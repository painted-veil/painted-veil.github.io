<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《图解TCPIP》学习笔记</title>
      <link href="/2021/10/05/TCPIP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/05/TCPIP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图解TCP-IP"><a href="#图解TCP-IP" class="headerlink" title="图解TCP/IP"></a>图解TCP/IP</h1><h2 id="1、网络基础知识"><a href="#1、网络基础知识" class="headerlink" title="1、网络基础知识"></a>1、网络基础知识</h2><h3 id="计算机与网路发展7个阶段"><a href="#计算机与网路发展7个阶段" class="headerlink" title="计算机与网路发展7个阶段"></a>计算机与网路发展7个阶段</h3><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p>事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的这些程序和数据能够一并批量得到处理的方式。</p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>多个终端（与同一个计算机连接，允许多个用户同时使用一台计算机的系统</p><h4 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a>计算机之间的通信</h4><h4 id="计算机网络产生"><a href="#计算机网络产生" class="headerlink" title="计算机网络产生"></a>计算机网络产生</h4><p>让各式各样的计算机相互 连接，从大型的超级计算机或主机到小型的个人电脑。</p><h4 id="互联网普及"><a href="#互联网普及" class="headerlink" title="互联网普及"></a>互联网普及</h4><h4 id="互联网技术为中心的时代"><a href="#互联网技术为中心的时代" class="headerlink" title="互联网技术为中心的时代"></a>互联网技术为中心的时代</h4><h4 id="从单纯建立连接到安全建立连接"><a href="#从单纯建立连接到安全建立连接" class="headerlink" title="从单纯建立连接到安全建立连接"></a>从单纯建立连接到安全建立连接</h4><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那 些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。</p><h4 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h4><p>分组交换是指将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。</p><h3 id="协议分层与OSI参考模型"><a href="#协议分层与OSI参考模型" class="headerlink" title="协议分层与OSI参考模型"></a>协议分层与OSI参考模型</h3><h4 id="协议的分层"><a href="#协议的分层" class="headerlink" title="协议的分层"></a>协议的分层</h4><p>通信协议 设计指标的OSI参考模型。这一模型将通信协议中必要的功能分成了7层。每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服 务。上下层之间进行交互时所遵循的约定叫做“接口”。同一层之间的交互所遵循的约定叫做“协议”。</p><h4 id="OSI参考模型中各个分层的作用"><a href="#OSI参考模型中各个分层的作用" class="headerlink" title="OSI参考模型中各个分层的作用"></a>OSI参考模型中各个分层的作用</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211005154427838.png" alt="image-20211005154427838"></p><p>■ 表示层 将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。 </p><p> ■ 会话层负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p><p> ■ 传输层起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</p><p> ■ 网络层将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。</p><p> ■ 数据链路层 负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。 将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。</p><p> ■ 物理层 负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。相互直连的设备之间使用地址实现传输。这种地址被称为MAC 地址，也可称为物理地址或 硬件地址。采用MAC地址，目的是为了识别连接到同一个传输介质上的设备</p><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>网卡集成了NIC，没有配置NIC的计算机如果想接入以太网，至少得外接一个扩展槽以便插入NIC。无线局域网的情况下也是如 此，计算机必须具备能够接入无线网的NIC才能保证连接到网络</p><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>中继器是在OSI模型的第1层——物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。</p><h4 id="网桥-2层交换机"><a href="#网桥-2层交换机" class="headerlink" title="网桥/2层交换机"></a>网桥/2层交换机</h4><p>网桥是在OSI模型的第2层——数据链路层面上连接两个网络的设备。它能够识别数据链路层中的数据帧 ，并将这些 数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。</p><h4 id="路由器-3层交换机"><a href="#路由器-3层交换机" class="headerlink" title="路由器/3层交换机"></a>路由器/3层交换机</h4><p>路由器是在OSI模型的第3层——网络层面上连接两个网络、并对分组报文进行转发的设备。网桥是根据物理地址进行处理，而路由器/3层交换机则是根据IP地址进行处理的。由此，TCP/IP中网络层的地址就成为了IP地址。</p><h4 id="4-7层交换机"><a href="#4-7层交换机" class="headerlink" title="4-7层交换机"></a>4-7层交换机</h4><p>4～7层交换机负责处理OSI模型中从传输层至应用层的数据。4～7层交换机就是以TCP等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。它与4～7层交换机一样都是处理传输层及以上的数据，但是网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信。</p><h2 id="2、TCP-IP基础知识"><a href="#2、TCP-IP基础知识" class="headerlink" title="2、TCP/IP基础知识"></a>2、TCP/IP基础知识</h2><p>20实际70年代前半叶，ARPANET中一个研究机构研发楚TCP/IP,1982，其具体规范才最终定下来，并于1983成为ARPANET网络唯一指定的协议。</p><h3 id="TCP-IP标准化"><a href="#TCP-IP标准化" class="headerlink" title="TCP/IP标准化"></a>TCP/IP标准化</h3><h4 id="TCP-IP具体含义"><a href="#TCP-IP具体含义" class="headerlink" title="TCP/IP具体含义"></a>TCP/IP具体含义</h4><p>具体来说，IP或 ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP的协议，TCP/IP一词泛指这些协议，因此，有时也称TCP/IP为网际协议族</p><h4 id="TCP-IP规范——RFC"><a href="#TCP-IP规范——RFC" class="headerlink" title="TCP/IP规范——RFC"></a>TCP/IP规范——RFC</h4><p>需要标准化的协议，被人们列入RFC文档在网上公布， RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息 ，以及实验方面的信息 。</p><h3 id="互联网基础知识"><a href="#互联网基础知识" class="headerlink" title="互联网基础知识"></a>互联网基础知识</h3><p>互联网进行通信时，需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族。</p><h4 id="互联网结构"><a href="#互联网结构" class="headerlink" title="互联网结构"></a>互联网结构</h4><p>互联网中的每个网络都是由骨干网和末端网组成的。每个网络之间通过 NOC（网络操作中心）相连。如果网络的运营商不同，它的网络连接方式 和使用方法也会不同。连接这种异构网络需要有IX(网络交换中心)的支持</p><h4 id="ISP和区域网"><a href="#ISP和区域网" class="headerlink" title="ISP和区域网"></a>ISP和区域网</h4><p>连接互联网需要向ISP或区域网提出申请，不同ISP提供的互联网接入服务像雾i不同。</p><h3 id="TCP-IP协议分层模块"><a href="#TCP-IP协议分层模块" class="headerlink" title="TCP/IP协议分层模块"></a>TCP/IP协议分层模块</h3><h4 id="TCP-IP与OSI参考模型"><a href="#TCP-IP与OSI参考模型" class="headerlink" title="TCP/IP与OSI参考模型"></a>TCP/IP与OSI参考模型</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211009132825080.png" alt="image-20211009132825080"></p><h4 id="硬件（物理层）"><a href="#硬件（物理层）" class="headerlink" title="硬件（物理层）"></a>硬件（物理层）</h4><p>TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。</p><h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。可以当作给NIC起作用的驱动程序。</p><h4 id="互联网层"><a href="#互联网层" class="headerlink" title="互联网层"></a>互联网层</h4><p>IP协议基于IP地址转发分包数据。TCP/IP分层中的互联网层与传输层的功能通常由操作系统提供。尤其是路由器，必须得实现通过互联网层转发分组数据包的功能。</p><h5 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h5><p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一 端，这期间它使用IP地址作为主机的标识。</p><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><p>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，ICMP需要给发送端发送一个发生异常的通知，有时也被用来诊断网络的健康状况。</p><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><p>从分组数据包的IP地址中解析出物理地址（MAC地址）的一种协议。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>与OSI参考模型中的传输层类似。</p><p>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同一时间运行着多个程序。 为此，必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。</p><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><p>面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。但是为提高网络利用率，TCP定义了各种规范，因此不利于视频会议。</p><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><p>是一种面向无连接的传输层协议。不会关注对端是否真的收到了传送过去的数 据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。常用于分组数据较少以及视频通信等多媒体领域。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现</p><h5 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h5><p>远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能。TCP/IP网络中远程登录常用TELNET和SSH两种协议、</p><h5 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h5><p>文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思，使用的协议叫做FTP。</p><h5 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h5><p>在TCP/IP中进行网络管理时，采用SNMP协议，使用该协议管理的主机网桥路由器称作SNMP代理而进行管理那一段叫做管理器。</p><h4 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h4><h5 id="TCP-IP通信过程"><a href="#TCP-IP通信过程" class="headerlink" title="TCP/IP通信过程"></a>TCP/IP通信过程</h5><h6 id="应用程序处理"><a href="#应用程序处理" class="headerlink" title="应用程序处理"></a>应用程序处理</h6><h6 id="TCP模块的处理"><a href="#TCP模块的处理" class="headerlink" title="TCP模块的处理"></a>TCP模块的处理</h6><p>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输。</p><h6 id="IP模块的处理"><a href="#IP模块的处理" class="headerlink" title="IP模块的处理"></a>IP模块的处理</h6><p>IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端在加上自己的IP首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含接收端IP地址以及发送端IP地址。</p><h6 id="网络接口的处理"><a href="#网络接口的处理" class="headerlink" title="网络接口的处理"></a>网络接口的处理</h6><p>从IP传过来的IP包，对于以太网驱动来说不过就是数据。给这数据附加上以太网首部并进行发送处理。 以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。</p><h4 id="经过数据链路的包"><a href="#经过数据链路的包" class="headerlink" title="经过数据链路的包"></a>经过数据链路的包</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211009195455224.png" alt="image-20211009195455224"></p><p>每个包首部至少都会包含两个信息：一个是发送端和接收端地址，另一个上一层的协议类型。经过每个协议分层时，都必须有识别包发送端和接收端的信息。此外每个分层的包首部还包含一个识别位，用来识别上一层协议的种类信息。</p><h4 id="数据包接收处理"><a href="#数据包接收处理" class="headerlink" title="数据包接收处理"></a>数据包接收处理</h4><p>包的接收过程就是发送流程的逆序过程。</p><h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><h3 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h3><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范，此外各个设备之间又是也会通过交换机、网桥中继器等中转数据。</p><h3 id="数据链路相关技术"><a href="#数据链路相关技术" class="headerlink" title="数据链路相关技术"></a>数据链路相关技术</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC地址用于识别数据链路中互连的节点</p><p>MAC地址长48比特，MAC地址一般会被烧入到ROM 中。因此，任何一个网卡的MAC地址都是唯一的，在全世界都不会有重复</p><p>MAC地址中3～24位表示厂商识别码，每个NIC厂商都有特定唯一的识别数字。25～48位是 厂商内部为识别每个网卡而用。因此，可以保证全世界不会有相同MAC地址的网卡。不论哪种数据链路的网络都不会以相同的MAC地址出现。</p><h4 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h4><p>通信介质的使用方法上，网络可分为共享介质型和非共享型。</p><p>共享介质型网络指由多个设备共享一个通信介质的一种网络。</p><h5 id="争用方式"><a href="#争用方式" class="headerlink" title="争用方式"></a>争用方式</h5><p>争夺获取数据传输的权力，也叫CSMA，令网络中各个站，采用先到先得的方式占用信道发送数据，如果多个站同时发送帧，则会产生冲突现象，也会导致网络拥堵和性能下降。第二种CSMA/CD（CSMA的改进）要求每个站提前检查冲突，一旦发生冲突，则尽早释放信道。</p><p>具体工作原理：</p><p>1、如果载波信道上没有数据流动，则任何站都可以发送数据。 </p><p>2、检查是否会发生冲突。一旦发生冲突时，放弃发送数据，同时立即释放载波信道。 </p><p>3、放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</p><h5 id="令牌传递方式"><a href="#令牌传递方式" class="headerlink" title="令牌传递方式"></a>令牌传递方式</h5><p>沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式，只有获得令牌的站才能发送数据，这样一是不会有冲突，二是每个站都有通过平等循环获得令牌的机会，因此，即使网络拥堵也不会导致性能下降。</p><h3 id="非共享介质网络"><a href="#非共享介质网络" class="headerlink" title="非共享介质网络"></a>非共享介质网络</h3><p>非共享介质网络是指不共享介质，是对介质采取专用的一种传输控制方式。不仅ATM采用，也成为以太网的主流方式，可实现全双工通信</p><h4 id="根据MAC地址转发"><a href="#根据MAC地址转发" class="headerlink" title="根据MAC地址转发"></a>根据MAC地址转发</h4><p>以太网交换机就是持有多个端口的网桥。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表。转发表可自动生成。</p><p>数据链路层的每 个通过点在接到包时，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。以某个MAC地址作为源地址的包由某一接口接收，实质上可以理解为MAC地址就是该接口的 目标。以该MAC地址作为目标地址的包，经由该接口送出即可。</p><p>MAC地址没有层次性，转发表的入口个数于整个数据链路中所有网络设备的数量有关，当设备数量增加时，转发表也会随之变大。因此需要对地址进行分层管理。</p><h4 id="环路检测技术"><a href="#环路检测技术" class="headerlink" title="环路检测技术"></a>环路检测技术</h4><h5 id="生成树方式"><a href="#生成树方式" class="headerlink" title="生成树方式"></a>生成树方式</h5><p>每个网桥必须在每1-10秒内互相交换BPDU包，从而判断哪些端口使用，一遍消除环路，一旦发生故障则自动切换通信线路，利用哪些没有被使用的端口继续进行传输。</p><p>以某一个网桥为构造树的根，并对每个端口设置权重。这一权重可以由网络管理员适当地设置，指定优先使用哪些端口以及发生问题时该使用哪些端口。</p><p>弊端是发生故障切换网络时需要几十秒的时间，因此使用RSTP的方法将恢复时间缩短到几秒内。</p><h5 id="源路由法"><a href="#源路由法" class="headerlink" title="源路由法"></a>源路由法</h5><p>解决令牌环网络的问题，该方式可以判断发送数据的源地址是通过哪个网桥实现传输的，并将帧写入RIF，网桥则根据这个RIF信息发送帧给目标地址。因此，即使网桥中出现了环路，数据帧也不会被反复转发，可成功地发送到目标地址。在这种机制中发送端本身必须具备源路由的功能。</p><h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>采用VLAN则不用修改网络布线只需要修改网络的结构即可，VLAN技术附加到网桥/2层交换 机上，就可以切断所有VLAN之间的所有通信。因此，相比一般的网桥/2层交换机，VLAN可以过滤多余的包，提高网络的承载效率。</p><p>VLAN是通过交换机按照其端口区分了多个网段，从而区分了广播数据传 播的范围、减少了网络负载并提高了网络的安全性。然而异构的两个网段之间，就需要利用具有路由功能的交换机（如3层交换机），或在各段中间通过路由器的连接才能实现通信。</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><h4 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h4><p>随着互联设备处理能力提高，一般采用终端与交换机之间独占电缆的方式</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>以太网前端有一个叫做前导码的部分，它有0，1数字交替组合而成，表示一个以以太网帧的开始，也是对端网卡能够确保与其同步的标志。</p><p>以太网帧本体的前端是以太网的首部，它总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p><p>紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是46～1500个字节。帧尾是一个叫做FCS的4个字节。在目标MAC地址中存放了目标工作站的物理地址。源MAC地址中则存放构造以太网帧的发送端工作站的物理地址。</p><h3 id="无线通信"><a href="#无线通信" class="headerlink" title="无线通信"></a>无线通信</h3><p>无线通信，依据通信距离可分为不同的类型。IEEE802委员会制定了无线PAN、无线LAN、无线MAN以及无线RAN等无线标准。无线 WAN的最典型代表就是手机通信。手机通过基站能够实现长距离通信。</p><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>PPP是指点对点，即一对一连接计算机协议，相当于OSI参考模型第二层的数据链路层。仅有PP无法实现通信还需要有物理层的支持</p><h4 id="LCP与NCP"><a href="#LCP与NCP" class="headerlink" title="LCP与NCP"></a>LCP与NCP</h4><p>不依赖上层的LCP协议,一个是依赖上层的NCP协议.如果上层为IP，此时的NCP也叫做IPCP.</p><p>LCP主要负责建立和断开连接,设置最大接收单元,设置验证协议以及设置是否进行通信质量的监控.</p><p>而IPCP则负责IP地址设置以及是否进行TCP/IP首部压缩等设备</p><p>通过PPP连接时，通常需要进行用户名密码的验证，并且对通信两端进行双方向的验证。其验证协议有两种，分别为PAP和CHAP</p><p>PAP是PPP连接建立时，通过两次握手进行用户名和密码验证。其中密码以明文方式传输。因此一般用于安全要求并不很高的环境，否则会有窃听或盗用连接的危险。 CHAP则使用一次性密码OTP，可以有效防止窃听。此外，在建立连接后还可以进行定期的密码交换，用来检验对端是否中途被替换。</p><h4 id="PPP的帧格式"><a href="#PPP的帧格式" class="headerlink" title="PPP的帧格式"></a>PPP的帧格式</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211011132228026.png" alt="image-20211011132228026"></p><h4 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h4><p>互联网接入服务商在以太网利用PPPoe提供PPP功能</p><h3 id="其他数据链路"><a href="#其他数据链路" class="headerlink" title="其他数据链路"></a>其他数据链路</h3><h4 id="ATM"><a href="#ATM" class="headerlink" title="ATM"></a>ATM</h4><p>以一个叫做信元的单位进行传输数据黎安路,由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接.</p><p>ATM的一个信元只能发送固定的48字节数据</p><p>因此在ATM网中即使只是一个信元丢失，也要重新发送最多192个信元。这也是ATM到目前为止的 最大弊端。一旦在网络拥堵的情况下，只要丢掉哪怕1％的信元也会导致整个数据都无法接收。特别是由于 ATM没有发送权限上的控制，很容易导致网络收敛。</p><h4 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h4><p>是一种在SDH上进行包通信的一种协议.SDH是在光纤上传输数字信号的物理层规范,</p><h4 id="FFDI"><a href="#FFDI" class="headerlink" title="FFDI"></a>FFDI</h4><p>分布式光线数据接口,采用令牌环的访问方式,在网络拥堵情况下极容易导致网络收敛.</p><h3 id="公共网络"><a href="#公共网络" class="headerlink" title="公共网络"></a>公共网络</h3><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>网络服务商提供一种在IP网络上使用MPLS技术构建VPN的服务。其中MPLS在IP包中附加一个叫做标签信息进行传输控 制。每个用户的标签信息不同，因此在通过MPLS网时，可以轻松地判断出目标地址。这样一来就可以将多 个不同用户的VPN信息通过MPLS网加以区分，形成封闭的私有网络。此外，还能进行用户级的带宽控制。</p><p>除了使用服务提供商的IP-VPN服务之外，有时企业还可以在互联网上建立自己的VPN,一般采用IPsec</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="IP即网际协议"><a href="#IP即网际协议" class="headerlink" title="IP即网际协议"></a>IP即网际协议</h3><p>TCP/IP心脏是互联网层</p><p>IP相当于OSI参考模型中的第3层——网络层。</p><p>网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点“通信。一旦跨越多种数据链路就需要借助网络层，即使在不同的数据链路上也能实现两端节点之间的数据包传输。</p><p>数据链路层与网络层的关系就像行程表和车票的关系。</p><h3 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><h4 id="IP地址属于网络层地址"><a href="#IP地址属于网络层地址" class="headerlink" title="IP地址属于网络层地址"></a>IP地址属于网络层地址</h4><p>IP地址用于在连接到网络中所有主机中识别出进行通信的目标地址。在TCP/IP通信中所有主机或路由器必须设定自己的IP地址。无论与那种数据链路连接，IP地址形式都保持不变。</p><p>在网桥或交换集线器等物理层或数据链路层数据包转发设备中，不需要设置IP地址</p><h4 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h4><p>将分组数据发送到最终目标地址的功能，即使网络非常复杂，也可以通过路由控制确定到达目标地址的通路。如果出现异常则分组数据迷失。</p><p>IP包正是在网络中一个个跳间被转发，因此IP路由也叫做多跳路由。</p><p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有通路全都指定出来。</p><h4 id="数据链路的抽象化"><a href="#数据链路的抽象化" class="headerlink" title="数据链路的抽象化"></a>数据链路的抽象化</h4><p>IP实现多个数据链路之间通信的协议，不同的数据链路最大区别就是各自最大传输单位不同。</p><h4 id="IP属于面向连接型"><a href="#IP属于面向连接型" class="headerlink" title="IP属于面向连接型"></a>IP属于面向连接型</h4><p>IP面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。</p><p><strong>采用无连接原因</strong></p><p>一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此项服务。</p><h3 id="IP基础知识-1"><a href="#IP基础知识-1" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><h4 id="IP地址由网络和主机两部分标识组成。"><a href="#IP地址由网络和主机两部分标识组成。" class="headerlink" title="IP地址由网络和主机两部分标识组成。"></a>IP地址由网络和主机两部分标识组成。</h4><p>网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p><h4 id="IP地址的分类。"><a href="#IP地址的分类。" class="headerlink" title="IP地址的分类。"></a>IP地址的分类。</h4><h5 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h5><p>A类IP地址是首位以“0”开头的地址。从第1位到第8位是它的网络标识。</p><h5 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h5><p>B类IP地址是前两位为“10”的地址，从第1位到第16位是它的网络标识。</p><h5 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h5><p>C类IP地址是前三位为“110”的地址，从第1位到第24位是它的网络标识。</p><h5 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h5><p>D类IP地址是前四位为“1110”的地址。从第1位到第32位是它的网络标识。</p><h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址</p><p>广播分为本地广播和直接广播两种</p><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><p>同时发送提高效率，对于向多台主机同时发送数据包，多播使用D类地址，从224.0.0.0到239.255.255.255都是多播地址的可用范围。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>由于直接使用ABC类地址显得浪费资源。</p><p>引入子网后，一个IP地址就种识别码，一是IP地址本身，另一个是表示网络部的子网掩码。</p><p>它对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是IP地址的首位开始连续的“1”</p><h4 id="全局地址与私有地址"><a href="#全局地址与私有地址" class="headerlink" title="全局地址与私有地址"></a>全局地址与私有地址</h4><p>全局IP地址基本上要在整个互联网范围内保持唯一。</p><p>私有IP地址结合NAT技术已成为现在解决IP地址分配问题的主流方案。</p><h4 id="全局地址由谁决定"><a href="#全局地址由谁决定" class="headerlink" title="全局地址由谁决定"></a>全局地址由谁决定</h4><p>在世界范围内，全局IP由ICANN进行管理。</p><h3 id="路由控制-1"><a href="#路由控制-1" class="headerlink" title="路由控制"></a>路由控制</h3><h4 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h4><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p><h4 id="路由表的聚合"><a href="#路由表的聚合" class="headerlink" title="路由表的聚合"></a>路由表的聚合</h4><p>利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码，对外呈现出的也是同一个网络地址。这样可以更好构建网络，通过路由信息的聚合可以有效减少路由表的条目。</p><h3 id="IP分割处理与再构成处理"><a href="#IP分割处理与再构成处理" class="headerlink" title="IP分割处理与再构成处理"></a>IP分割处理与再构成处理</h3><p>数据链路不同，则MTU相异</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>为了根本解决决IPv4地址耗尽的问题而被标准化的网际协议。</p><h4 id="IPv6特点"><a href="#IPv6特点" class="headerlink" title="IPv6特点"></a>IPv6特点</h4><p>IP地址的扩大与路由控制表聚合</p><p>性能提升</p><p>支持即插即用</p><p>采用认证与加密功能</p><p>多播、Mobile IP成为扩展功能</p><h4 id="IPv6中IP地址结构"><a href="#IPv6中IP地址结构" class="headerlink" title="IPv6中IP地址结构"></a>IPv6中IP地址结构</h4><p>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配IP地址。</p><p>限制型网络，即那些不与互联网直接接入的私有网络，可以使用唯一本地地址。</p><p>该地址根据一定的算法生成随机数并融合到地址当中，可以像IPv4的私有地址一样自由使用。</p><h4 id="IPv6分段处理"><a href="#IPv6分段处理" class="headerlink" title="IPv6分段处理"></a>IPv6分段处理</h4><p>IPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</p><h3 id="IPv6首部格式"><a href="#IPv6首部格式" class="headerlink" title="IPv6首部格式"></a>IPv6首部格式</h3><p>IPv6中为了减轻路由器的负担，省略了首部校验和字段</p><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><p>在数据链路层也不使用IP地址。在以太网的情况下只使用MAC地址传输数据包。而实际上将众多IP数据包在网络上进行传送的就是数据链路本身，因此必须了解发送端MAC地址</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS可以将访问网站的字符串自动转化为具体的IP地址</p><h4 id="DNS产生"><a href="#DNS产生" class="headerlink" title="DNS产生"></a>DNS产生</h4><p>在应用中，当用户输入主机名（域名）时，DNS会自动检索那个注册了主机名和IP地址的数据库，并迅速定位相应的IP地址。每台计算机有唯一的主机名在进行网络通信必须自动将主机名转化为具体的IP地址，因此主机会利用一个叫做hosts的数据库文件。</p><h4 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h4><p>域名是指为了识别主机名称和组织结构名称的一种具有分层的名称。</p><p>在使用域名时，可以在每个主机名后面追加上组织机构的域名，单凭主机名还无法完全管理IP地址，因为在不同的组织机构中不允许有同名的主机，但出现了带有层次结构的域名后每一个组织机构就可以自由地为主机命名了</p><p>域名服务器：管理域名的主机和相应的软件，可以管理所在分层的域的相关信息，所管理的分层叫ZONE</p><p>根部所设置的DNS叫做根域名服务器。它对DNS的检索数据功能起着至关重要的作用</p><h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211013103530002.png" alt="image-20211013103530002"></p><h3 id="ARP-1"><a href="#ARP-1" class="headerlink" title="ARP"></a>ARP</h3><p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。</p><h4 id="ARP工作机制"><a href="#ARP工作机制" class="headerlink" title="ARP工作机制"></a>ARP工作机制</h4><p>从一个IP地址发送ARP请求包以了解其MAC地址目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址，由此可以获得MAC地址，实现链路内的IP通信。</p><p>根据ARP可以动态地进行地址解析，在TCP/IP的网络构造和网络通信中无需事先知道MAC地址是什么，只要有IP地址即可。</p><p>如果每发送一个IP数据报都要进行一次ARP请求以此确定MAC地址，那将会造成不必要的网络流量，因此把获取到的MAC地址缓存一段时间，下一次就不需要重新发送ARP请求，而是直接使用这个缓存表当中MAC地址进行数据报的发送，每执行一次ARP，对应的缓存内容都会被清除。</p><h4 id="RAPP"><a href="#RAPP" class="headerlink" title="RAPP"></a>RAPP</h4><p>RARP是将ARP反过来，从MAC地址定位IP地址的一种协议。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p><h4 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h4><p>通常ARP包会被路由器隔离，但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><h3 id="ICMP-1"><a href="#ICMP-1" class="headerlink" title="ICMP"></a>ICMP</h3><p>CMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p><h4 id="ICMP的消息"><a href="#ICMP的消息" class="headerlink" title="ICMP的消息"></a>ICMP的消息</h4><h5 id="ICMP目标不可达消息"><a href="#ICMP目标不可达消息" class="headerlink" title="ICMP目标不可达消息"></a>ICMP目标不可达消息</h5><p>IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达的ICMP罅隙，并在这个消息中显示不可达的具体原因</p><h5 id="ICMP重定向消息"><a href="#ICMP重定向消息" class="headerlink" title="ICMP重定向消息"></a>ICMP重定向消息</h5><p>如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的ICMP消息发送给发送端主机一个跟适合的发送路由。</p><h5 id="ICMP超时消息"><a href="#ICMP超时消息" class="headerlink" title="ICMP超时消息"></a>ICMP超时消息</h5><p>IP包中有一个字段叫做生存周期，它的值是随着每经过一次路由器就会减1，直到减到0时该IP包会被丢弃，此时，IP路由器会发送一个ICMP超时的消息。</p><h5 id="ICMP回送消息"><a href="#ICMP回送消息" class="headerlink" title="ICMP回送消息"></a>ICMP回送消息</h5><p>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，可以下向对端主机发送回送请求的消息，也可以接收对端主机发回来的回送应答消息。</p><h4 id="其他ICMP消息"><a href="#其他ICMP消息" class="headerlink" title="其他ICMP消息"></a>其他ICMP消息</h4><h5 id="ICMP原点抑制消息"><a href="#ICMP原点抑制消息" class="headerlink" title="ICMP原点抑制消息"></a>ICMP原点抑制消息</h5><p>在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题。ICMP原点抑制消息的目的就是为了缓和这种拥堵情况。</p><h5 id="ICMP路由器探索消息"><a href="#ICMP路由器探索消息" class="headerlink" title="ICMP路由器探索消息"></a>ICMP路由器探索消息</h5><p>主要用于发现与自己相连网络中的路由器。</p><h5 id="ICMP地址掩码消息"><a href="#ICMP地址掩码消息" class="headerlink" title="ICMP地址掩码消息"></a>ICMP地址掩码消息</h5><p>主要用于主机或路由器想要了解子网掩码的情况。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP。在IPv4或者IPv6也可以使用。</p><h4 id="DHCP工作机制"><a href="#DHCP工作机制" class="headerlink" title="DHCP工作机制"></a>DHCP工作机制</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211013205226256.png" alt="image-20211013205226256"></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT技术，由此可以实现用一个全局IP地址与多个主机的通信。</p><h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><p>网络A、B使用IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信。为了让它们之间正常通信，这时必须得采用IP隧道的功能。</p><h4 id="其他IP相关技术"><a href="#其他IP相关技术" class="headerlink" title="其他IP相关技术"></a>其他IP相关技术</h4><h4 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h4><p>IP任播主要用于报警电话110与消防电话119系统，IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法</p><h4 id="显式拥塞通知"><a href="#显式拥塞通知" class="headerlink" title="显式拥塞通知"></a>显式拥塞通知</h4><p>当发生网络拥塞时，发送主机应该减少数据包的发送量。因此使用ECN来实现拥塞通知的功能，将IP首部的TOS字段置换为ENC字段，并在TCP首部的保留位中追加CWR 标志和ECE标志。</p><h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><p>TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端</p><h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h4><p>UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小,却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><h4 id="TCP与UDP的区分"><a href="#TCP与UDP的区分" class="headerlink" title="TCP与UDP的区分"></a>TCP与UDP的区分</h4><p>TCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。</p><p>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</p><h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211015123702097.png" alt="image-20211015123702097"></p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><h4 id="根据端口识别应用"><a href="#根据端口识别应用" class="headerlink" title="根据端口识别应用"></a>根据端口识别应用</h4><p>一台计算机上同时可以运行多个程序，传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><h4 id="通过IP地址、端口号、协议号进行通信识别"><a href="#通过IP地址、端口号、协议号进行通信识别" class="headerlink" title="通过IP地址、端口号、协议号进行通信识别"></a>通过IP地址、端口号、协议号进行通信识别</h4><p>仅凭目标端口识别某一个通信是不够的</p><p>因此，TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”。只要其中某一项不同，则被认为是其他通信。</p><h4 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h4><h5 id="标准既定的端口号"><a href="#标准既定的端口号" class="headerlink" title="标准既定的端口号"></a>标准既定的端口号</h5><p>每个应用程序都有其指定的端口号，每个端口号都有其对应的使用目的，不可以随意使用任何一个端口号</p><h5 id="时序分配方法"><a href="#时序分配方法" class="headerlink" title="时序分配方法"></a>时序分配方法</h5><p>此时服务端有必要确定监听端口号，接收服务的客户端没必要确定端口号</p><p>操作系统可以为每个应用层序分配互不冲突的端口号。</p><p>动态分配的端口号取值范围在49152到65535之间。</p><h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>端口号由其使用的传输层协议来决定，因此不同的传输协议可以使用相同的端口号。</p><p>数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。如果是TCP则传给TCP模块、如果是UDP则传给UDP模块去做端口号的处理。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不会受到影响。</p><h3 id="UDP-2"><a href="#UDP-2" class="headerlink" title="UDP"></a>UDP</h3><h4 id="特点及目的"><a href="#特点及目的" class="headerlink" title="特点及目的"></a>特点及目的</h4><p>不提供复杂的控制机制，利用IP提供面向连接的通信服务，并且是将应用层序发来的数据在收到一刻，立刻原样发送到网络上。</p><p>即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由采用UDP的应用程序去处理。</p><p>因此UP经常面向无连接</p><p>包总量较少的通信如DNS，SNMP</p><p>视频、音频等多媒体通信</p><p>限定于LAN等特定网络中的应用通信</p><p>广播通信(广播、多播)</p><h3 id="TCP-2"><a href="#TCP-2" class="headerlink" title="TCP"></a>TCP</h3><p>实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制，是一种面向有连接的协议，只有在确认通信端存在时才会发送数据，从而可以控制流量良妃。</p><h4 id="特点与目的"><a href="#特点与目的" class="headerlink" title="特点与目的"></a>特点与目的</h4><p>TCP通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h4 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h4><p>在TCP中，当发送端的数据到达接受主机时，接收端主机会返回一个已收到的消息的通知，叫做确认应答（ACK）。</p><h4 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h4><p>最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</p><p>在每次发包时都会计算往返时间其偏差。将这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点的值。 </p><p>重发超时考虑偏差，是因为有可能根据网络环境的不同往返时间可能才会产生大幅度的摇摆，之所以发生这种情况是因为数据包的分段经过不同线路达到的，TCP/IP即使在这种情况下也要进行控制不要浪费网络流量。</p><p>数据重发还是收不到则将等待确认应答时间以指数函数延长且数据发送一定次数后如果依然没有确认就谁判断发生异常强制关闭连接。</p><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>可以使用TCP首部用于控制的字段来管理TCP连接，一个连接建立于断开至少需要来回发送7个包。</p><h4 id="TCP以段为单位发送数据"><a href="#TCP以段为单位发送数据" class="headerlink" title="TCP以段为单位发送数据"></a>TCP以段为单位发送数据</h4><p>建立TCP连接时确定数据包的单位成为最大消息长度，最理想是最大消息长度正好是IP中不会被分片处理的最大数据长度。</p><p>TCP在三次握手的时候在两端主机之间计算得出，两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后选择一个较小的值投入使用。</p><h4 id="利用窗口提高速度"><a href="#利用窗口提高速度" class="headerlink" title="利用窗口提高速度"></a>利用窗口提高速度</h4><p>引入窗口，即使在往返时间较长的情况下，它也能控制网络性能的下降。而发送端主机在发送一个段之后不必要等待确认应答，而是继续发送。</p><p>窗口大小指无需确认应答而可以继续发送数据最大值。该机制利用大量的缓冲区，通过对多个端同时进行确认应答的功能。</p><h4 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h4><p>如果使用窗口控制某些确认应答即使丢失也不需重发。</p><p>如果某个报文段丢失，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发，叫做高速重发控制。</p><h4 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h4><p>TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，操作是接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，该大小限度就被称作窗口大小。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>如果突然发送一个较大量的数据，可能会导致整个网络的瘫痪。所以利用拥塞控制解决。</p><h3 id="其他传输层协议"><a href="#其他传输层协议" class="headerlink" title="其他传输层协议"></a>其他传输层协议</h3><p>1、UDP-Lite</p><p>2、SCTP</p><p>3、DCCP</p><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><p>1、源端口号</p><p>2、目标端口号</p><p>3、包长度</p><p>4、校验</p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p>1、源端口号</p><p>2、目标端口号</p><p>3、序列号</p><p>4、确认应答号</p><p>5、数据偏移</p><p>6、保留</p><p>7、控制位</p><p>8、窗口大小</p><p>9、校验</p><p>10、紧急指针</p><p>11、选项</p><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="路由控制的定义"><a href="#路由控制的定义" class="headerlink" title="路由控制的定义"></a>路由控制的定义</h3><p>互联网是由路由器连接的网络组合而成的。为了能让数据包正确达地到达目标主机，路由器必须在途中进行正确地转发。这种向“正确的方向”转发数据所进行的处理就叫做路由控制或路由。</p><p>路由器根据路由控制表转发数据包，根据所获到的数据包中目标主机的IPD地址与路由控制表的比较得出下一个应该接受的路由器，因此路由控制表的记录一定要正确无误。</p><h4 id="动态路由静态路由"><a href="#动态路由静态路由" class="headerlink" title="动态路由静态路由"></a>动态路由静态路由</h4><p>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法。而动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。</p><p>使用动态路由管理员必须设置好路由协议。对于路由器个数较多的网络采用动态路由显然是一个能够捡起管理员负担的方法，</p><p>两种路由要组合使用</p><h4 id="动态路由的基础"><a href="#动态路由的基础" class="headerlink" title="动态路由的基础"></a>动态路由的基础</h4><p>给相邻路由器发送自己已知的网络连接信息，而这些信息由传递给其他路由器，直至真个网络路由器路由控制表也就制作完成。</p><h3 id="路由控制范围"><a href="#路由控制范围" class="headerlink" title="路由控制范围"></a>路由控制范围</h3><p>人们根据路由控制范围常使用IGP和EGP</p><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p>制定自己的路由策略，并以此为准在一个或多个网络群体中采用的小型单位叫做自治系统或路由选择域。</p><p>自治系统内部动态路由采用的协议是域内路由协议，即IGP。而自治系统之间的路由控制采用的是域间路由协议，即EGP。</p><h4 id="IGP与EGP"><a href="#IGP与EGP" class="headerlink" title="IGP与EGP"></a>IGP与EGP</h4><p>路由协议大致分为两大类。一类是外部网关协议EGP，另一类是内部网关协议IGP</p><p>没有EGP就不可能有世界上各个不同组织机构之间的通 信。没有IGP机构内部也就不可能进行通信。</p><p>IGP还可以使用RIP等众多协议，EGP则使用的是BGP协议。</p><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p>根据距离和方向决定目标网络或目标主机位置一种方法。路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。</p><h4 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h4><p>链路状态算法中所有路由器持有相同的信息。对于任何一台路由器，网络拓扑都完全一样。因此，只要某一台路由器与其他路由器保持同样的路由控制信息，就意味着该路由器上的路由信息是正确的。只要每个路由器尽快地与其他路由器同步路由信息，路由信息就可以达到一个稳定的状态。</p><p>因此无论网络结构变得负责，路由器能够保持正确的路由信息。</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>是距离向量型一种路由协议，广泛用于LAN</p><h4 id="广播路由控制信息"><a href="#广播路由控制信息" class="headerlink" title="广播路由控制信息"></a>广播路由控制信息</h4><p>RIP将路由控制信息向全网广播，如果没有收到路由控制信息，连接就会断开，如果等了6次没有收到路由信息，才会真正关闭连接。</p><h4 id="根据距离向量确定路由"><a href="#根据距离向量确定路由" class="headerlink" title="根据距离向量确定路由"></a>根据距离向量确定路由</h4><p>RIP基于距离向量算法决定路径。距离的单位为“跳数”。跳数是指所经过的路由器的个数。RIP尽可能少通过路由器将数据包转发到目标IP地址，根据距离向量生成距离向量表，再抽出较小的路由生成最终的路由控制表。</p><h4 id="使用子网掩码时的RIP处理"><a href="#使用子网掩码时的RIP处理" class="headerlink" title="使用子网掩码时的RIP处理"></a>使用子网掩码时的RIP处理</h4><p>RIP虽然不交换子网掩码，但用于使用子网掩码的网络环境。同时这种情况下要注意以下几点</p><p>1、从接口的IP地址对应分类得出网络地址后，与根据路由控制信息流过此路由器的包中的IP地址对应的分类得出的网络地址进行比较。如果两者的网络地址相同，那么就以接口的网络地址长度为准。</p><p>2、如果两者的网络地址不同，那么以IP地址的分类所确定的网络地址长度为准。</p><h4 id="RIP中路由变更时的处理"><a href="#RIP中路由变更时的处理" class="headerlink" title="RIP中路由变更时的处理"></a>RIP中路由变更时的处理</h4><p>毒性逆转是指当网络中发生链路被断开的时候，不是不再发送这个消息，而是将这个无法通信的消息传播出去。</p><p>触发更新是指当路由信息发生变化时，不等待30秒而是立刻发送出去</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>根据OSI的IS-IS协议而提出的一种链路状态型路由协议。由于采用链路状态类型，所以即使网络中有环路，也能够进行稳定的路由控制。</p><p>OSPF为链路状态型路由器。路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表。</p><h4 id="OSPF基础知识"><a href="#OSPF基础知识" class="headerlink" title="OSPF基础知识"></a>OSPF基础知识</h4><p>在OSPF中，把连接到同一个链路的路由器称作相邻路由器，在一个比较复杂的网络中如同一链路中加入了以太网就不需要所有相邻的路由器之间都进行控制信息交换，而是确定一个指定路由器并以它为中心交换路由信息。</p><p>在OSDP根据作用可以分为5种类型的包</p><h4 id="OSPF工作原理"><a href="#OSPF工作原理" class="headerlink" title="OSPF工作原理"></a>OSPF工作原理</h4><p>OSPF中进行连接确认的协议叫做HELLO协议。</p><p>LAN中每10秒发送一个HELLO包。如果没有HELLO包到达，则进行连接是否断开的判断。后在进行连接断开或恢复连接操作时，由于链路状态发生了变化，路由器会发送一个链路状态更新包通知其他路由器网络状态的变化。</p><h4 id="将区域分层化进行细分管理"><a href="#将区域分层化进行细分管理" class="headerlink" title="将区域分层化进行细分管理"></a>将区域分层化进行细分管理</h4><p>链路状态型路由协议的潜在问题在于，当网络规模越来越大时，表示链路状态的拓扑数据库就变得越来 越大，路由控制信息的计算也就越困难。OSPF为了减少计算负荷，引入了区域的概念。</p><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>边界网关协议是连接不同组织机构的一种协议，因此属于外部网关协议。</p><h4 id="BGP和AS号"><a href="#BGP和AS号" class="headerlink" title="BGP和AS号"></a>BGP和AS号</h4><p>在RIP和OSPF中利用IP的网络地址部分进行着路由控制，然而BGP则需要放眼整个互联网进行路由控制。BGP的最终路由控制表由网络地址和下一站的路由器组来表示，不过它会根据所要经过的AS个数进行路由控制。</p><h4 id="BGP是路径向量协议"><a href="#BGP是路径向量协议" class="headerlink" title="BGP是路径向量协议"></a>BGP是路径向量协议</h4><p>根据BGP交换路由控制信息的路由器叫做BGP扬声器。BGP扬声器为了在AS之间交换BGP信息，必须与所有AS建立对等的BGP连接。</p><p>BGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表。这个表格叫做AS路径信息访问列表。</p><h3 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h3><p>路由技术基于IP地址中最长匹配原则进行转发，而标记交换则对每个IP包都设定一个叫做“标记”的值，然后根据这个“标记”再进行转发。标记交换技术中最具代表性的当属多协议标记交换技术，即MPLS。</p><p>MPLS不像MAC直接对应到硬件设备，因此不需要数据链路层协议的作用。</p><h4 id="MPLS的网络基本的动作"><a href="#MPLS的网络基本的动作" class="headerlink" title="MPLS的网络基本的动作"></a>MPLS的网络基本的动作</h4><p>MPLS网络中实现MPLS功能的路由器叫做标记交换路由器（LSR）。特别是与外部网路连接的那部分LSR叫做标记边缘路由器（LER）。MPLS正是在LER上对数据包进行追加标记和删除标记的操作。</p><p>在一个数据包上附加标记是一个及其简单的动作。如果数据链路本来就有一个相当于标记的信息，那么可以直接进行映射。如果没有携带任何标记信息，需要追加一个全新的垫片头，来包含标记信息。</p><p>扩展LSP有两种方式。可以通过各个LSR向自己邻接的LSR分配MPLS标记，也可以由路由协议载着标记信息进行交互。LSP属于单方向的通路，如果需要双向的通信则需要两个LSP。</p><h4 id="MPLS的优点"><a href="#MPLS的优点" class="headerlink" title="MPLS的优点"></a>MPLS的优点</h4><p>转发速度块，使用固定长度的标记信息，使得处理更加简单，可以高速的硬件实现转发，此外相比互联网中的主干路由器需要保存大量路由表才能进行处理的现状，MPLS只需要设置必要的几处信息即可，所要处理的数据量也大幅度减少。</p><p>标记生成虚拟的路径，并在它的上面实现IP等数据包的通信。</p><h2 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h2><p>应用协议主要是指OSI参考模型中第5层、第6层、第7层上半部分的协议。</p><p>TCP和IP等下层协议是不依赖于上层应用类型、适用性非常广的协议。而应用协议则是为了实现某种应用而设计和创造的协议。</p><h3 id="远程登录-1"><a href="#远程登录-1" class="headerlink" title="远程登录"></a>远程登录</h3><p>远程登录是为了实现TSS环境，是将主机和终端的关系应用到计算机网络上的一个结果，TSS中通常有一个处理能力非常强的主机，围绕着这台主机的是处理能力没有那么强的多个终端机器。这些终端通过专线与主机相连。</p><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><p>TELNET利用TCP的一条连接，通过这一条连接向主机发送文字命令并在主机上执行。</p><p>TELNET可以分为两类基本服务。一是仿真终端功能，二是协商选项机制。</p><p>TELNET经常用于登录路由器或高性能交换机等网络设备进行相应的设置。</p><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>SSH是加密的远程登录系统</p><p>1、可以使用更强的认证机制</p><p>2、可以转发文件</p><p>3、可以使用端口转发功能</p><h3 id="文件传输-1"><a href="#文件传输-1" class="headerlink" title="文件传输"></a>文件传输</h3><p>FTP是在两个相连的计算机之间进行文件传输时使用的协议。</p><p>它使用两条TCP连接：一条用来控制，另一条用于数据的传输。</p><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>提供电子邮件服务的西医叫做SMTP，为了实现高效发送邮件内容，在其传输层使用了TCP协议</p><p>引进了一种会连接电源的邮件服务器，发送和接收端通过邮件服务器进行收发邮件，接收端从邮件服务器接收邮件时使用POP3协议。</p><p>电子邮件的机制由3部分组成，它们分别是邮件地址，数据格式以及发送协议。</p><h4 id="邮件地址"><a href="#邮件地址" class="headerlink" title="邮件地址"></a>邮件地址</h4><p>根据MX记录中指定的邮件服务器，可以管理不同邮件地址与特定邮件服务器之间的映射关系。</p><h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h4><p>电子邮件所能发送的数据类型被扩展到MIME，可以发送静态图像动画声音等各种形式数据，鉴于MIME规定应用消息的格式，因此在 OSI参考模型中相当于第6层表示层</p><p>MIME基本上由首部和正文两部分组成。首部不能是空行，因为一旦出现空行，其后的部分将被视为正文。</p><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>SMTP是发送电子邮件的协议。它使用的是TCP的25号端口。SMTP建立一个TCP连接以后，在这个连接上进行控制和应答以及数据的发送。客户端以文本的形式发出请求，服务端返回一个3位数字的应答。</p><h4 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h4><p>为了解决SMTP于它支持的是发送端主机的行为，而不是根据接收端的请求发送邮件的问题引入了POP协议，用于接收电子邮件。</p><p>发送端的邮件根据SMTP协议将被转发给一直处于插电状态的POP服务器。客户端再根据POP协议从POP服务器接收对方发来的邮件。</p><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP与POP类似，也是接收电子邮件的协议。在POP中邮件 由客户端进行管理，而在IMAP中邮件则由服务器进行管理。</p><h3 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h3><p>WWW定义了3个重要的概念，它们分别是访问信息的手段与位置、信息的表现形式以及信息转发等操作。</p><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p>URI用于标识资源。URI是一种可以用于WWW之外的高效的识别码，它被用于主页地址、电子邮件、电话号码等各种组合中。</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。HTTP中默认使用80端口。它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p><h3 id="网络管理-1"><a href="#网络管理-1" class="headerlink" title="网络管理"></a>网络管理</h3><h4 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h4><p>在TCP/IP的网络管理中可以使 用SNMP收集必要的信息。它是一款基于UDP/IP的协议。</p><h4 id="MIB"><a href="#MIB" class="headerlink" title="MIB"></a>MIB</h4><p>SNMP中交互的信息是MIB。MIB是在树形结构的数据库中为每个项目 附加编号的一种信息结构。</p><h4 id="RMON"><a href="#RMON" class="headerlink" title="RMON"></a>RMON</h4><p>MIB由监控网络中某个设备接口的众多参数构成。 相比之下，RMON则由监控网络上线路的众多参数构成。</p><p>RMON中可监控的信息从原来的一个点扩展到了一条线上。这样可以更高效率地监控网络。可监控的内容上也增加了很多从用户角度看极为有意义的信息，如网络流量统计等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell学习笔记</title>
      <link href="/2021/10/02/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/02/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><p>shell是一个命令 解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动挂起甚至编写一些程序</p><h4 id="脚本格式要求"><a href="#脚本格式要求" class="headerlink" title="脚本格式要求"></a>脚本格式要求</h4><p>#！/bin/bash开头，脚本需要有可执行权限</p><p>shell脚本后缀以sh结尾</p><p>如#！/bin/bash echo”hello world”</p><p>然后加入执行权限chmod u+x   hello.sh</p><p>脚本常用的执行权限</p><h4 id="脚本的执行方式"><a href="#脚本的执行方式" class="headerlink" title="脚本的执行方式"></a>脚本的执行方式</h4><p>1、sh+脚本（有无执行权限都可以） sh hello.sh(亦可以使用绝对路径)</p><p>2、绝对路径或者相对路径（有执行权限）</p><h3 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h3><p>系统变量  如$home、$PWD、$SHELL</p><p>显示当前shell所有变量 set</p><p>shell变量的定义</p><p>定义变量 变量名=值    </p><p>撤销变量  unset 变量</p><p>设置静态变量 readonly 变量 ,如果声明了静态变量则不可以unset</p><p>输出变量需要&amp;  echo &amp;A</p><p>变量等号两侧不可以有空格，变量名称一般习惯为大写</p><p>A=‘date’   运行里面的命令并将结果返回A，如果不加反引号则代表把date这个字符串赋值给A</p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>export 变量名=变量值 （将shell变量输出为环境变量/全局变量）</p><p>source  配置文件（将修改后的配置信息立即生效）</p><p>echo $变量名 查询环境变量的值，再输出环境变量是要source让配置文件生效</p><p>多行注释   开头!&lt;&lt;!   结尾！</p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用位置参数变量</p><p>$n  n为数字 10以上的参数需要大括号包含如 ${10}</p><p>$*把所有参数看成一个整体</p><p>$@代表命令行的所有参数，不过$@把每个参数区分对待</p><p>$#这个变量代表命令行中所有参数的个数</p><p>echo “0=$0 1=$1”</p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>$$当前进程进程号</p><p>$！后台运行最后一个进程进程号</p><p>$？最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，反之相反</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>$((运算式))或者$[运算式] 或者expr m+n，如果用expr要 *</p><p>注意exxpr运算符要有空格</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>[condition],注意condition前后要有空格,即使为空也要空格  0为true ,&gt;1为false</p><p>两个整数比较 -lt,-le,-eq,-gt,-ge  字符串比较=</p><p>文件类型判断 -f,-e</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;ok&quot;</span> = <span class="string">&quot;ok&quot;</span> ] </span><br><span class="line"></span><br><span class="line">then </span><br><span class="line"></span><br><span class="line">​echo <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">fi（代表语句结束）</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f  /root/shode/aaa.txt ]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​echo <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">fi（代表语句结束)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [条件判断式]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​代码</span><br><span class="line"></span><br><span class="line">elif(条件判断式)</span><br><span class="line"></span><br><span class="line">​代码</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case 语句  $变量名 in</span><br><span class="line"></span><br><span class="line">“值1”）</span><br><span class="line"></span><br><span class="line">如果变量等于1，则执行</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">&quot;值2&quot;)</span><br><span class="line"></span><br><span class="line">如果变量等于2，则执行</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot;  $*被当作一个整体只会输出一句话</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in &quot;$@&quot;  $@被当分别对待有几个参数则输出几句</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for ((初始值;循环控制条件;变量变化))</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [条件判断式]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="read读取控制"><a href="#read读取控制" class="headerlink" title="read读取控制"></a>read读取控制</h3><p>read(选项)(参数)</p><p>选项-p 指定读取值时的提示符,-t指定读取值时的等待时间，如果没有在指定时间内输入则不再等待</p><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p>basename 返回完整路径 /的部分，常用于获取文件名</p><p>basename [pathname] [suffix]</p><p>如 basename home/bin/aa.txt,返回aaa.txt</p><p>basename home/bin/aa.txt.txt 返回aaa</p><p>dirname  返回完整路径/前面的部分，常用于获取路径名</p><p>dirname /home/aaa/bbb/aa.txt  返回/home/aaa/bbb</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>[ function ] funname [()]</p><p>{</p><p>​    Action</p><p>​    [return int;]</p><p>}</p><p>调用直接写函数名  funname [值]</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getsum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum=$[$n1+$n2]</span><br><span class="line">echo <span class="string">&quot;$sum&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">调用自定义函数</span><br><span class="line">getsum $n1 $n2</span><br><span class="line">输入两个值</span><br><span class="line">read -p <span class="string">&quot;输入n1=&quot;</span> n1</span><br><span class="line">read -p <span class="string">&quot;输入n2=&quot;</span> n2</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>日志文件是重要系统信息文件，记录许多重要的系统事件，同时日志对于安全来说可以通过日志来检查错误发生的原因或者收到攻击时攻击者留下的痕迹，是一种用来记录重大事件的工具</p><p>绝大部分的日志文件所在目录：/var/log</p><p>系统启动日志/var/log/boot.log</p><p>/var/log/cron，系统定时任务的相关日志</p><p>/var/log/lastlog 直接用指令lastlog查看，记录用户最后一次登录时间的日志，这个文件也是二进制文件</p><p>/var/log/maillog 记录邮件信息的日志</p><p>/var/log/message 记录重要信息的日志</p><p>/var/log/secure 记录验证和授权方面的信息，只要涉及账户密码都会记录</p><p>/var/tun/lump记录当前登录用户的信息，这个文件会随着用户的登录和注销而不断发生变化  要用who 、users等命令查看</p><h4 id="日志服务管理"><a href="#日志服务管理" class="headerlink" title="日志服务管理"></a>日志服务管理</h4><p>centos7.6日志服务是：rsylogd（后台程序服务管理日志）/etc/rsyslog.conf配置文件控制该服务</p><p> 查询linux中的rsyslogd服务是否启动：ps aux| grep “rsylogd” |grep -v “grep”</p><p>日志文件包含以下四种内容</p><p>1、事件产生的事件 2 、产生事件的服务器的主机名 3、产生事件的服务名或程序名  4、事件的具体信息</p><p>也可以增加自己的日志文件</p><h4 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h4><p>把旧的日志文件移动并改名，同时建立新的空的日志文件，当旧日志文件超出保存范围之后就会进行删除</p><p>/etc/logrotate/conf全局日志论题规则，可以单独给某个日志文件指定策略</p><p>如果没有dateext参数（用日期作为文件后缀）当进行一次日志论题，当前的日志会自动改名，然后新建日志用来保存新的日志</p><p>![日志轮替](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1629524576241.png)</p><p>把自己日志加入日志轮替</p><p>第一种是直接再logrotate.conf配置文件写入该日志的轮替策略</p><p>第二种是在/var/logrotate.d/目录种建立该日志的轮替文件，再该轮替文件中写入正确的轮替策略，因为该目录的文件都会被 “include”到主配置文件中，所以也可以把日志加u轮替（同时可读性和管理也比较好）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">添加自定义轮替规则</span><br><span class="line">/var/log/hsp.log</span><br><span class="line">&#123;</span><br><span class="line">missingok</span><br><span class="line">daily</span><br><span class="line">copytruncate</span><br><span class="line">rotate 7</span><br><span class="line">notifempty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志轮替机制"><a href="#日志轮替机制" class="headerlink" title="日志轮替机制"></a>日志轮替机制</h4><p>依赖系统的定时任务在/etc/cron.daily/目录，就会发现这个目录使用logrotate文件（可执行），logrotate通过这个文件依赖定时任务执行</p><h4 id="内存日志"><a href="#内存日志" class="headerlink" title="内存日志"></a>内存日志</h4><p>内存日志一旦重启就会清空</p><p>journalctl  可以查看内存日志   </p><p>journalctl -n 3 查看最新3条  journalctl -p err 报错日志</p><p>journalctl -since 19:00  –until 19:10:10 查看起始时间到结束时间</p><p>journalctl -o verbose日志详细内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2021/10/02/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/02/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1、了解sql"><a href="#1、了解sql" class="headerlink" title="1、了解sql"></a>1、了解sql</h2><h3 id="1、什么数据库"><a href="#1、什么数据库" class="headerlink" title="1、什么数据库"></a>1、什么数据库</h3><p>数据库应称为数据库管理系统DBMS，数据库是通过DBMS创建和操纵的，访问的是DBMS，保存数据的容器</p><p>表：某种特定类型的结构化清单</p><p>模式：关于数据库和表的布局以及特性的信息</p><p>列：表由列组成，存储表中某部分的信息</p><p>数据类型：所容许的数据类型</p><p>行：表中的数据是按行存储的，所保存的每个记录存储在自己的行内</p><p>主键，一行或一组列，能够唯一标识表中的每个行，主键不是必须的的，可以一起使用多个列作为主键</p><p>只要以下条件：</p><p>1、任意两行都不具有相同的逐渐值</p><p>2、每个行都必须有一个主键值，不允许为NULL值</p><p>3、主键列中的值不允许修改或更新</p><p>4、主键值不能重用，如果某行从表中删除，它的主键不能赋给以后的新行</p><h3 id="2、什么是SQL"><a href="#2、什么是SQL" class="headerlink" title="2、什么是SQL"></a>2、什么是SQL</h3><p>SQL-结构化查询语言</p><p>优点：1、几乎所有DBMS都支持SQL</p><p>2、简单易学</p><p>3、灵活使用能进行复杂和高级数据库操作</p><h3 id="3、什么是MYSQL"><a href="#3、什么是MYSQL" class="headerlink" title="3、什么是MYSQL"></a>3、什么是MYSQL</h3><h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><p>1、成本</p><p>2、性能</p><p>3、可信赖</p><p>4、简单</p><h4 id="2、MySQL版本"><a href="#2、MySQL版本" class="headerlink" title="2、MySQL版本"></a>2、MySQL版本</h4><p>4-InnoDB引擎，增加事务处理，改进全文文本搜索</p><p>4.1-对函数库、子查询、集成帮助重要增加</p><p>5-存储过程、触发器、游标、视图</p><h2 id="2、检索数据"><a href="#2、检索数据" class="headerlink" title="2、检索数据"></a>2、检索数据</h2><h3 id="1、SELECT语句"><a href="#1、SELECT语句" class="headerlink" title="1、SELECT语句"></a>1、SELECT语句</h3><h4 id="1、检索单个列："><a href="#1、检索单个列：" class="headerlink" title="1、检索单个列："></a>1、检索单个列：</h4><p>SELECT prod_name</p><p>FROM Products；</p><p>从product表中检索一个prod_name的列</p><p>注意事项：1、处理SQL语句时，所有空格都被忽略</p><p>2、结束SQL语句，其中多条SQL语句必须以分号，多数DBMS不需要再单条SQL语句后加上分号，但是加上分号肯定没有坏处</p><h4 id="2、检索多个列"><a href="#2、检索多个列" class="headerlink" title="2、检索多个列"></a>2、检索多个列</h4><p>SELECT prod_name，prod_price</p><p>FROM Products；</p><h4 id="3、检索所有列"><a href="#3、检索所有列" class="headerlink" title="3、检索所有列"></a>3、检索所有列</h4><p>SELECT *</p><p>FROM Products；</p><h4 id="4、检索不同行"><a href="#4、检索不同行" class="headerlink" title="4、检索不同行"></a>4、检索不同行</h4><p>SELECT DISTINCTT prod_id</p><p>FROM Products</p><h4 id="5、限制结果"><a href="#5、限制结果" class="headerlink" title="5、限制结果"></a>5、限制结果</h4><p>SELECT prod_id</p><p>FROM Products</p><p>LIMIT 5；</p><p>返回不多于5行</p><p>（LIMIT 4  OFFSET 3）从行3开始取4行</p><h4 id="6、使用完全限定的表名"><a href="#6、使用完全限定的表名" class="headerlink" title="6、使用完全限定的表名"></a>6、使用完全限定的表名</h4><p>SELECT products.prod_id</p><p>FROM crashcourse.products</p><p>假定products表确实位于crashcourse数据库中</p><h2 id="3、排序检索数据"><a href="#3、排序检索数据" class="headerlink" title="3、排序检索数据"></a>3、排序检索数据</h2><p>子句：SQL语句由子句构成，有的必须有的可选</p><h3 id="1、order-by子句"><a href="#1、order-by子句" class="headerlink" title="1、order by子句"></a>1、order by子句</h3><h4 id="1、以字母顺序排序"><a href="#1、以字母顺序排序" class="headerlink" title="1、以字母顺序排序"></a>1、以字母顺序排序</h4><p>SELECT prod_name</p><p>FROM Products</p><p>ORDER BY prod_name；</p><h4 id="2、按多个列排序"><a href="#2、按多个列排序" class="headerlink" title="2、按多个列排序"></a>2、按多个列排序</h4><p>SELECT prod_name，prod_price</p><p>FROM Products</p><p>ORDER BY prod_name， prod_price；</p><h4 id="3、按列位置排序"><a href="#3、按列位置排序" class="headerlink" title="3、按列位置排序"></a>3、按列位置排序</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>ORDER BY 2，3；</p><p>先按SELECT清单中的第二个列，再按第三列排序，也就是先prod_name,再按prod_price排序，如果不在清单则不能使用这种排序</p><h4 id="4、指定排序方向"><a href="#4、指定排序方向" class="headerlink" title="4、指定排序方向"></a>4、指定排序方向</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>ORDER BY  prod_price DESC，prod_name；</p><p>以降序排列产品价格,如果是升序为ASC，但是升序是默认的</p><p>注意区分大小写用order by子句做不到</p><h2 id="4、过滤数据"><a href="#4、过滤数据" class="headerlink" title="4、过滤数据"></a>4、过滤数据</h2><h3 id="1、使用where子句"><a href="#1、使用where子句" class="headerlink" title="1、使用where子句"></a>1、使用where子句</h3><h4 id="1、使用where子句过滤"><a href="#1、使用where子句过滤" class="headerlink" title="1、使用where子句过滤"></a>1、使用where子句过滤</h4><p>如果只需要特定数据需要指定搜索条件，搜索条件也成为过滤条件</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price  = 3.49；</p><p>在同时使用ORDER BY 和 WHERE子句是，应该让 order by 位于 where  之后否则会产生错误</p><h3 id="2、where子句操作符"><a href="#2、where子句操作符" class="headerlink" title="2、where子句操作符"></a>2、where子句操作符</h3><h4 id="1、检查单个值"><a href="#1、检查单个值" class="headerlink" title="1、检查单个值"></a>1、检查单个值</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt; 10；</p><h4 id="2、不匹配检查"><a href="#2、不匹配检查" class="headerlink" title="2、不匹配检查"></a>2、不匹配检查</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt; &gt; 10；</p><p>过略下列价格不是10的</p><p><strong>！= 和&lt;&gt;通常可以互换使用，但并不是所有DBMS都支持这两种不等于操作符，如Microsoft Access</strong></p><h4 id="3、范围值检查"><a href="#3、范围值检查" class="headerlink" title="3、范围值检查"></a>3、范围值检查</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price  BETWEEM 5 AND 10；</p><p>使用between时必须指定两个值，所需范围的低端和高端值</p><h4 id="4、空值检查"><a href="#4、空值检查" class="headerlink" title="4、空值检查"></a>4、空值检查</h4><p>SELECT prod_name</p><p>FROM Products</p><p>WHERE prod_price  IS NULL；</p><p>返回没有价格的所有产品</p><h2 id="5、组合使用where子句"><a href="#5、组合使用where子句" class="headerlink" title="5、组合使用where子句"></a>5、组合使用where子句</h2><p>操作符：用来连结或改变where子句中的关键字也成为逻辑操作符</p><h3 id="1、操作符"><a href="#1、操作符" class="headerlink" title="1、操作符"></a>1、操作符</h3><h4 id="1、AND操作符"><a href="#1、AND操作符" class="headerlink" title="1、AND操作符"></a>1、AND操作符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE vend_id = ‘DLL01’ AND prod_price &lt;=4；</p><h4 id="2、OR操作符"><a href="#2、OR操作符" class="headerlink" title="2、OR操作符"></a>2、OR操作符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE vend_id = ‘DLL01’ OR vend_id = ‘BRS01’；</p><h4 id="3、计算次序"><a href="#3、计算次序" class="headerlink" title="3、计算次序"></a>3、计算次序</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE (vend_id = ‘DLL01’ OR vend_id = ‘BRS01’)</p><p>AND prod_price &gt;=10；</p><p><strong>and在计算次序中优先级更高，操作符容易被错误使用，因此可以用圆括号组合</strong></p><h3 id="2、IN操作符"><a href="#2、IN操作符" class="headerlink" title="2、IN操作符"></a>2、IN操作符</h3><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE vend_id IN  (‘DLL01’ ,’BRS01’)；</p><p>IN用来指定范围条件，范围中的每个条件都可以匹配，IN操作符完成与OR相同的功能，</p><p>但是使用In操作符优点</p><p>1、长的合法选项清单，IN操作符的语法更加清楚且更直观</p><p>2、使用IN，计算的次序更加容易管理</p><p>3、In操作符一般比OR执行更快</p><p>4、IN可以包含其他SELECT语句</p><h3 id="3、NOT操作符"><a href="#3、NOT操作符" class="headerlink" title="3、NOT操作符"></a>3、NOT操作符</h3><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE NOT vend_id = ‘DLL01’ ；</p><p>匹配DLL01之外其他所有东西，该例子也可以使用&lt;&gt;操作符完成</p><p>NOT的好处与IN联合使用时，找出与条件列表不匹配的行非常简单</p><h2 id="6、用通配符进行过滤"><a href="#6、用通配符进行过滤" class="headerlink" title="6、用通配符进行过滤"></a>6、用通配符进行过滤</h2><h3 id="1、LIKE操作符"><a href="#1、LIKE操作符" class="headerlink" title="1、LIKE操作符"></a>1、LIKE操作符</h3><p>通配符：用来匹配值的一部分的特殊字符</p><p>搜索模式：由字面值、通配符或两者组合构成的搜索条件</p><p><strong>通配符只能用于文本字段，非文本数据类型字段不能使用通配符</strong></p><h4 id="1、百分号-通配符"><a href="#1、百分号-通配符" class="headerlink" title="1、百分号%通配符"></a>1、百分号%通配符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘Fish%’；</p><p>将搜索任意以Fish起头的词，告诉DBMS接受Fish之后任意字符</p><p>如果使用Microsoft Access,则需要*而不是%</p><p><strong>这是区分大小写</strong></p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘%bean bag%’；</p><p>匹配任何位置包含文本 bean bag的值，无论在它之前或之后出现什么字符</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘F%y%’；</p><p>找到F起头以y结尾的所有产品，但是如果产品名称最后为空格则无法识别</p><h4 id="2、下划线（-）通配符"><a href="#2、下划线（-）通配符" class="headerlink" title="2、下划线（_）通配符"></a>2、下划线（_）通配符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘_ inch teddy bear’；</p><p>（_）总是匹配一个字符，不能多也不能少</p><h4 id="3、方括号-通配符"><a href="#3、方括号-通配符" class="headerlink" title="3、方括号([]) 通配符"></a>3、方括号([]) 通配符</h4><p>方括号通配符用来指定一个字符集，必须匹配指定位置</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name  LIKE ‘[JM]%’</p><p>ORDER BY prod_name;</p><p>找出名字以J或M开头产品</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name  LIKE ‘[ ^JM ]%’</p><p>ORDER BY prod_name;</p><p>不以JM开头的的产品</p><p>并不是所有DBMS支持[] 通配符</p><h3 id="2、使用通配符的技巧"><a href="#2、使用通配符的技巧" class="headerlink" title="2、使用通配符的技巧"></a>2、使用通配符的技巧</h3><p>1、注意通配符位置</p><p>2、不要过分使用</p><p>3、除非绝对必要不要它们用在搜索模式开始出，否则搜索起来最慢</p><h2 id="7、使用MySQL正则表达式"><a href="#7、使用MySQL正则表达式" class="headerlink" title="7、使用MySQL正则表达式"></a>7、使用MySQL正则表达式</h2><h4 id="1、基本字符匹配"><a href="#1、基本字符匹配" class="headerlink" title="1、基本字符匹配"></a>1、基本字符匹配</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘1000’</p><p>ORDER BY prod_name</p><p>REGEXP后所跟为正则表达式</p><p><strong>LIKE匹配整个列，如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回，除非使用通配符，而REGEXP在列值内进行匹配，如果在列值中出现，相应的行会被返回，正则表达式匹配不区分大小写</strong></p><h4 id="2、进行OR匹配"><a href="#2、进行OR匹配" class="headerlink" title="2、进行OR匹配"></a>2、进行OR匹配</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘1000|2000’</p><p>ORDER BY prod_name</p><h4 id="3、匹配几个字符之一"><a href="#3、匹配几个字符之一" class="headerlink" title="3、匹配几个字符之一"></a>3、匹配几个字符之一</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘[123] Ton’</p><p>ORDER BY prod_name</p><p>这个与下面不同</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘1|2|3 Ton’</p><p>ORDER BY prod_name</p><p>1，2，3如果不在集合中将会应用于整个串</p><h4 id="4、匹配范围"><a href="#4、匹配范围" class="headerlink" title="4、匹配范围"></a>4、匹配范围</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘[1-5] Ton’</p><p>ORDER BY prod_name</p><p><strong>[a-z]匹配任意字母字符</strong></p><h4 id="5、匹配特殊字符"><a href="#5、匹配特殊字符" class="headerlink" title="5、匹配特殊字符"></a>5、匹配特殊字符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘\\ .’</p><p>ORDER BY prod_name</p><p>匹配特殊字符必须\ \为前导，上面就是查找.</p><h4 id="6、匹配字符类"><a href="#6、匹配字符类" class="headerlink" title="6、匹配字符类"></a>6、匹配字符类</h4><p>![1630982988666](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1630982988666.png)</p><h4 id="7、匹配多个实例"><a href="#7、匹配多个实例" class="headerlink" title="7、匹配多个实例"></a>7、匹配多个实例</h4><h4 id="8、匹配定位"><a href="#8、匹配定位" class="headerlink" title="8、匹配定位"></a>8、匹配定位</h4><h2 id="8、创建计算字段"><a href="#8、创建计算字段" class="headerlink" title="8、创建计算字段"></a>8、创建计算字段</h2><p>字段：与列的意思相同</p><h3 id="1、拼接字段"><a href="#1、拼接字段" class="headerlink" title="1、拼接字段"></a>1、拼接字段</h3><p>拼接字段：将值联结到一起构成单个值</p><p>SELECT vend_name + ‘ (‘ + vend_country +’)’</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>也可以将+ 换成||连接元素 （sql的拼接）</p><p>SELECT Concar(vend_name + ‘ (‘ + vend_country +’)’)</p><p>FROM Vendors</p><p>ORDER BY vend_name;(mysql的拼接)</p><p>四个元素</p><p>1、vend_name</p><p>2、包含一个空格和一个左圆括号</p><p>3、存储在vend_country的国家</p><p>4、包含一个右圆括号</p><p>RTrim删除右边多余的空格 Trim去掉左右两边的空格,LTrim去掉左边空格</p><h3 id="2、使用别名"><a href="#2、使用别名" class="headerlink" title="2、使用别名"></a>2、使用别名</h3><p>SELECT RTRIM（vend_name） + ‘ (‘ + RTRIM(vend_country) +’)’ AS vend_title</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>显示的名为vend_title的两者拼接字符串</p><h3 id="3、执行算数计算"><a href="#3、执行算数计算" class="headerlink" title="3、执行算数计算"></a>3、执行算数计算</h3><p>SELECT prod_id,quantity,item_price</p><p>quantity*item_price AS expanded_price</p><p>FROM OrderItems</p><p>WHERE order_num =20008;</p><h2 id="9、使用数据处理函数"><a href="#9、使用数据处理函数" class="headerlink" title="9、使用数据处理函数"></a>9、使用数据处理函数</h2><h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h3><p>只有少数几个函数被所有DBMS支持</p><h3 id="2、使用函数"><a href="#2、使用函数" class="headerlink" title="2、使用函数"></a>2、使用函数</h3><h4 id="1、文本处理函数"><a href="#1、文本处理函数" class="headerlink" title="1、文本处理函数"></a>1、文本处理函数</h4><p>SELECT vend_name， UPPER(vend_name) AS vend_name_upcase</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>UPPER函数将文本转换为大写</p><p> SELECT vend_name， UPPER(vend_name) AS vend_name_upcase</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>SELECT cust_name, cust_contact</p><p>FROM customers</p><p>WHERE Soundex(cust_contact) = Soundex(‘Y.Lie’);</p><p> SOUNDEX 会根据字符串的英文发音，将字母数字字符串转换成一个由四个字符组成的代码。  </p><h4 id="2、日期和时间处理函数"><a href="#2、日期和时间处理函数" class="headerlink" title="2、日期和时间处理函数"></a>2、日期和时间处理函数</h4><p>![1631079154634](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1631079154634.png)</p><p>SELECT cust_id, order_num</p><p>FROM orders</p><p>WHERE Date(order_date) = ‘2005-09-01’;</p><p>检索2005-9-1所用订单</p><p>SELECT cust_id, order_num</p><p>FROM orders</p><p>WHERE Date(order_date) Between ‘2005-09-01’ AND ‘2005-09-30’;</p><p>检索年份</p><p>SELECT cust_id, order_num</p><p>FROM orders</p><p>WHERE YEAR(order_date) =2005 AND Month(order_date) = 9;</p><p>检索年、月</p><h4 id="3、数值处理函数"><a href="#3、数值处理函数" class="headerlink" title="3、数值处理函数"></a>3、数值处理函数</h4><p>Abs,Cos,Exp,Mod,Pi,Rand,Sin,Sqrt,Tan</p><h2 id="10、汇总数据"><a href="#10、汇总数据" class="headerlink" title="10、汇总数据"></a>10、汇总数据</h2><p>聚集函数：运行在行组上，计算和返回单个值的函数</p><h3 id="1、聚集函数"><a href="#1、聚集函数" class="headerlink" title="1、聚集函数"></a>1、聚集函数</h3><h4 id="1、AVG函数"><a href="#1、AVG函数" class="headerlink" title="1、AVG函数"></a>1、AVG函数</h4><p>通过对表中函数计算并计算特定列值的和，求得该列的平均值</p><p>SELECT AVG(prod_price) AS avg_price</p><p>FROM products</p><p>计算特定行的值</p><p>SELECT AVG(prod_price) AS avg_price</p><p>FROM products</p><p>WHERE vend_id = 1003</p><p><strong>AVG函数忽略列值为NULL的行</strong></p><h4 id="2、COUNT函数"><a href="#2、COUNT函数" class="headerlink" title="2、COUNT函数"></a>2、COUNT函数</h4><p>COUNT函数进行计数，可利用COUNT确定表中行的数目或符合特定条件的行的数目</p><p>SELECT AVG(prod_price) AS avg_price</p><p>FROM products</p><p>WHERE vend_id = 1003</p><h4 id="3、MAX函数"><a href="#3、MAX函数" class="headerlink" title="3、MAX函数"></a>3、MAX函数</h4><p>SELECT MAX(prod_price) AS max_price</p><p>FROM products</p><p><strong>MAX函数忽略列值为NULL的行</strong></p><h4 id="4、MIN函数"><a href="#4、MIN函数" class="headerlink" title="4、MIN函数"></a>4、MIN函数</h4><p>SELECT MIN(prod_price) AS max_price</p><p>FROM products</p><h4 id="5、SUM函数"><a href="#5、SUM函数" class="headerlink" title="5、SUM函数"></a>5、SUM函数</h4><p>SUM返回指定列值的总和</p><p>SELECT SUM(prod_price) AS item_ordered</p><p>FROM products;</p><p>SUM也可以合计计算值</p><p>SELECT SUM(prod_price*quantity) AS item_ordered</p><p>FROM products;</p><h3 id="2、聚集不同值"><a href="#2、聚集不同值" class="headerlink" title="2、聚集不同值"></a>2、聚集不同值</h3><p>SELECT AVG(DISTINCT prod_price) AS avg_price</p><p>FROM products</p><p>WHERE vend_id = 1003;</p><p>使用DISTINCT后，平均值只考虑各个不同的价格</p><h3 id="3、组合聚集函数"><a href="#3、组合聚集函数" class="headerlink" title="3、组合聚集函数"></a>3、组合聚集函数</h3><p>SELECT COUNT(*) AS num_items</p><p>MIN(prod_price) AS price_min</p><p>MAX(prod_price) AS price_max</p><p>AVG(prod_price) AS price_avg</p><p>FROM products；</p><h2 id="11、分组数据"><a href="#11、分组数据" class="headerlink" title="11、分组数据"></a>11、分组数据</h2><h3 id="1、数据分组"><a href="#1、数据分组" class="headerlink" title="1、数据分组"></a>1、数据分组</h3><p>SELECT COUNT(*) AS num_prods</p><p>FROM products</p><p>WHERE vend_id = 1003;</p><h3 id="2、创建分组"><a href="#2、创建分组" class="headerlink" title="2、创建分组"></a>2、创建分组</h3><p>SELECT vend_id,COUNT(*) AS num_prods</p><p>FROM products</p><p>GROUP By vend_id;</p><p>指示MYSQL会分组数据</p><h3 id="3、过滤分组"><a href="#3、过滤分组" class="headerlink" title="3、过滤分组"></a>3、过滤分组</h3><p>SELECT vend_id,COUNT(*) AS num_prods</p><p>FROM products</p><p>WHERE prod_price &gt;=10</p><p>GROUP By vend_id</p><p>HAVING COUNT(*) &gt;=2;</p><p>HAVING过滤2或2以上的分组</p><h3 id="4、分组和排序"><a href="#4、分组和排序" class="headerlink" title="4、分组和排序"></a>4、分组和排序</h3><p>SELECT order_num, SUM(quantity*item_price) AS ordertotal</p><p>FROM orderitems</p><p>GROUP By order_num</p><p>HAVING SUM(quantity*item_price) &gt;=50</p><p>ORDER BY ordertotal;</p><p>group by子句用来按订单号分组 HAVING过略数据ORDER BY排序输出</p><h4 id="5、SELECT的子句顺序"><a href="#5、SELECT的子句顺序" class="headerlink" title="5、SELECT的子句顺序"></a>5、SELECT的子句顺序</h4><p>SELECT-FROM-WHERE-GROUP BY -HAVING -ORDER BY -LIMIT</p><h2 id="12、子查询"><a href="#12、子查询" class="headerlink" title="12、子查询"></a>12、子查询</h2><h3 id="1、子查询"><a href="#1、子查询" class="headerlink" title="1、子查询"></a>1、子查询</h3><p>子查询就是查询中嵌套查询</p><h3 id="2、利用子查询进行过略"><a href="#2、利用子查询进行过略" class="headerlink" title="2、利用子查询进行过略"></a>2、利用子查询进行过略</h3><p>SELECT cust_id</p><p>FROM orders </p><p>WHERE  order_num IN (SELECT order_num</p><p>FORM orderitems</p><p>WHERE prod_id = ‘TNT2’);</p><h3 id="3、作为计算字段使用子查询"><a href="#3、作为计算字段使用子查询" class="headerlink" title="3、作为计算字段使用子查询"></a>3、作为计算字段使用子查询</h3><p>SELECT cust_name,cust_state,</p><p> (SELECT COUNT(*)</p><p>FORM orders</p><p>WHERE orders,cust_id = customers.cust_id ) AS orders</p><p>FROM customers</p><p>ORDER BY cust_name;</p><p>相关子查询：设计外部查询的子查询</p><p><strong>注意这里的cust_id是要不同的表</strong></p><h2 id="13、联结表"><a href="#13、联结表" class="headerlink" title="13、联结表"></a>13、联结表</h2><h3 id="1、联结"><a href="#1、联结" class="headerlink" title="1、联结"></a>1、联结</h3><p>利用SQL的SELECT能执行的最重要的操作</p><h4 id="1、关系表"><a href="#1、关系表" class="headerlink" title="1、关系表"></a>1、关系表</h4><p>外键：外键为某个表中的一列，它包含另外一个表的主键值</p><p>关系数据可以有效的存储和方便的处理，因此，关系数据库的可伸缩性远比非关系数据库要好</p><p>可伸缩性：能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好</p><h4 id="2、为什么要使用联结"><a href="#2、为什么要使用联结" class="headerlink" title="2、为什么要使用联结"></a>2、为什么要使用联结</h4><p>分解数据能为多个表更加有效的存储，更方便的处理，并且具有更大的可伸缩性，但是为了SELECT语句检索数据，因此使用联结，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h3 id="2、创建联结"><a href="#2、创建联结" class="headerlink" title="2、创建联结"></a>2、创建联结</h3><h4 id="1、创建联结"><a href="#1、创建联结" class="headerlink" title="1、创建联结"></a>1、创建联结</h4><p>SELECT vend_name，prod_name, prod_price</p><p>FROM products, vendors</p><p>WHERE vendors.vend_id = products.vend_id</p><p>ORDER BY prod_name；</p><p><strong>引用的列可能出现二义性时，必须使用完全限定列名，否则MYSQL返回错误</strong></p><h4 id="2、WHERE子句的重要性"><a href="#2、WHERE子句的重要性" class="headerlink" title="2、WHERE子句的重要性"></a>2、WHERE子句的重要性</h4><p>如果在联结两个表时，没有WHERE子句，第一个表中的每个行将与第二个表中的每个行没对，而不管逻辑是否可以配在一起</p><p><strong>应该保证所有联结都有WHERE子句，否则MySQL将返回比想要数据多得多数据</strong></p><h4 id="3、内部联结"><a href="#3、内部联结" class="headerlink" title="3、内部联结"></a>3、内部联结</h4><p>SELECT vend_name，prod_name, prod_price</p><p>FROM vendors INNER JOIN products </p><p>ON vendors.vend_id = products.vend_id;</p><p>两个表之间的关系时FROM子句的组成部分，以INNER JOIN 指定，在使用这种语法时，联结条件用特定ON子句而不是WHERE子句给出，传递给ON的实际条件与传递给WHERE的相同</p><h4 id="4、联结多个表"><a href="#4、联结多个表" class="headerlink" title="4、联结多个表"></a>4、联结多个表</h4><p>SELECT vend_name，prod_name, prod_price， quantity</p><p>FROM products, vendors， orderitems</p><p>WHERE vendors.vend_id = products.vend_id</p><p>AND orderitems.prod_id =products.prod_id</p><p>AND order_num = 20005;</p><p><strong>MYSQL运行时关联指定的每个表以处理联结，这种处理非常耗费资源，因此不要联结不必要的表</strong></p><h2 id="14、创建高级联结"><a href="#14、创建高级联结" class="headerlink" title="14、创建高级联结"></a>14、创建高级联结</h2><h3 id="1、使用表别名"><a href="#1、使用表别名" class="headerlink" title="1、使用表别名"></a>1、使用表别名</h3><p>SELECT cust_name，cust_contact</p><p>FROM customers AS c, orders AS o , orderitem AS oi</p><p>WHERE c.cust_id = o. cust_id</p><p>AND oi .order_num = o.order_num</p><p>AND prod_id = ‘TNT2’;</p><h3 id="2、使用不同类型的联结"><a href="#2、使用不同类型的联结" class="headerlink" title="2、使用不同类型的联结"></a>2、使用不同类型的联结</h3><h4 id="1、自联结"><a href="#1、自联结" class="headerlink" title="1、自联结"></a>1、自联结</h4><p>利用子查询查找</p><p>SELECT prod_id,prod_name</p><p>FROM products</p><p>WHERE  vend_id = ( SELECT vend_id</p><p>FROM products </p><p>WHERE prod_id = ‘DTNTR’) ;</p><p>利用联结的相同查询</p><p>SELECT p1.prod_id .p1.prod_name</p><p>FROM products AS p1, products AS p2</p><p>WHERE p1.vend_id = p2. vend_id</p><p>AND p2.prod_id = ‘DTNTR’;</p><p><strong>用自联结通常作为外部语句用来代替从相同表中检索数据时使用的子查询语句，有时候处理联结远比处理子查询快的多</strong></p><h4 id="2、自然联结"><a href="#2、自然联结" class="headerlink" title="2、自然联结"></a>2、自然联结</h4><p>自然连接排除多次出现，使每个列只返回一次</p><p>几乎所有的内部联结都是自然联结</p><h4 id="3、外部联结"><a href="#3、外部联结" class="headerlink" title="3、外部联结"></a>3、外部联结</h4><p>SELECT customers.cust_id, order.order_num</p><p>FROM customers LEFT OUTER JOIN orders</p><p>ON customers.cust_id =order.cust_idl;</p><p>使用外部联结时，必须使用RIGHT或LEFT关键字指定包括其所有行的表， RIGHT指出的时OUTER JOIN 右边的表</p><p>*<em>MySQL不支持简化字符  * =和= <em>的使用，这两种在其他DBMS中是很流行的</em></em></p><h3 id="3、使用带聚集函数的联结"><a href="#3、使用带聚集函数的联结" class="headerlink" title="3、使用带聚集函数的联结"></a>3、使用带聚集函数的联结</h3><p>SELECT customers.cust_id, customers.cust_id</p><p>COUNT(orders.order_num) AS num_ord</p><p>FROM customers INNER JOIN orders</p><p>ON customers.cust_id =order.cust_i</p><p>GROUP BY customers.cust_id;</p><p>聚集函数用来汇总数据，如下面COUNT</p><h3 id="4、使用联结和联结条件"><a href="#4、使用联结和联结条件" class="headerlink" title="4、使用联结和联结条件"></a>4、使用联结和联结条件</h3><p>1、一般我们使用内部联结，但使用外部联结也是有效的</p><p>2、保持使用正确的联结条件，否则将返l回不正确的数据</p><p>3、应该总是提供联结条件，否则会得出笛卡尔积</p><p>4、一个联结可以包含多个表，甚至对于每个联结可以采用不同的联结类型</p><h2 id="15、组合查询"><a href="#15、组合查询" class="headerlink" title="15、组合查询"></a>15、组合查询</h2><h3 id="1、组合查询"><a href="#1、组合查询" class="headerlink" title="1、组合查询"></a>1、组合查询</h3><p>MySQL也允许执行多个查询，并将结果作为单个查询结果集返回，这些组合查询通常成为并或复合查询</p><p>使用组合查询的基本情况</p><p>1、在单个查询中从不同的表返回类似结果的数据</p><p>2、对单个表执行多个查询，按单个返回数据</p><h3 id="2、创建组合查询"><a href="#2、创建组合查询" class="headerlink" title="2、创建组合查询"></a>2、创建组合查询</h3><p>可用UNION操作符来组合数条SQL查询，利用UNION，可以给出多条SELECT语句，将它们结果组成单个结果集</p><h4 id="1、使用UNION"><a href="#1、使用UNION" class="headerlink" title="1、使用UNION"></a>1、使用UNION</h4><p>SELECT vend_id，prod_id，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt;= 5</p><p>UNION</p><p>SELECT vend_id, prod_id, prod_price</p><p>FROM products</p><p>WHERE vend_Id IN (1001,1002)</p><p>这条语句由前面两条SELECT 语句组成，语句用UNION关键字分割</p><p>（在某个条件也可以用多条WHERE子句代替UNION查询）</p><h4 id="2、UNION规则"><a href="#2、UNION规则" class="headerlink" title="2、UNION规则"></a>2、UNION规则</h4><p>1、必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）</p><p>2、每个查询必须包含相同的列、表达式或聚集函数</p><p>3、列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含的转换的类型</p><h4 id="3、包含或取消重复的行"><a href="#3、包含或取消重复的行" class="headerlink" title="3、包含或取消重复的行"></a>3、包含或取消重复的行</h4><p>SELECT vend_id，prod_id，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt;= 5</p><p>UNION  ALL</p><p>SELECT vend_id, prod_id, prod_price</p><p>FROM products</p><p>WHERE vend_Id IN (1001,1002)</p><p>ORDER BY vend_id,prod_price</p><p>使用UNION ALL则不取消重复的行</p><h4 id="4、对组合查询结果排序"><a href="#4、对组合查询结果排序" class="headerlink" title="4、对组合查询结果排序"></a>4、对组合查询结果排序</h4><p>SELECT vend_id，prod_id，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt;= 5</p><p>UNION</p><p>SELECT vend_id, prod_id, prod_price</p><p>FROM products</p><p>WHERE vend_Id IN (1001,1002)</p><p>ORDER BY vend_id,prod_price</p><p>SELECT语句的输出用ORDER BY子句排序，在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后</p><h2 id="16、使用文本搜索"><a href="#16、使用文本搜索" class="headerlink" title="16、使用文本搜索"></a>16、使用文本搜索</h2><h3 id="1、理解全文本搜索"><a href="#1、理解全文本搜索" class="headerlink" title="1、理解全文本搜索"></a>1、理解全文本搜索</h3><p>MySQL支持几种基本的数据库引擎。两个最常用的引擎为MyISAM和InnoDB,前者支持全文本搜索，而后者不吃</p><p>全文本搜索可以解决通配符和正则表达式带来的几种限制</p><p>1、性能</p><p>2、明确控制</p><p>3、智能化的结果</p><h3 id="2、使用全文本搜索"><a href="#2、使用全文本搜索" class="headerlink" title="2、使用全文本搜索"></a>2、使用全文本搜索</h3><p>为了全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断的重新索引</p><p>在索引之后SELECT 可与Match()和Against()一起使用以实际执行搜索</p><h4 id="1、启用全文本搜索"><a href="#1、启用全文本搜索" class="headerlink" title="1、启用全文本搜索"></a>1、启用全文本搜索</h4><p>一般在创建表的时候启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，他给出被索引列的一个逗号分隔的列表</p><p>CREATE TABLE productnotes</p><p>{</p><p>note_id  int</p><p>prod_id char(10)</p><p>note_date datetime</p><p>note_text text</p><p>PRIMARY  KEY(note_id)</p><p>FULLTEXT(note_text )</p><p>} ENGINE=MyISAM;</p><p>为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引</p><p>这里的FULLTEXT索引单个列</p><p><strong>不要再导入数据时使用FULLTEXT，更新索引要化时间，，应该首先导入所有数据，然后再修改表，定义FULLTEXT</strong></p><h4 id="2、进行全文本搜索"><a href="#2、进行全文本搜索" class="headerlink" title="2、进行全文本搜索"></a>2、进行全文本搜索</h4><p>在索引之后，使用MATCH指定被搜索的列，Against指定要使用的搜索的表达式</p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE Match(note_text) Against(‘rabbit’);</p><p>指定词rabbit作为搜索文本，Match指示MySQL针对指定的列进行搜索</p><p><strong>传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY方式，否则全文本搜索不区分大小写</strong></p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE note_text LIKE ‘%rabbite%’;</p><p>用正则表达式实现同样的结果</p><p>SELECT note_text，Match(note_text) Against(‘rabbit’) AS rank</p><p>FROM productnotes;</p><h4 id="3、使用查询扩展"><a href="#3、使用查询扩展" class="headerlink" title="3、使用查询扩展"></a>3、使用查询扩展</h4><p>查询扩展用来设法放宽所返回全文本搜索的结果范围，找出相关行的其他行</p><p>在使用查询扩展时,MySQL对数据和索引进行两边扫描来完成搜索，</p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE Match(note_text)  Against(‘avails’ WITH QUERY EXPANSION);</p><p>查询扩展功能用于4.4.1或更高级的版本</p><h4 id="4、布尔文本搜索"><a href="#4、布尔文本搜索" class="headerlink" title="4、布尔文本搜索"></a>4、布尔文本搜索</h4><p>以布尔方式可以提供关于如下内容的细节</p><p>1、要匹配的词</p><p>2、要排斥的的词</p><p>3、排列提示</p><p>4、表达式分组</p><p>5、另外一些内容</p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE Match(note_text)  Against(‘heavy’ IN BOOLEAN MODE);</p><h4 id="5、全文本搜索的使用说明"><a href="#5、全文本搜索的使用说明" class="headerlink" title="5、全文本搜索的使用说明"></a>5、全文本搜索的使用说明</h4><p>1、在索引全文本数据时，短词被忽略且从中排除</p><p>2、MySQL带有一个内建的非用词列表，这些词在索引全文本数据时总是被忽略</p><p>3、许多词出现频率很高，搜索它们没有用</p><p>4、如果表中的行数少于3行，则全文搜所不返回结果</p><p>5、忽略词中的单引号</p><h2 id="17、插入数据"><a href="#17、插入数据" class="headerlink" title="17、插入数据"></a>17、插入数据</h2><h3 id="1、数据插入"><a href="#1、数据插入" class="headerlink" title="1、数据插入"></a>1、数据插入</h3><p>INSERT用来插入或添加行到数据库表的</p><p>可以插入完整的行，插入行的一部分，插入多行，插入某些查询的结果</p><h3 id="2、插入完整的行"><a href="#2、插入完整的行" class="headerlink" title="2、插入完整的行"></a>2、插入完整的行</h3><p>INSERT INTO Customers</p><p>VALUES(NULL,</p><p>‘PEP . LAPEW’</p><p>‘100 Main Street’,</p><p>‘Los Angles’,</p><p>‘CA’,</p><p>‘90046’,</p><p>‘USA’,</p><p>NULL,</p><p>NULL);’</p><p><strong>INSERT语句一般不会产生输出，这种语法简单但并不安全</strong></p><p>以下方式更安全</p><p>INSERT INTO Customers（cust_name,</p><p>cust_address,</p><p>cust_city,</p><p>cust_state,</p><p>cust_zip,</p><p>cust_country,</p><p>cust_contact,</p><p>cust_email)</p><p>VALUES(NULL,</p><p>‘PEP . LAPEW’</p><p>‘100 Main Street’,</p><p>‘Los Angles’,</p><p>‘CA’,</p><p>‘90046’,</p><p>‘USA’,</p><p>NULL,</p><p>NULL);’</p><p><strong>一般不要使用没有明确给出列的列表的INSERT语句，而且INSERT语句是耗时，而且它可能降低等待处理的SELECT语句的性能，如果数据检索是最重要的，则你可以通过在INSERT和INFO之间添加关键字LOW_PROIORITY</strong></p><h3 id="3、插入多个行"><a href="#3、插入多个行" class="headerlink" title="3、插入多个行"></a>3、插入多个行</h3><p>可以使用多条INSERT语句，设置一次提交，每条语句用一个分号结束</p><p>或者只要每条INSERT语句中的列名相同，而已如下组合各语句</p><h4 id="4、插入检索出的数据"><a href="#4、插入检索出的数据" class="headerlink" title="4、插入检索出的数据"></a>4、插入检索出的数据</h4><p>将SELECT语句结果插入多个表中。这就是所谓的INSERT SELECT</p><p>INSERT INTO Customers（cust_name,</p><p>cust_address,</p><p>cust_city,</p><p>cust_state,</p><p>cust_zip,</p><p>cust_country,</p><p>cust_contact,</p><p>cust_email)</p><p>SELECT cust_name,</p><p>cust_address,</p><p>cust_city,</p><p>cust_state,</p><p>cust_zip,</p><p>cust_country,</p><p>cust_contact,</p><p>cust_email</p><p>FROM custnew;</p><p><strong>SELECT语句可以包含WHERE子句以过滤插入的数据</strong></p><h2 id="18、更新和删除数据"><a href="#18、更新和删除数据" class="headerlink" title="18、更新和删除数据"></a>18、更新和删除数据</h2><h3 id="1、更新数据"><a href="#1、更新数据" class="headerlink" title="1、更新数据"></a>1、更新数据</h3><p>可使用UPDATE</p><p>更新表中特定行</p><p>更新表中所有行</p><p><strong>不要省略WHERE子句，在使用UPDATE时一定要注意细心</strong></p><p>UPDATE语句非常容易使用，由三部分组成</p><p>要更新的表</p><p>列名和它们的新值</p><p>确定要更新行的过滤条件</p><p>UPDATE customers</p><p>SET cust_email = ‘<a href="mailto:&#x65;&#108;&#109;&#x65;&#x72;&#64;&#102;&#117;&#x64;&#x64;&#46;&#x63;&#x6f;&#109;">&#x65;&#108;&#109;&#x65;&#x72;&#64;&#102;&#117;&#x64;&#x64;&#46;&#x63;&#x6f;&#109;</a>‘</p><p>WHERE cust_id = 1005;</p><p>SET子句设置cust_email列为指定的值</p><p>UPDATE语句以WHERE子句结束</p><p>UPDATE customers</p><p>SET cust_email = ‘<a href="mailto:&#101;&#108;&#109;&#101;&#x72;&#64;&#x66;&#x75;&#100;&#x64;&#46;&#x63;&#x6f;&#x6d;">&#101;&#108;&#109;&#101;&#x72;&#64;&#x66;&#x75;&#100;&#x64;&#46;&#x63;&#x6f;&#x6d;</a>‘</p><p>cust_name = ‘The Fudds’</p><p>WHERE cust_id = 1005;</p><p><strong>如果UPDATE语句更新多行，并且在更新这些行中的一行或多行时出现一个错误，则整个操作被取消，因此可使用IGNORE关键字</strong></p><p>如果要删除某个列的值，可设置为NULL</p><p>UPDATE customers</p><p>SET cust_email = NULL</p><p>WHERE cust_id = 1005</p><h3 id="2、删除数据"><a href="#2、删除数据" class="headerlink" title="2、删除数据"></a>2、删除数据</h3><p>使用DELETE语句，可以两种方式使用DELETE</p><p>1、从表中删除特定的行</p><p>2、从表中删除所有的行</p><p>DELETE FROM customers</p><p>WHERE cust_id = 10006;</p><p><strong>DELETE删除整行而不是删除列，为了删除指定的列，请使用UPDATE语句，而且DELETE不删除表本身，如果想从表中删除所有行，不要使用DELETE，可以使用TRUNCATE TABLE，完成相同的工作，但速度更快</strong></p><h3 id="3、更新和删除的指导原则"><a href="#3、更新和删除的指导原则" class="headerlink" title="3、更新和删除的指导原则"></a>3、更新和删除的指导原则</h3><p>1、除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句</p><p>2、保证每个表都有主键</p><p>3、在对使用更新和删除语句使用WHERE子句前，应该先用SELECT测试</p><p>4、使用强制实施以用完整性的数据库</p><h2 id="19、创建和操作表"><a href="#19、创建和操作表" class="headerlink" title="19、创建和操作表"></a>19、创建和操作表</h2><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>两种创建表的方法</p><p>1、使用具有交互式创建和管理表的工具</p><p>2、表也可以直接用MySQL语句操纵</p><h4 id="1、表创建基础"><a href="#1、表创建基础" class="headerlink" title="1、表创建基础"></a>1、表创建基础</h4><p>要利用CREATE TABLE创建表必须要下列信息</p><p>1、新表的名字，在关键字CREATE TABLE之后给出</p><p>2、表列的名字和定义，用逗号分隔</p><p>CREATE TBALE customers</p><p>(</p><p>cust_id int NOT NULL AUTO_INCREMENT,</p><p>cust_name char(50) NOT NULL,</p><p>cust_address char(50) NULL,</p><p>cust_email char(255) NULL,</p><p>PRIMARY EKY （cust_id)</p><p>)ENGINE=InnoDB;</p><p>表的主键可以在创建表时用PRIMARY KEY关键字指定</p><p><strong>强烈推荐采用某种缩进格式，同时在创建新表时指定的表明必须不存在没否则将出错，如果 要防止意外覆盖已有的表，SQL要求首先手工删除该表，然后再重建它，而不是简单用创建语句覆盖它</strong></p><h4 id="2、使用NULL值"><a href="#2、使用NULL值" class="headerlink" title="2、使用NULL值"></a>2、使用NULL值</h4><p>CREATE TBALE customers</p><p>(</p><p>cust_id int NOT NULL AUTO_INCREMENT,</p><p>cust_name char(50) NOT NULL,</p><p>cust_address char(50) NULL,</p><p>cust_email char(255) NULL,</p><p>cust_date datetime NOT NULL,</p><p>PRIMARY EKY （cust_id)</p><p>)ENGINE=InnoDB;</p><p>如果每个列的定义含有关键字NOT NULL，这将会住址插入没有值的列，如果试图插入将返回错误且插入失败</p><h4 id="3、主键再介绍"><a href="#3、主键再介绍" class="headerlink" title="3、主键再介绍"></a>3、主键再介绍</h4><p>主键值必须唯一</p><p>如果主键使用单个列，则它的值必须唯一</p><p>CREATE TABLE orderitems</p><p>{</p><p>order_num int NOT NULL,</p><p>item_price decimal(8,2) NOT NULL,</p><p>PRIMARY KEY (order_num, order_item)</p><p>}ENGINE=InnoDB;</p><p><strong>主键只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识</strong></p><h4 id="4、使用AUTO-INCREMENT"><a href="#4、使用AUTO-INCREMENT" class="headerlink" title="4、使用AUTO_INCREMENT"></a>4、使用AUTO_INCREMENT</h4><p>AUTO_INCREMENT告诉MySQL本例增加一行时自动增量。每执行一个INSERT操作，将自动对该列增量</p><h4 id="5、指定默认值"><a href="#5、指定默认值" class="headerlink" title="5、指定默认值"></a>5、指定默认值</h4><p>CREATE TABLE orderitems</p><p>{</p><p>order_num int NOT NULL,</p><p>item_price decimal(8,2) NOT NULL,</p><p>quantity int NOT NULL DEFAULT 1,</p><p>PRIMARY KEY (order_num, order_item)</p><p>}ENGINE=InnoDB;</p><p>DEFAULT 1指示MySQL,在未给出数量的情况使用数量1</p><p><strong>与大多数DBMS不一样，MySQL不允许使用函数作为默认值，只支持常量</strong></p><h4 id="6、引擎类型"><a href="#6、引擎类型" class="headerlink" title="6、引擎类型"></a>6、引擎类型</h4><p> 与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。 </p><p>引擎类型</p><p>1、 InnoDB是一个可靠的事务处理引擎（，它不支持全文本搜索 </p><p>2、 MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）</p><p>3、 MyISAM是一个性能极高的引擎，它支持全文本搜索， 但不支持事务处理 </p><p><strong>外键不能跨引擎，使用一个引擎的表不能引用具有使用不同隐情表的外键</strong></p><h3 id="2、更新表"><a href="#2、更新表" class="headerlink" title="2、更新表"></a>2、更新表</h3><p>使用ALTER TABLE更改表结构必须如下信息</p><p>1、ALTER TABLE之后根除要更改表明（该表必须存在）</p><p>2、所做更改列表</p><p>ALTER TABLE vendors</p><p>ADD vend_phone char(20)</p><p>这条语句给vendors增加一个名为vend_phone的列，必须表明其数据类型</p><p>ALTER TABLE  vendors</p><p>DROP COLUMN vend_phone删除刚刚添加的列‘</p><p>ALTER TABLE的一种常见用途是定义外键</p><p>ALTER TBALE oderitems</p><p>ADD CONSTRAINT fk_orderitems_orders</p><p>FOREIGN KEY (order_num) REFERENCES orders (order_num)</p><h3 id="3、删除表"><a href="#3、删除表" class="headerlink" title="3、删除表"></a>3、删除表</h3><p>DROP TABLE customers</p><h3 id="4、重命名表"><a href="#4、重命名表" class="headerlink" title="4、重命名表"></a>4、重命名表</h3><p>RENAME TBALE customers2 TO customers</p><h2 id="20、使用视图"><a href="#20、使用视图" class="headerlink" title="20、使用视图"></a>20、使用视图</h2><h3 id="1、视图"><a href="#1、视图" class="headerlink" title="1、视图"></a>1、视图</h3><p>Mysql5添加了对视图的支持</p><h4 id="1、为什么使用视图"><a href="#1、为什么使用视图" class="headerlink" title="1、为什么使用视图"></a>1、为什么使用视图</h4><p>1、重用SQL语句</p><p>2、简化复杂的SQL操作</p><p>3、使用表的我组成部分而不是整个表</p><p>4、保护数据</p><p>5、更改数据格式和表示</p><p><strong>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索，如果使用多个联结，和过滤创建了复杂的视图或者嵌套了视图，会发现性能下降的厉害</strong></p><h4 id="2、视图规则和限制"><a href="#2、视图规则和限制" class="headerlink" title="2、视图规则和限制"></a>2、视图规则和限制</h4><p> 1、 与表一样，视图必须唯一命名。 </p><p>2、对于可以创建的视图数目没有限制。 </p><p>3、为了创建视图，必须具有足够的访问权限。这些限制通常由数据 库管理人员授予。 </p><p>4、 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造 一个视图。 </p><p>5、 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也 含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</p><p> 6、 视图不能索引，也不能有关联的触发器或默认值。 </p><p>7、 视图可以和表一起使用。</p><h3 id="2、使用视图"><a href="#2、使用视图" class="headerlink" title="2、使用视图"></a>2、使用视图</h3><p> 1、视图用CREATE VIEW语句来创建。</p><p> 2、使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 </p><p>3、 用DROP删除视图，其语法为DROP VIEW viewname;。</p><p> 4、更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR  REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创 建一个视图；如果要更新的视图存在，则第2条更新语句会替换原 有视图。 </p><h4 id="1、利用视图简化复杂的联结"><a href="#1、利用视图简化复杂的联结" class="headerlink" title="1、利用视图简化复杂的联结"></a>1、利用视图简化复杂的联结</h4><p>CREATE VIEW productcustomers AS</p><p>SELECT cust_name,cust_contact,prod_id</p><p>FROM customers,orders,orderitems</p><p>WHERE customer.cust_id =orders.cust_id</p><p>AND orderitems,order_num=order.order_num;</p><p>这里联结三个表，返回已订购任意产品所有客户的列表</p><h4 id="2、用视图重新格式化检索出的数据"><a href="#2、用视图重新格式化检索出的数据" class="headerlink" title="2、用视图重新格式化检索出的数据"></a>2、用视图重新格式化检索出的数据</h4><p>CREATE VIEW vendorlocation AS </p><p>SELECT Concat(RTrim(vend_name)),’(‘,RTrim(vend_country)’)’</p><p>AS vend_title</p><p>FROM vendors</p><p>ORDER BY vend_name;</p><p>这条语句使用以前的select语句相同的查询创建视图，这时可以使用视图</p><p>SELECT *</p><p>FROM vendorlocations;</p><h4 id="3、用视图过滤不想要的数据"><a href="#3、用视图过滤不想要的数据" class="headerlink" title="3、用视图过滤不想要的数据"></a>3、用视图过滤不想要的数据</h4><p>视图对于应用普通的WHERE子句也很有用</p><p>CREATE VIEW customeremaillist AS</p><p>SELECT cust_name,cust_id,cust_email</p><p>FROM customers,</p><p>WHERE cust_email IS NOT NULL;</p><h4 id="4、使用视图与计算字段"><a href="#4、使用视图与计算字段" class="headerlink" title="4、使用视图与计算字段"></a>4、使用视图与计算字段</h4><p>SELECT prod_id,quantity,item_price,quantity*item_price</p><p>AS expanded_price </p><p>FROM orderitems</p><p>WHERE order_num=20005;</p><p>将其转换为一个视图</p><p>CREATE VIEM orderitemsexpanded AS</p><p>SELECT prod_id,quantity,item_price,quantity*item_price</p><p>AS expanded_price </p><p>FROM orderitems;l</p><p>如果要检索20005详细内容，如下进行</p><p>SELECT * </p><p>FROM orderitemexpander</p><p>WEHER order_num = 20005;</p><h4 id="5、更新视图"><a href="#5、更新视图" class="headerlink" title="5、更新视图"></a>5、更新视图</h4><p>视图是可以更新的，但是并非所有视图都是可更新的，如果Mysql不能正确确定被更新的基数据，则不允许更新</p><p>也就是如果有一下操作则不能更新</p><p>1、分组</p><p>2、联结</p><p>3、子查询</p><p>4、并</p><p>5、聚集函数（Min()、Count()、Sum())</p><p>6、DISTINCT</p><p>7、导出（计算）列</p><h2 id="21、使用存储过程"><a href="#21、使用存储过程" class="headerlink" title="21、使用存储过程"></a>21、使用存储过程</h2><h3 id="1、存储过程"><a href="#1、存储过程" class="headerlink" title="1、存储过程"></a>1、存储过程</h3><p>MySQL添加了对存储过程的支持</p><p>存储过程就是为以后的使用而保存的一条或多条MySQL语句的集合，可以将其视为批文件，虽然作用不仅限于批处理</p><h3 id="2、为什么要使用存储过程"><a href="#2、为什么要使用存储过程" class="headerlink" title="2、为什么要使用存储过程"></a>2、为什么要使用存储过程</h3><p>1、把处理封装在容易使用的单元中，简化复杂的操作</p><p>2、由于不要求反复建立一系列处理步骤，保存了数据的完整性</p><p>3、简化对变动的管理</p><h3 id="3、使用存储过程"><a href="#3、使用存储过程" class="headerlink" title="3、使用存储过程"></a>3、使用存储过程</h3><h4 id="1、执行存储过程"><a href="#1、执行存储过程" class="headerlink" title="1、执行存储过程"></a>1、执行存储过程</h4><p>CALL接受存储过程的名字以及需要传递给他的任意参数</p><p>CALL productpricing(@pricelow,@pricehigh,@priceaverage);</p><p>可以显示结果也可以不显示</p><h4 id="2、创建存储过程"><a href="#2、创建存储过程" class="headerlink" title="2、创建存储过程"></a>2、创建存储过程</h4><p>CREATE PROCEDURE productpricing()</p><p>BEGIN</p><p>​    SELECT Avg(prod_price) AS priceaverage</p><p>​    FROM products</p><p>END;</p><p>这里存储过程名为productpring，它们将在()列举出来，此存储过程没有参数，但后跟的()仍然徐娅，BEIGIN和END语句用来限定存储过程体，过程体本身只是一个SELECT语句</p><p>如果使用这个存储过程</p><p>CALL productpricing();</p><h4 id="3、删除存储过程"><a href="#3、删除存储过程" class="headerlink" title="3、删除存储过程"></a>3、删除存储过程</h4><p>DROP PROCEDURE productpricing;</p><p><strong>这里不用（）,只需要给出存储过程名</strong></p><h4 id="4、使用参数"><a href="#4、使用参数" class="headerlink" title="4、使用参数"></a>4、使用参数</h4><p>CREATE PROCEDURE productpricing(</p><p>OUT p1 DECIMAL(8,2),</p><p>OUT ph DECIMAL(8,2),</p><p>OUT pa DECIAML(8,2))</p><p>BEGIN</p><p>​    SELECT Min(prod_price) </p><p>​    INTO p1</p><p>​    FROM products;</p><p>​    SELECT Max(prod_price) </p><p>​    INTO pj</p><p>​    FROM products;</p><p>​    SELECT Avg(prod_price) </p><p>​    INTO pa</p><p>​    FROM products;</p><p>END;</p><p> 此存储过程接受3个参数：pl存储产品最低价格，ph存储产品 最高价格，pa存储产品平均价格。每个参数必须具有指定的类 型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出 一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存 储过程传出）和INOUT（对存储过程传入和传出）类型的参数。 </p><p>调用此存储过程必须指定3个变量名</p><p>CALL productpricing(@pricelow,@pricehigh,@priceaverage);</p><p><strong>所有MySQL变量都必须以@开始</strong></p><p>获得三个值，可使用以下语句</p><p>SELECT @pricehigh,@pricelow,@priceaverage;</p><p>下面使用IN 和OUT参数</p><p>CREATE PROCEDURE ordertotal(</p><p>​    IN onumber TNT,</p><p>​    OUT ototal DECIMAL(8,2)</p><p>)</p><p>BEGIN</p><p>​    SELECT Sum(item_price*quantity)</p><p>​    FROM orderitems</p><p>​    WHERE order_num = onumber</p><p>​    INTO ototal;</p><p>END;</p><p> onumber定义为IN，因为订单号被传入存储过程。ototal定义 为OUT，因为要从存储过程返回合计。SELECT语句使用这两个 参数，WHERE子句使用onumber选择正确的行，INTO使用ototal存储计算 出来的合计。 </p><p>CALL ordertotal(20005,@total);</p><p>必须给ordertotal传递两个函数，第一个参数为订单号，第二个参数为包含计算出来的合计变量名</p><p>为了显示合计</p><p>SELECT @total；</p><h4 id="5、建立智能存储过程"><a href="#5、建立智能存储过程" class="headerlink" title="5、建立智能存储过程"></a>5、建立智能存储过程</h4><p>增加注释–，添加另外一个参数taxable，它是一个布尔值，在DECLARE语句定义了两个局部变量</p><h4 id="6、检查存储过程"><a href="#6、检查存储过程" class="headerlink" title="6、检查存储过程"></a>6、检查存储过程</h4><p>要显示一个用来创建一个存储过程的CRETE语句，使用SHOW CREATE PROCEDURE语句</p><p>SHOW CREATE PROCEDURE ordertotal;</p><p>为了包括何时，由谁创建等详细存储过程列表使用SHOW PROCEDURE STATUS</p><p><strong>如果要限制SHOW PROCEDURE STATUS的输出，可以使用LIKE指定一个过滤模式</strong></p><h2 id="22、使用游标"><a href="#22、使用游标" class="headerlink" title="22、使用游标"></a>22、使用游标</h2><h3 id="1、游标"><a href="#1、游标" class="headerlink" title="1、游标"></a>1、游标</h3><p>游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据</p><h3 id="2、使用游标"><a href="#2、使用游标" class="headerlink" title="2、使用游标"></a>2、使用游标</h3><p>1、在使用游标前，必须声明它，这个过程实际上没有检索数据，他只是定义要使用的SELECT语句</p><p>2、一旦声明后，必须打开游标以供使用</p><p>3、对于填有数据的游标，根据需要取出各行</p><p>4、结束使用游标后，必须关闭游标</p><h4 id="1、创建游标"><a href="#1、创建游标" class="headerlink" title="1、创建游标"></a>1、创建游标</h4><p>游标用DECLARE创建，DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句</p><p>CREATE PROCEDURE processorders()</p><p>BEGIN</p><p>​    DECLARE ordernumbers CURSOR</p><p>​    FOR</p><p>​    SELECT order_num FROM orders;</p><p>END;</p><p>这里定义命名游标，存储过程处理完成后，游标就消失</p><p>定义游标之后可以重新打开它</p><h4 id="2、打开和关闭游标"><a href="#2、打开和关闭游标" class="headerlink" title="2、打开和关闭游标"></a>2、打开和关闭游标</h4><p>游标用OPEN CURSOR语句打开</p><p>OPEN odernumbers;</p><p>游标用CLOSE语句关闭，CLOSE释放游标使用的内部内存和资源，因此每个游标不在需要时都应该关闭</p><h4 id="3、使用游标数据"><a href="#3、使用游标数据" class="headerlink" title="3、使用游标数据"></a>3、使用游标数据</h4><p>在一个游标被打开之后，可以使用FETCH语句分别访问他的每一行，指定检索什么数据,检索出来的数据存储在什么地方</p><p>CREATE PROCEDURE processorders()</p><p>BEGIN</p><p>//声明名为o的变量名</p><p>​    DECLARE o INT;</p><p>​    DECLARE ordernumbers CURSOR</p><p>​    FOR</p><p>​    SELECT order_num FROM orders;</p><p>​    OPEN ordernumbers;</p><p>​    FETCH ordernumbers INTO o;</p><p>​    CLOSE ordernumbers;</p><p>END;</p><h2 id="23、使用触发器"><a href="#23、使用触发器" class="headerlink" title="23、使用触发器"></a>23、使用触发器</h2><h3 id="1、触发器"><a href="#1、触发器" class="headerlink" title="1、触发器"></a>1、触发器</h3><p>触发器是MySQL相应以下任意语句而自动执行的一条MySQL语句</p><p>1、DELETE</p><p>2、INSERT</p><p>3、UPDATE</p><p>其他语句不支持触发器</p><h3 id="2、创建触发器"><a href="#2、创建触发器" class="headerlink" title="2、创建触发器"></a>2、创建触发器</h3><p> 1、唯一的触发器名； </p><p>2、触发器关联的表；</p><p> 3、触发器应该响应的活动（DELETE、INSERT或UPDATE）； </p><p>4、触发器何时执行（处理之前或之后） </p><p><strong>保持每个数据库的触发器名唯一</strong></p><p>CREATE TRIGGER newproduct AFTER INSERT ON products</p><p>FOR EACH ROW SELECT ‘Product added’;</p><p>create trigger用来创建名为newproduct的新触发器，触发器可以在一个操作之前或之后执行，这里的AFTER INSERT， 所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次 </p><p><strong>只有表支持触发器，视图不支持</strong></p><p>触发器每个表每个事件每次定义，每个表每个事件每次只允许一个触发器。<strong>因此每个表最多支持6个触发器，如果BEFORE触发器失败或语句本身，则MySQL将不执行AFTER触发器</strong></p><h3 id="3、删除触发器"><a href="#3、删除触发器" class="headerlink" title="3、删除触发器"></a>3、删除触发器</h3><p>DROP TRIGGER newproduct;</p><p>为了修改一个触发器，必须先删除它，然后再重新创建</p><h3 id="4、使用触发器"><a href="#4、使用触发器" class="headerlink" title="4、使用触发器"></a>4、使用触发器</h3><h4 id="1、INSERT触发器"><a href="#1、INSERT触发器" class="headerlink" title="1、INSERT触发器"></a>1、INSERT触发器</h4><p> 1、在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行； </p><p>2、在BEFORE INSERT触发器中，NEW中的值也可以被更新）；</p><p> 3、对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值 </p><p>CREATE TRIGGER neworder AFTER INSERT ON orders</p><p>FOR EACH ROW SELECT NEW.order_num;</p><p> 在插入一个新订单到orders表时，MySQL生 成一个新订单号并保存到order_num中。触发器从NEW.order_num取得 这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。 </p><h4 id="2、DELETE触发器"><a href="#2、DELETE触发器" class="headerlink" title="2、DELETE触发器"></a>2、DELETE触发器</h4><p> 1、 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访 问被删除的行；  </p><p> 2、OLD中的值全都是只读的，不能更新。 </p><p>使用OLD保存将要被删除的行到一个存档表中：<br>CREATE TRIGGER deleteorder BEFORE DELETE ON orders</p><p>FOR EACH ROW</p><p>BEGIN</p><p>​    INSERT INTO arichive_orders(order_num,order_date,cust_id)</p><p>VALUES(OLD.order_num,OLD.order_date,OLD.cust_id);</p><p>END;</p><p> 在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_  orders的存档表中 </p><p><strong>使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器 来说），如果由于某种原因，订单不能存档，DELETE本身将被放弃</strong></p><h4 id="3、UPDATE触发器"><a href="#3、UPDATE触发器" class="headerlink" title="3、UPDATE触发器"></a>3、UPDATE触发器</h4><p> 1、在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新 更新的值；</p><p>2、在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）；</p><p> 3、OLD中的值全都是只读的，不能更新。 </p><p>CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors </p><p>FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state)</p><p> 每次更新一个行时，NEW.vend_state中的 值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。 </p><h4 id="4、触发器进一步介绍"><a href="#4、触发器进一步介绍" class="headerlink" title="4、触发器进一步介绍"></a>4、触发器进一步介绍</h4><p>1、与其他DBMS相比，MySQL 5中支持的触发器相当初级。 </p><p>2创建触发器可能需要特殊的安全访问权限，但是，触发器的执行 是自动的。 </p><p>3、应该用触发器来保证数据的一致性（大小写、格式等）。 </p><p>4、 触发器的一种非常有意义的使用是创建审计跟踪。 </p><p>5、 MySQL触发器中不支持CALL语句。 </p><h2 id="24、管理事务处理"><a href="#24、管理事务处理" class="headerlink" title="24、管理事务处理"></a>24、管理事务处理</h2><h3 id="1、事务处理"><a href="#1、事务处理" class="headerlink" title="1、事务处理"></a>1、事务处理</h3><p> MyISAM和InnoDB是两种最常使用 的引擎。前者不支持明确的事务处理管理，而后者支持 </p><p>1、 事务（transaction）指一组SQL语句； </p><p>2、回退（rollback）指撤销指定SQL语句的过程；</p><p>3、提交（commit）指将未存储的SQL语句结果写入数据库表； </p><p>4、保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 </p><h3 id="2、控制事务处理"><a href="#2、控制事务处理" class="headerlink" title="2、控制事务处理"></a>2、控制事务处理</h3><p> MySQL使用下面的语句来标识事务的开始： </p><p>START TRANSACTION</p><h4 id="1、使用ROLLBACK"><a href="#1、使用ROLLBACK" class="headerlink" title="1、使用ROLLBACK"></a>1、使用ROLLBACK</h4><p> MySQL的ROLLBACK命令用来回退（撤销）MySQL语句.</p><p>SELECT * FROM ordertotals;</p><p>START TRANSACTION;</p><p>DELETE FROM ordertotals;</p><p>SELECT * FROM ordertotals;</p><p>ROLLBACK;</p><p>SELECT *FROM ordertotals;</p><p>从显示ordertotals表的内容开始。首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退 START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为 空。 显然，ROLLBACK只能在一个事务处理内使用</p><p>**事务处理用来管理INSERT UPDATE 和DELETE语句不能回退SELECT语句以及回退CREATE或DROP操作 **</p><h4 id="2、使用COMMIT"><a href="#2、使用COMMIT" class="headerlink" title="2、使用COMMIT"></a>2、使用COMMIT</h4><p> 一般的MySQL语句都是直接针对数据库表执行和编写的。这就是 所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 </p><p>为明确的提交，使用COMMIT语句</p><p>START TRANSACTION</p><p>DELETE FROM orderitems WHERE order_num = 20010;</p><p>DELETE FROM orders WHERE order_num = 20010;</p><p>COMMIT;</p><p> 因为涉及更新 两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETKE不会提交</p><h4 id="3、使用保留点"><a href="#3、使用保留点" class="headerlink" title="3、使用保留点"></a>3、使用保留点</h4><p> 简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部 分提交或回退 </p><p>为了创建占位符</p><p>SAVEPOINT delete1’</p><p>每个保留点都取表示它的唯一名字</p><p>ROLLBACK TO delete1;</p><p>**保留点越多越好，而且保留点在事务处理完成后自动释放 也可以用RELEASE SAVEPOINT明确地释放保留点 **</p><h4 id="4、更改默认的提交行为"><a href="#4、更改默认的提交行为" class="headerlink" title="4、更改默认的提交行为"></a>4、更改默认的提交行为</h4><p> 默认的MySQL行为是自动提交所有更改 </p><p>SET autocommit = 0;</p><p>autocommit标志决定是否自动提交更改，不管有没有COMMIT语句，设置为0则只是不自动提交更改</p><h2 id="25、安全管理"><a href="#25、安全管理" class="headerlink" title="25、安全管理"></a>25、安全管理</h2><h3 id="1、访问控制"><a href="#1、访问控制" class="headerlink" title="1、访问控制"></a>1、访问控制</h3><p> 访问控制的目的不仅仅是防止用户的恶意企图还有无疑是错误的结果</p><p><strong>在现实世界 的日常工作中，决不能使用root，除非在绝对情况</strong></p><h3 id="2、管理用户"><a href="#2、管理用户" class="headerlink" title="2、管理用户"></a>2、管理用户</h3><p>USE mysql</p><p>SELECT user FROM user;</p><p>获得用户账号列表时</p><h4 id="1、创建用户账号"><a href="#1、创建用户账号" class="headerlink" title="1、创建用户账号"></a>1、创建用户账号</h4><p>CREATE USER ben IDENTIFIED BY ’p@$$w0ord‘;</p><p>创建用户不一定需要口令，CREATE USER创建一个新用户账号</p><p>**令IDENTIFIED BY指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密， GRANT语句也可以创建用 户账号，但一般来说CREATE USER是最清楚和最简单的句子。 **</p><p>重新命名一个用户账号</p><p>RENAME USER ben TO bforta;</p><h4 id="2、删除用户账号"><a href="#2、删除用户账号" class="headerlink" title="2、删除用户账号"></a>2、删除用户账号</h4><p>DROP USER bforta;</p><p><strong>自MySQL 5以来，DROP USER删除用户账号和 所有相关的账号权限。在MySQL 5以前，DROP USER只能用来 删除用户账号，不能删除相关的权限。</strong></p><h4 id="3、设置访问权限"><a href="#3、设置访问权限" class="headerlink" title="3、设置访问权限"></a>3、设置访问权限</h4><p>SHOW GRANTS FOR bforta;</p><p>看到赋予用户账号的权限</p><p> 设置权限，使用GRANT语句。GRANT要求你至少给出以下信息： </p><p>1、要授予的权限； </p><p>2、被授予访问权限的数据库或表；</p><p>3、 用户名。 </p><p>GRANT SELECT ON crashcourse. * TO bforta;</p><p>此GUANT允许用户在crashcourse,*上使用SELECT</p><p>GRANT反操作为REVOKE,用来撤销特定的权限</p><p>REVOKE SELECT ON crashcoure.* FROM bforta;</p><p> GRANT和REVOKE可在几个层次上控制访问权限：</p><p>1、 整个服务器，使用GRANT ALL和REVOKE ALL；</p><p>2、整个数据库，使用ON database.*；</p><p>3、 特定的表，使用ON database.table；</p><p>4、特定的列； </p><p>5、 特定的存储过程。 </p><h4 id="4、更改口令"><a href="#4、更改口令" class="headerlink" title="4、更改口令"></a>4、更改口令</h4><p>SET PASSWORD FOR bforta = Password(‘n3w’)</p><p>SET PASSWORD更新用户口令。新口令必须传递到Password()函数进行加密。 </p><h2 id="26、数据库维护"><a href="#26、数据库维护" class="headerlink" title="26、数据库维护"></a>26、数据库维护</h2><h3 id="1、备份数据"><a href="#1、备份数据" class="headerlink" title="1、备份数据"></a>1、备份数据</h3><p> 由于这些文件总是处于打开和使用状态，普通的文件副本备份不 一定总是有效。 因此以下几种方法备份</p><p>1、 使用命令行实用程序mysqldump转储所有数据库内容到某个外部 文件。在进行常规备份前这个实用程序应该正常运行，以便能正 确地备份转储文件。 </p><p>2、可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据 （但是并非所有数据库引擎都支持这个实用程序）。</p><p>3、可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所 有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，而且此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原 。</p><p><strong>首先刷新未写数据为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。</strong></p><h3 id="2、数据库维护"><a href="#2、数据库维护" class="headerlink" title="2、数据库维护"></a>2、数据库维护</h3><p>ANALYZE TABLE orders;</p><p>用来检查表键是否正确</p><p>CHECK TABLE orders,orderitems;</p><p>用来针对许多问题进行检查</p><p>1、如果MyISAM表访问产生不正确和不一致的结果，可能需要用 REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题</p><p> 2、如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。  </p><h4 id="3、诊断启动问题"><a href="#3、诊断启动问题" class="headerlink" title="3、诊断启动问题"></a>3、诊断启动问题</h4><p> MySQL 服务器自身通过在命令行上执行mysqld启动。 </p><h4 id="4、查看日志文件"><a href="#4、查看日志文件" class="headerlink" title="4、查看日志文件"></a>4、查看日志文件</h4><p> 1、错误日志。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用 –log-error命令行选项更改。 </p><p>2、查询日志。它记录所有MySQL活动，在诊断问题时非常有用。由于日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用 –log命令行选项更改。</p><p>3、二进制日志。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前MySQL版本中使用的是更新日志。 </p><p>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。此日志通常名为 hostname-slow.log ，位于 data 目录中。此名字可以用 –log-slow-queries命令行选项更改 </p><p>**在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 **</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux和虚拟机学习笔记</title>
      <link href="/2021/10/02/linux%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/02/linux%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="网路连接三种模式"><a href="#网路连接三种模式" class="headerlink" title="网路连接三种模式"></a>网路连接三种模式</h3><p>1、桥接模式：虚拟系统和外部系统通讯，但是造成Ip冲突</p><p>2、NAT模式：网络哟地址转换模式，虚拟系统可以和外部系统通讯，不造成Ip冲突（能够代理出来但不能回去）</p><p>3、主机模式：主机系统</p><h3 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h3><p>1、使用vmware的克隆操作，克隆要关闭Linux系统，，直接右键点击虚拟机-管理-克隆-创建完整的克隆-克隆完直接打开-剩下步骤和安装虚拟机相同</p><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>如果在使用虚拟机系统的时候，想回到原先的某一个状态，担心有些操作造成系统异常，需要回到某个正常运行的状态——快照管理</p><p>方法：右键虚拟机-快照-拍摄的快照-利用快照管理器转到该状态即可（在哪拍快照意味这在此开一个分支）当然每次快照都会占用磁盘空间</p><h3 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h3><p>迁移：直接虚拟机文件夹迁移，删除：直接磁盘文件删除（彻底）或者直接虚拟机内部文件夹删除（部分）</p><h3 id="利用vmtool实现文件共享"><a href="#利用vmtool实现文件共享" class="headerlink" title="利用vmtool实现文件共享"></a>利用vmtool实现文件共享</h3><p>安装完vmtool之后（需要gcc），利用设置设置共享文件夹，在linux中mmt文件夹下</p><h3 id="linux的目录结构"><a href="#linux的目录结构" class="headerlink" title="linux的目录结构"></a>linux的目录结构</h3><p>树状结构-把硬件都映射为文件，从根目录</p><p>/bin-是binary的缩写，目录存放最经常使用的指令。/sbin-存放系统管理员使用的系统管理程序</p><p>/root-该目录为系统管理员，也称作超级权限者用户主目录。</p><p>/lost+found-（隐藏，通过终端进入）一般为空，当系统非法关机就存放一些文件。</p><p>/lib-系统开机所需要最基本的动态连接共享库，其作用类似于windows的dll文件，几乎所有程序都需要这种共享库。</p><p>/etc-所有系统管理所需要的配置文件和子目录。</p><p>/user-用户应用程序和文件都放在这个programfile目录中。/user/local另一个注解额外安装软件所存放的目录</p><p>/boot启动Linux使用的一些核心文件。/proc(不能动)虚拟目录是系统内存的映射</p><p>/srv-(不能动)服务启动所需要的临时文件。/sys-(不能动)该目录安装了2.6内核下一个新的文件系统</p><p>/tmp存放临时文件。/dev-把所有硬件用文件存储/media自动识别的文件，/media-linux会把识别的设备挂载到这个目录之中</p><p>/mnt-让用户临时挂载别的文件系统。/opt-主机额外安装软件所存放的目录</p><p>/var这个目录存放不断被扩充东西，一般为各种经常修改的日志文件</p><p>/selinux-是一种安全子系统，他能控制程序访问特定文件</p><h3 id="linux远程登录和linux远程文件传输"><a href="#linux远程登录和linux远程文件传输" class="headerlink" title="linux远程登录和linux远程文件传输"></a>linux远程登录和linux远程文件传输</h3><p>远程登录linux进行项目管理和开发</p><p>远程登录：xshell 文件xftp6</p><p>查询ip地址ifconfig  然后ping +ip地址判断两者之间有无联网</p><p>利用xftp进行文件传输             （乱码则在属性改为utf-8)</p><h3 id="vi和vim的基本使用"><a href="#vi和vim的基本使用" class="headerlink" title="vi和vim的基本使用"></a>vi和vim的基本使用</h3><p>正常模式：vim打开一个档案直接进入一般模式</p><p>插入模式：按下i I,O o,A,a,r，R按任何一个字母会进入编辑模式</p><p>命令行模式：可以提供相关指令，完成读取，存盘，替换等vim操作，输入esc转为正常模式在输入‘：’或者‘ / ’从其他模式进入命令行模式 ，wq保存退出，q!强制退出不保存， q退出不保存</p><p>拷贝当前行（一般模式下）yy 然后p (粘贴) 拷贝多行 4yy（拷贝往上4行）然后输入p</p><p>删除当前行dd同时删除5行5dd，查找某个单词 （命令行模式下）/hello查找单词hello，输入n就是查找下一个</p><p>设置\取消文件的行号（命令行模式） ‘:set nu’\   ‘:set npnu’</p><p>定位文档最末行G最首行gg在(一般模式),撤销这个动作(一般模式) u</p><p>编辑文件定位(一般模式下)‘20gg’或’20G‘(定位到20行)</p><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><p>shutdown -h now 立刻进行关机</p><p>shudown -h 1 1分钟后关机</p><p>shutdown -r now 现在重新启动计算机   halt关机 reboot重启</p><p>sync内存数据同步到磁盘，无论重启还是关闭系统首先要运行sync命令，但目前关机重启指令都在关机前执行sync</p><h3 id="用户登录注销"><a href="#用户登录注销" class="headerlink" title="用户登录注销"></a>用户登录注销</h3><p>su - (用户名)  su - root 切换系统管理员身份（获取最大权限）  logout可以注销用户，root执行logout就会回到登录的身份如jesse,(logout在图形运行级别无效，在运行级别3有效)</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>添加一个用户 useradd 用户名 某人该用户的家目录在 /home/用户名会自动创建和用户名同名的家目录 useradd -d /home/test king 在test下创建一个用户king的家目录</p><p>passwd 用户名  指定密码否则如果不写用户名就是当前用户的密码</p><p>pwd显示当前用户在哪一个目录下</p><p>删除用户 userdel  用户名（要切成root删除用户）这是保留家目录的</p><p>userdel  -r 用户名 这是删除家目录的 （注意会把tom全部删除）</p><p>一般情况下建议保留家目录</p><p>查询用户信息 id 用户名，  who am i 查询当前用户信息</p><p>高权限用户到低权限用户不用输密码</p><p>用户组：系统对用共性的多个用户进行统一的股那里</p><p>groupadd 组名 （添加组）groupdel  组名（删除组）</p><p>useradd -g 用户组 用户名 增加用户名的同时增加组</p><p>usermod -g 用户组 用户名 修改用户的组</p><p>/etc/passwd 文件 用户的配置文件，记录用户各种信息</p><p>/etc /shadow 文件 口令配置文件 /etc/group 组的配置文件</p><p>/etc/group文件组的配置文件</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><p>运行级别：0关机1单用户 2多用户无网络 3多用户有玩咯4 系统未使用保留给用户 </p><p>5图形界面6系统重启 </p><p>init 切换不同的运行级别</p><p>systemctl get-default查看当前默认级别 </p><p><a href="https://zhuanlan.zhihu.com/p/102802164">找回root密码</a>或者passwd root在图形界面</p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p>man 获得帮助信息  man ls查看ls指令,ls .al /root 指定目录下所用的内容</p><p>help获得shell内置命令的帮助信息 ，也可百度</p><h3 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h3><p>ls -a显示所有文件，ls -l以列表形式显示当目录</p><p>cd ~回到自己的家目录 cd ..回到上一级目录</p><p>cd /root绝对路径到root cd ../../root相对路径到root目录</p><p>mkdir 要创建一级目录 mkdir /home /dog -p创建多级目录 mkdir /home/animal /dog</p><p>rmdir 删除非空目录 rm -rf  /home /animal强制删除目录</p><p>touch创建空文件 touch  hello.txt</p><p>cp 拷贝文件到指定目录 cp [选项] source dest    -r递归复制整个文件夹  cp hello.txt /bbb</p><p>cp -r /home/bbb /opt/把bbb文件和下面文件拷贝到opt目录</p><p>rm -f(-f是指是否有提示)/home/hello.txt，rm -r /home/bbb强制删除整个文件夹</p><p>mv 移动文件到目录或重命名  mv old.txt new.txt重命名,mv pig.txt /root移动文件到root目录（也可移动并且重命名）mv /opt/bbb  /home/移动到home目录下</p><p>cat指令查看文件内容  cat -n 显示行号（这个命令只能浏览文件而不能修改文件） </p><p>cat -n /etc/profile|more</p><p>more一般用来交互，查看文件是一个基于vi的编辑器可以与cat一起使用也可以 more 目录</p><p>使用:f可以查看你当前行号， 交互：可以 空格键向下翻</p><p>less 根据显示的需要加载内容对于显示大型文件有较高效率，用来查看文件内容  less /opt/杂文.txt</p><p>输入pagedown是下一页 输入pageup是上一页 /字串向下搜寻字串功能 n向下查找N向上查找</p><p>echo 输出环境变量 echo $HOSTNAME ,echo “hello” 输出hello</p><p>head 文件查看头文件10行内容 head -n 5 文件(比如etc/profile)查看文件头5行内容</p><p>tail 输出文件中尾部内容 与head同理 tail -f实时追踪该文档的更新，退出ctrl+c</p><p>输出重定向&gt;和&gt;&gt;追加，如： ls -l &gt; 文件 列表的内容覆盖写入文件中 ls -l &gt;&gt;文件 文件追加内容 </p><p>cat 文件1 &gt;  文件2 将文件1的内容覆盖到文件2（类似拷贝） ,echo “ok” &gt; 文件，将文件内容覆盖为“ok”</p><p>In 软连接 （相当于快捷方式） In -s 文件或目录 软连接名（如果cd 软连接名相当于进入该目录）</p><p>如果删除就是用 rm （注意最后不要带上斜杠否则代表这是一个目录）</p><p>history查看执行过的历史命令 history 10显示最近10条指令</p><h3 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h3><p>date 显示当前时间 date + %Y像是年份  date “+%Y-%m%d“显示年月日 H M S时分秒</p><p>date -s 字符串时间，设置日期   </p><p>cal查看日历指令   cal 2020显示2020年所有日历</p><h3 id="搜索查找指令"><a href="#搜索查找指令" class="headerlink" title="搜索查找指令"></a>搜索查找指令</h3><p>find 指令  -name指定文件名 -user指定用户 -size 指定文件大小</p><p>如 find /home -name hello.txt ,find / -szie  +(-) 200M(k，G)</p><p>ls -lh更加人性化查看方式</p><p>locate指令，快出定位文件路径，无需遍历整个文件，查找速度快，该指令执行之前必须下必须先执行updatedb命令</p><p>which 查看指令在哪个目录下 如which ls</p><p>grep指令(过滤指令，查找内容)和管道符号|表示将前一个命令处理结果输出传给后面一个指令处理</p><p>cat /home/hello.txt :|grep -n “yes”,或者grop -n “yes” /home/hello.txt  -i忽略大小写</p><h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><p>gzip 用于压缩文件， gunzip用于解压的</p><p>zip用于压缩文件和文件夹 unzip用于解压的文件夹的</p><p>zip -r myhome.zip /home/将home目录以及其包含文件和子文件都压缩</p><p>unzio -d  /opt/temp myhome.zip 将文件解压到对应目录下</p><p>tar指令是打包指令 打包后文件是 .tar.gz文件  -c产生打包文件 -v显示像是信息 -z打包同时压缩  -x解包</p><p>tar -zcvf pc.tar.gz /home/pig.txt   tar-zxvf home/pc.tar.gz -C /opt/tmp2  解压到哪个目录 -C</p><h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><p>linux用户必须属于一个组，不能独立于组外</p><p>所有者：文件由谁拥有  所在组：文件拥有者所在的组 其他组：不在文件所在组上</p><p>查看所有者(第三列)  ls -ahl   修改文件所有者 chown 用户名 文件名</p><p>组的创建 groupadd 组名  创建一个用户fox放入组中 useradd -g monster fox</p><p>修改文件所在的组 chgrp 组名 文件名(目录)</p><p>改变用户所在的组：usermod -g 组名 用户名，usermod -d 目录名 用户名 改变用户登录的初始目录</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>第0位确定文件类型 d, -,l,c,b   l:链接 ，d是目录，c是字符设备比如鼠标键盘， b是块设备比如硬盘 ，-代表是普通文件</p><p>第1-3位确定文件所用者拥有该文件的权限  </p><p>第4-6位确定所属组（同用户组的）所拥有文件的权限</p><p>第7-9位确定其他用户拥有该文件的权限</p><p>rwx到文件：r代表可读 w代表可修改但是不代表可以删除一个文件删除一个文件代表对目录有写权限 x代表可执行</p><p>rwx到目录 r代表可以读取，ls查看目录内容，w代表可写：对目录内创建修改删除文件 x可以进入该目录</p><p>r=4,w=2,x=1 rwx=7      1：硬链接树或子目录数</p><p>修改权限chmod  </p><p>第一种方式 + - = 变更权限 ，u：所有者 g:所有者 o:其他人  a:所有人</p><p>chmod u=rwx,g =rx,o=x 文件/目录名,chmod o+w,chmod a-x</p><p>chmod 755 目录=chmod  rwxr-xr-xmu’lu</p><p>修改文件所有者 chown </p><p>chown newowner（tom）  文件/目录改变所有者</p><p>chown newowner:newgroup 文件目录  改变所有者和所在组  -R将目录下所有文件改变所有者</p><p>chgrp 修改文件所在组 chgrp newgroup 文件/目录  -R同理</p><h3 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h3><p>任务调度：系统在某个个时间执行特定的命令或程序</p><p>基本语法 crontab -e  +命令编辑定时任务 -l查询任务 -r删除当前所有的任务</p><p>5个星号分别表示从分 时 天 月 星期几如 <em>/1</em>***  +命令 表示每分钟执行</p><p>，表示不连续的时间 -代表范围 8 */n每个多久执行  0 5 * * 1-6周一到周六5点执行（注意星期几和几号最好不要同时出现否则容易混乱）</p><p>crontab -r终止任务调度 crontab -l列出当前有哪些任务进度 service crond restart重启任务调度</p><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><p>at命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行，使用at命令一定要保证atd进程的启动，默认情况下，atd守护进程每60秒检查作业队列，有作业时会检查作业运行时间，如果时间与当前时间匹配则运行此任务</p><p>ps -ef 当前执行的进程有哪些 | grep atd  过滤atd 检测atd是否运行</p><p>每隔60秒对每个作业(队列)执行一次，任务执行完就出列</p><p>at [选项] [时间] 回车  ctrl+D（两次）结束at命令输入  <a href="https://www.cnblogs.com/mq0036/p/14645726.html">at的选项</a></p><p>at指定时间的方法 <a href="https://idc.wanyunshuju.com/cym/120a.html">at命令在指定的时间执行</a></p><p>删除已经设置的任务 atrm 编号</p><h3 id="磁盘分区机制"><a href="#磁盘分区机制" class="headerlink" title="磁盘分区机制"></a>磁盘分区机制</h3><p>linux分区只有一个根目录，一个独立且唯一的文件结构，每个分区用来组成文件系统的一部分，linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，将一个分区和一个目录联系起来，这是载入的一个分区将使它的存储空间在一个目录下获得。、</p><p>linux硬盘分为IDE (hdx<del>)和 SCSI(sdx</del>)目前基本上是SCSI硬盘</p><h3 id="磁盘的挂载与应用"><a href="#磁盘的挂载与应用" class="headerlink" title="磁盘的挂载与应用"></a>磁盘的挂载与应用</h3><p>分配新的硬盘空间：虚拟机右键设置-硬盘-设置大小（重启后可查看硬盘）</p><p>lsblk (查看硬盘使用情况)</p><p>分区命令 fdisk /dev/sdb  输入m可增加分区，然后输入w确认分区退出（q）</p><p>mkfs -t ext4 /dev/sdb 格式化硬盘</p><p>mount /dev/sdb1  /newdisk挂载到newdisk文件夹下</p><p>卸载: umount /dev/sdb1 或者umount newdisk</p><p>但是用命令行挂载如果重启就会消失  永久挂载通过修改/etc/fstab实现挂载，添加完成后执行 mount -a即可生效![1628254946502](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1628254946502.png)</p><p>注意永久挂载如果错误使用会进入紧急模式而开不了机</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><p>查询整体磁盘使用情况 df -h</p><p>查询指定目录的磁盘占用情况 du -h 目录 否则默认为当前目录  -a含文件 -s大小汇总 -max-depth=1查询深度为1 </p><p>ls- l /opt|grep “^-“ |wc -l；统计opt文件夹下文件个数，ls- l /opt|grep “^d” |wc -l 统计Opt文件夹下 目录的个数</p><p>ls- lR /opt|grep “^d” |wc -l 统计opt文件夹下文件个数包括子文件个数</p><p>树状显示目录结构tree 目录，如果没有tree 则使用 yum install tree  </p><h3 id="NAT网络配置"><a href="#NAT网络配置" class="headerlink" title="NAT网络配置"></a>NAT网络配置</h3><p>查看windows网络配置 ipconfig</p><p>查看Linux网络配置 ifconfig</p><p>ip只要在同一网段就可以互相通信</p><h3 id="linux网络配置"><a href="#linux网络配置" class="headerlink" title="linux网络配置"></a>linux网络配置</h3><p>第一种方法：自动获取 缺点：每次获取的Ip地址可能不一样  在ipv4下查看</p><p>第二种方法：指定ip,直接修改配置文件来指定IP，并可以连接到外网</p><p>编辑 vi/etc/sysconfig/network-srcipts/ifcfg-ens33</p><p>要求：将IP地址配置的静态的，</p><p>service network restart 或者 reboot     </p><h3 id="设置主机名和host"><a href="#设置主机名和host" class="headerlink" title="设置主机名和host"></a>设置主机名和host</h3><p>指令hostname查看主机名</p><p>修改文件在 /etc/hostname 指定修改主机名 修改后重启生效</p><p>设置hosts映射</p><p>host文件记录主机和ip的映射关系</p><p>在linux  通过主机名找到某个linux系统  在/etc/hosts 指定</p><p>如192.168.200.1  think-pad</p><p>DNS 是互联网作为域名和ip地址相互映射的一个分布式系统</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>ps 查看当前系统哪些进程正在执行  ps -a 显示所有进程信息</p><p>ps -u 以用户格式显示进程信息  ps -x显示后台进程运行的参数</p><p>ps显示的信息：ity终端信息 stat -运行状态 start开始时间  time-占用cpu时间</p><p>command 执行该进程的指令，vsz占用虚拟内存情况 rss占用物理内存大小，mem占用物理内存百分比 ppid父进程</p><p>ps -aux |grep sshd 检测有无sshd服务</p><p>ps -ef以全格式显示当前所有的进程 -e是显示所有进程 -f全格式</p><p>终止进程：  kill [选型]  进程号   ，killall 进程名称 杀死所有进程子进程也结束</p><p>-9强迫进程立即停止</p><p>/bin/systemctl start  sshd.service重启sshd</p><p>查看进程数 pstree 选项  -p显示进程Pid   -u树状形式显示进程用户</p><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务本质就是进程但是运行在后台通常会监听某个端口，等待其他程序的请求</p><p>service 服务名 [start|stop|restart|reload|status]   </p><p>service指令主要用在etc/init.d目录下管理</p><p>centos7.0后很多服务不用service指令而用systemctl</p><p>查看服务名setup 就可看到全部服务  如果前面带星号说明linux开机自动启动，如果去掉需要手动启动</p><p>服务的运行级别  0：系统停机状态 1单用户工作状态  2多用户状态  3 完全多用户</p><p>简化的命令更换级别 init 0</p><p>4系统未使用 5 x11控制台  6系统正常关闭并重启</p><p>systemctl -get-default查看当前运行级别，systemstl -set-default multi-user.target运行级别3  graphical.target运行级别5</p><p>chkconfig 可以给服务的各个运行级别设置自启动/关闭,自启动是针对不同级别的</p><p>chkconfig指令管理服务 在etc/init.d查看</p><p>chkconfig  服务名 –list，chkcongfig –level 5 服务名 on/off</p><p>systemctl  [start|stop|restart|status] 服务名   该指令管理的服务在  /user/lib/systemd/system查看</p><p>systemctl list-unit-files  查看服务开机启动状态</p><p>systemctl enable 服务名  设置服务开机启动   systemctl  disable 服务名   关闭服务开机启动 （意思是三个级别都启动）</p><p>systemctl  is-enabled 服务名  查看服务是否已经启动</p><p>关闭启动防火墙服务只是临时生效，最终还是需要systemctl  disabled enable</p><p>打开端口指令 firewall-cmd –permanent –add-port=端口号/协议</p><p>关闭端口指令 firewall-cmd –permanent –remove-port=端口号/协议  111/tcp</p><p>重新载入，才能生效  firewall-cmd –reload</p><p>查询端口时候开放： firewall-cmd –query-port=端口/协议</p><p>netstat  -anp |more 查询端口协议</p><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top显示正在执行进程，在执行一段时间可以更新正在运行的进程</p><p>top [选项]  -d 秒数  每隔几秒刷新 -i不显示任何闲置或将死进程 -p  通过指定监控进程id来仅仅监控某个进程的状态</p><p>top交互操作输入P以cpu使用率排序  M以内存 N以PID排序 q退出top</p><p>监控特定用户  先输入top  输入u  在输入用户名</p><p>终止指令进程 top  然后输入k  然后输入pid </p><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>netstat 查看系统网络状态  -an按一定顺序排列输出 -p显示哪个进程在调用</p><h3 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h3><p>查询以安装的rpm了列表 rpm -qa| grep xx 查看是否安装什么包</p><p>rpm -q 软件包名  查询该软件包是否安装</p><p>rpm -qi 软件包名 查询软件包信息  ，rpm -ql 软件包名 查询软件包中的文件，rpm -qf 文件全路径名 查询文件所属的软件包</p><p>rpm -e 软件包名  卸载rpm包</p><p>rpm -ivh rpm包全路径名称  安装rpm包  i=安装  v=提示 h=进度条</p><p>卸载的时候 -nodeps强制卸载但是有可能导致另外一个包无法使用</p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>shell前端软件包管理器，基于rpm管理能够从指定雾浮起自动下载rpm包并且安装</p><p>yum list | grep xx软件列表 ， yum install xx下载安装</p><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>虚拟机可以快照，但实体机无法做快照，所以要备份和恢复技术</p><p>1、把需要的文件用tar打包就行，下次需要恢复的时候，在解压开覆盖即可</p><p>2、使用dump和restore命令</p><p>#yum -y install dump</p><p>#yum -y install restore</p><p>dump支持分卷和增量备份</p><p>dump [-c]  [目录或文件系统]</p><p>-c创建新的归档文件吗，并将一个或多个文件参数所指定的内容写入归档文件的开头</p><p>-t 指定文件名，若该文件在备份文件中，则列出名</p><p>-u 备份完毕后，在/etc/dumpdares中记录备份的文件系统，层级，日期和时间，只支持分区</p><p>-0123456789 0为最完整的备份，回备份所有文件</p><p>-j 自动调用压缩工具打包文件</p><p>-W 显示需要备份文件及其最后一次备份的层级，时间，日期</p><p>cat /etc/dumpdates查看备份时间文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uj -f /opt/boot.bak0.bz2 /boot  将备份boot分区</span><br></pre></td></tr></table></figure><p>只有分区才支持增量分区，如果是目录或者文件则不支持增量备份</p><p>restore 命令用来恢复已经备份的文件</p><p>restore [模式选项] [选项] </p><p>-C使用对比模式  -i使用交互模式，-r进行还原模式  -t查看模式看备份文件有哪些文件</p><p><strong>增量恢复要依次执行</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker学习笔记</title>
      <link href="/2021/10/02/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/02/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>centos7安装docker</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh get-docker.sh   </span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version </span><br></pre></td></tr></table></figure><p>检查版本是否安装成功</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker </span><br></pre></td></tr></table></figure><p>开启docker服务端</p><h3 id="创建容器镜像"><a href="#创建容器镜像" class="headerlink" title="创建容器镜像"></a>创建容器镜像</h3><p>容器相当于镜像，镜像是只读的，容器是可读写的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run ubuntu</span><br></pre></td></tr></table></figure><p>拉取一个名为ubuntu的镜像，注意镜像名有有要求，在dockerhub拉取的，所以名字不能乱取</p><h3 id="容器的相关命令"><a href="#容器的相关命令" class="headerlink" title="容器的相关命令"></a>容器的相关命令</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>输入命令后，就会显示出当前已经存在的容器，并且会列出对应的信息。</p><ul><li><p>CONTAINER ID : 容器对应的ID，这个是唯一的</p></li><li><p>IMAGE : 使用的镜像名称，显示不同</p></li><li><p>COMMAND : 执行的相关命令</p></li><li><p>CREATED: 创建的时间</p></li><li><p>STATUS: 目前镜像的状态，一般会有两种状态Up和Exited.</p></li><li><p>PORTS: 协议和端口</p></li><li><p>NAMES: 容器的名称，名字是Docker随机生成的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure></li></ul><p>查看docker所有存在镜像包括停止的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop &lt;name or ID&gt;</span><br></pre></td></tr></table></figure><p>停止容器的相关命令</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm &lt;name or ID&gt;</span><br></pre></td></tr></table></figure><p>删除容器相关的命令</p><h3 id="多容器操作"><a href="#多容器操作" class="headerlink" title="多容器操作"></a>多容器操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ps -aq</span><br></pre></td></tr></table></figure><p>查看所有容器的命令号</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ps -qa)</span><br></pre></td></tr></table></figure><p>得到所有命令号停止</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm $(docker container ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有容器</p><p> 正在运行的容器，是不可以直接删除的，会报错。我们来做个实验。新建一个容器. 要先停止再删除或者强制删除正在运行的容器</p><h3 id="端口映射以及主动模式和被动模式"><a href="#端口映射以及主动模式和被动模式" class="headerlink" title="端口映射以及主动模式和被动模式"></a>端口映射以及主动模式和被动模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 80:80 nginx</span><br></pre></td></tr></table></figure><p> 确定docker对应的容器端口是多少。比如Nginx镜像的端口诗<code>80</code>。知道这个端口后，就可以在启动容器的时候，用<code>-p </code> 的形式，启用映射了。 </p><p> 等待项目启动后，打开浏览器窗口，在地址栏输入<code>127.0.0.1</code>，就可以打开nginx的默认网址 </p><h4 id="主动模式attach模式"><a href="#主动模式attach模式" class="headerlink" title="主动模式attach模式"></a>主动模式attach模式</h4><p> 当打开<code>127.0.0.1</code>网址的时候，终端上打印出了相关的日志（log），平且每访问一次，都会增加一条日志。也就是说Docker容器的日志会实时的展现到窗口并且占用此端口。这种模式叫做attached模式。 </p><h4 id="detach模式"><a href="#detach模式" class="headerlink" title="detach模式"></a>detach模式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">90</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>这次你会看到，和<code>attached</code>模式不同的是，这次输入完命令后，只显示出了容器的编号，并且可以再输入任何命令。就算我们关掉窗口，容器依然运行，也就是他是在系统后台进行运行的。</p><p>这种就比较适合在生产环境中运行，停掉和删除容器都需要使用<code>Shell脚本</code>的形式。减少了很多误操作。</p><p>输入127.0.01:90就可以通过90端口访问</p><h4 id="detach模式转为attach模式"><a href="#detach模式转为attach模式" class="headerlink" title="detach模式转为attach模式"></a>detach模式转为attach模式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  attach &lt;ID or Image Name&gt;</span><br></pre></td></tr></table></figure><h4 id="detach模式查看日志"><a href="#detach模式查看日志" class="headerlink" title="detach模式查看日志"></a>detach模式查看日志</h4><p>先复习一下上节课的内容，用<code>detached</code>模式开启一个<code>nginx</code>服务，并映射服务器的<code>80端口</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>容器被运行起来了，是<code>detached</code>模式，也就是Docker 的后台运行模式。这时候想要查看后台日志，可以使用下面的命令查看。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs &lt;ID or Image name&gt;</span><br></pre></td></tr></table></figure><p>虽然日志在窗口中出现了，但只打印一次<code>logs</code>,如果想动态一直跟踪日志，可以在命令上加入一个<code>-f</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs -f &lt;ID or Image name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker交互模式"><a href="#docker交互模式" class="headerlink" title="docker交互模式"></a>docker交互模式</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu sh</span><br></pre></td></tr></table></figure><p><code>-it</code>代表启用交互模式，<code>sh</code>代表可以使用Shell脚本。当你输入玩这个脚本后，Docker就会进入到交互模式。可以使用<code>ls</code>来得到目录下的文件，也可以使用<code>hostname</code>来查看计算机名称。</p><p> 这时候你想退出容器和交互模式可以输入<code>exit</code>命令。需要重点说明的是，随着命令退出后，容器也会跟着退出，变成<code>Exited</code>模式。 </p><p>如果我们想退出交互，但是并不想停止容器。可以先开启<code>detached模式</code>，然后通过命令进入交互模式。</p><p>再用<code>detached模式</code>创建一个<code>nginx镜像</code>的容器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>直接通过下面的命令就可以进入到交互模式下了。（重要）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;ID or Image name&gt; sh </span><br></pre></td></tr></table></figure><p><code>exec</code>是执行的意思，<code>-it</code>交互模式 ， <code>sh</code>交互的方式，用shell脚本进行交互</p><h3 id="镜像获取拉取删除"><a href="#镜像获取拉取删除" class="headerlink" title="镜像获取拉取删除"></a>镜像获取拉取删除</h3><h4 id="镜像的获取"><a href="#镜像的获取" class="headerlink" title="镜像的获取"></a>镜像的获取</h4><ul><li><p>从网络社区直接拉取，在Docker里这种社区叫做<code>Registry</code>(登记处)（pull from registry）</p></li><li><p>从Dockerfile构建一个镜像，这是DIY一个镜像，同时整个构建过程是需要联网，因为需要西在基础镜像，然后根据基础镜像进行构建（build from Dockerfile）。</p></li><li><p>自有文件的导入，可以从本地导入已经构建好的镜像文件，在没有网络的时候可以用。这个文件是通过已有的镜像导出来的压缩包，然后就可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image</span><br></pre></td></tr></table></figure><p> 对于Image操作的所有命令和提示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull wordpress</span><br></pre></td></tr></table></figure></li></ul><p>拉取wordpress镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>查看镜像列表的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull wordpress:cli-php8.0</span><br></pre></td></tr></table></figure><p>下载对应版本的镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect baf</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm &lt;Image ID&gt;</span><br></pre></td></tr></table></figure><h4 id="镜像导入导出"><a href="#镜像导入导出" class="headerlink" title="镜像导入导出"></a>镜像导入导出</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image save busybox:latest -o mybusybox.image</span><br></pre></td></tr></table></figure><p><code>save</code>是导出/保存的意思，<code>busybox:latest</code>是镜像名称+版本号， <code>-o</code>代表输出，<code>mybusybox.image</code>是导出后镜像的名字。</p><p>导入镜像步骤</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm busybox</span><br></pre></td></tr></table></figure><p>删除后直接导入镜像。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image load -i .\mybusybox.image</span><br></pre></td></tr></table></figure><h3 id="dockfile"><a href="#dockfile" class="headerlink" title="dockfile"></a>dockfile</h3><p> Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。 </p><ul><li><p>Dockerfile是用于构建docker镜像的文件</p></li><li><p>Dockerfile里包含了构建镜像所需的”指令“</p></li><li><p>Dockerfile有其特定的语法规则</p><h4 id="dockerfile-文件编写"><a href="#dockerfile-文件编写" class="headerlink" title="dockerfile 文件编写"></a>dockerfile 文件编写</h4><p>首先装一个Ubuntu系统。</p><p>第二步，下载安装Python环境</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3<span class="number">.9</span> python3-pip python3<span class="number">.9</span>-dev</span><br></pre></td></tr></table></figure><p>第三步，准备<code>jspang.py</code>文件。这个可以在<code>D盘</code>新建一个<code>DockerTest文件夹</code>，然后在文件夹中新建一个<code>jspang.py</code>文件，然后编写下面的文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello JSPang&quot;</span>)</span><br></pre></td></tr></table></figure><p>第四步，运行jspang.py</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 hello.py</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>编写Dockerfile文件（建议把Dockerfile文件和jspang.py文件放在一起个文件夹下）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN  apt-get update &amp;&amp; \</span><br><span class="line">         DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3<span class="number">.9</span> python3-pip python3<span class="number">.9</span>-dev</span><br><span class="line">ADD jspang.py /</span><br><span class="line">CMD [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;jspang.py&quot;</span>]</span><br></pre></td></tr></table></figure></li></ul><p>有了<code>Dockerfile</code>和<code>jspang.py</code>文件以后，通过<code>PowerShell</code>进入到两个文件的文件夹。通过Docker命令就可以完成构建。</p><h4 id="通过dockerfile构建镜像"><a href="#通过dockerfile构建镜像" class="headerlink" title="通过dockerfile构建镜像"></a>通过dockerfile构建镜像</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t &lt;Name:tag&gt; <span class="xml"><span class="tag">&lt;<span class="name">file</span> <span class="attr">path</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过已经写好的Dockerfile，构建一个<code>jspang</code>的镜像，可以使用下面的命令构建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t jspang .</span><br></pre></td></tr></table></figure><p>（注意命令最后是有一个<code>.</code>的），如果是第一次执行打包，这个过程还比较久的，当出现FINISHED后，说明打包完成了。</p><p>打包完成后，可以通过<code>docker image ls</code>命令来查看现在拥有的镜像列表。如果一切正常，可以看到名字为<code>jspang</code>的镜像已经存在了。</p><p>可以执行容器，验证一下自己DIY的镜像是否可用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run jspang</span><br></pre></td></tr></table></figure><p>镜像如果正常，应该正确现实出<code>Hello JSPang</code>字样，然后就直接退出容器了。这是跟我们写的Dockerfile有关的。</p><p>，就是重新<code>build</code>一个镜像，。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t jspangcom/jspang .</span><br></pre></td></tr></table></figure><p>也可以通过<code>docker image tag</code>命令，具体语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag &lt;old image name &gt; <span class="xml"><span class="tag">&lt;<span class="name">new</span> <span class="attr">iamge</span> <span class="attr">name</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>例如把<code>jspang</code>这个镜像，改为<code>jspangcom/jspang</code>镜像,命令可以如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag jspang jspangcom/jspang</span><br></pre></td></tr></table></figure><h4 id="推送到dockerhub"><a href="#推送到dockerhub" class="headerlink" title="推送到dockerhub"></a>推送到dockerhub</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>执行命令好，会要求输入<code>Username</code>，也就你<code>Dockerhub ID</code>，还需要输入密码。如果输入正确，并出现<code>Login Succeeded</code>就证明登录成功了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push Name[:TAG]</span><br></pre></td></tr></table></figure><p>比如就是把刚才的<code>jspangcom/jspang</code>镜像push到社区，就可以使用下面的命令。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push jspangcom/jspang</span><br></pre></td></tr></table></figure><h3 id="dockerfile编写指南"><a href="#dockerfile编写指南" class="headerlink" title="dockerfile编写指南"></a>dockerfile编写指南</h3><h4 id="from语法"><a href="#from语法" class="headerlink" title="from语法"></a>from语法</h4><p>第一句就是<code>FROM ubuntu:latest</code> , 它的意思是选择一个基础镜</p><p>几乎所有的Dockerfile文件，要做的第一件事就是要选择一个基础镜像。<code>FROM ubuntu:latest</code>并不是一个最优写法。</p><p>选择镜像3个原则</p><ol><li><p>官方镜像优于非官方的镜像；</p></li><li><p>固定版本的版本（tag），而不是每次都使用latest;</p></li><li><p>功能满足，选择体积小的镜像；镜像体积大则他人越不会使用</p><h4 id="run语法正确形式"><a href="#run语法正确形式" class="headerlink" title="run语法正确形式"></a>run语法正确形式</h4><p>分层越多维护越难</p><p>把所有执行命令放到一个RUN里，并用<code>&amp;&amp; \</code>进行连接。就可以把很多命令写到一个RUN里边了。</p><p>以下是安装ipinfo的linux操作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y wget &amp;&amp; \</span><br><span class="line">    wget https:<span class="comment">//github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \</span></span><br><span class="line">    tar zxf ipinfo_2<span class="number">.0</span>.1_linux_amd64.tar.gz &amp;&amp; \</span><br><span class="line">    mv ipinfo_2<span class="number">.0</span>.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; \</span><br><span class="line">    rm -rf ipinfo_2<span class="number">.0</span>.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure></li></ol><p>这样所有的RUN命令只生成一层<code>image layer</code>。打包出来的镜像也没有那么大了。这个文件写到<code>Dockerfile.good</code>文件里，然后用命令进行打包。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -f dockerfile.good -t ipinfo-good .</span><br></pre></td></tr></table></figure><p> 这时候再用<code>docker image histroy </code> 查看分层，就会看到分层少了很多。 不要每一行都写一个run命令</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《图解HTTP》学习笔记</title>
      <link href="/2021/10/02/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/02/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h1><h2 id="1、了解web网络基础"><a href="#1、了解web网络基础" class="headerlink" title="1、了解web网络基础"></a>1、了解web网络基础</h2><p>HTTP协议处于TCP/IP应用层，应用层包括FTP和DNS</p><p>传输层有TCP和UDP还有网络层和链路层</p><p>IP网际协议位于网络层，IP地址指明节点被分配到地址,MAC地址是指网卡所属固定地址，IP地址可以和MAC地址进行配对</p><p>TCP协议提供可靠的字节流服务，将大块数据分割成以报文段为单位数据包进行管理，为了确保数据准确送到目标处，TCP协议采用了三次握手，握手过程中使用TCP标志-SYN和ACK，发送端首先发送一个带SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志数据包表示传达确认信息。最后发送端回传一个带ACK标志的数据包，代表握手结束。</p><h2 id="2、简单的HTTP协议"><a href="#2、简单的HTTP协议" class="headerlink" title="2、简单的HTTP协议"></a>2、简单的HTTP协议</h2><p>请求必定由客户端发出，服务端回复相应</p><p>HTTP是不保存的协议，即无状态协议，HTTP协议自身不对请求和响应之间的通信状态进行保存，也就是说在HTTP这个级别，协议对于发送过的请求或相应都不做持久化处理</p><h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><p>GET： 获取资源，GET方法用来请求访问已被URI识别的资源，指定的资源经过服务器端解析后返回相应内容。</p><p>POST：传输实体主体吗，一般不用GET方法进行传输而是用POST方法</p><p>PUT：传输文件，PUT方法用来传输文件，但是HTTP1.1的PUTY方法自身不带验证机制任何人可以上传文件，因此Web网站不使用该方法。</p><p>HEAD：获得报文首部，不返回报文主题部分，用于确认URI的有效性以及资源更新的日期时间</p><p>DELETE：删除文件，同样不带验证机制</p><p>OPTIONS：询问支持方法</p><p>TRACE：追踪路径，让web服务器将之前的请求通信环回给客户端方法，可以知道请求时怎样修改的，但是容易引发XST攻击</p><p>CONNECT：要求用隧道协议连接代理，要求于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL和TLS协议将通信内容加密后经网络隧道传输</p><h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p>持久连接特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态，目的在于减少额外开销，减轻服务器端的负载。同时使管线化成为可能。</p><h3 id="使用Cookie状态"><a href="#使用Cookie状态" class="headerlink" title="使用Cookie状态"></a>使用Cookie状态</h3><p>Cookie会根据服务器端发送的响应报文一个叫做Cookie信息来的首部字段信息，通知客户端保存Cookie，当下次客户端再往服务器发送请求时，客户端回自动在请求报文中加入Cookie值后发送出去。服务器发现客户端Cookie后回检查究竟是从哪一个客户端发来的连接请求，对比服务器上记录，最后得到之前状态信息。</p><h2 id="3、报文HTTP信息"><a href="#3、报文HTTP信息" class="headerlink" title="3、报文HTTP信息"></a>3、报文HTTP信息</h2><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>用于HTTP协议交互信息称为HTTP报文，报文大致可分为报文首部和报文主体两块</p><p>报文主体用于传输请求或响应的实体主体，通常报文主体等于实体主体。只有当传输中进行编码操作哦时，实体主体内容发生变化，才导致它和报文护体产生差异。</p><h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在传输大容量数据时，通过把数据分割成多块，能够浏览器逐步显示页面这种分块的功能成为分块传输编码。 </p><h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商技术有3种类型</p><p>服务器驱动协商：以请求首部字段为参考，在服务器端自动处理</p><p>客户端驱动协商：用户从浏览器显示可选列表中手动选择</p><p>透明协商：服务器端和客户端各自进行内容协商一种方法</p><h2 id="4、返回结果HTTP状态码"><a href="#4、返回结果HTTP状态码" class="headerlink" title="4、返回结果HTTP状态码"></a>4、返回结果HTTP状态码</h2><p>借助状态码用户可以知道服务器端时正常处理了请求还是出现错误</p><h3 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>2xx的响应结果表明请求被正常处理了</p><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>代表服务器接收请求已经成功处理，但在返回的响应报文中不含实体的主体部分。也不允许返回任何实体的主体。</p><h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>表示客户端进行范围请求，服务器成功执行了这部分的GET请求</p><h3 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向，该状态码表示请求的资源已经被分配了新的URI，以后使用资源现在所指的URI。</p><h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时性重定向，状态码表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问</p><h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>请求对应的资源存在另外一个URI，应该使用GET方法定向获取请求的资源与302区别是明确表示应该采用GET方法获取资源</p><h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。</p><h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向，与302有相同的含义，307不会从POST变成GET</p><h3 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>请求报文中存在语法错误，错误发生时，要修改请求的内容后再次发送请求。另外会像200OK一样对待该状态码</p><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>请求需要有通过HTTP认真的认证信息，如果之前有过次，则表示用户认证失败</p><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>请求资源的访问被服务器拒绝了，可以在实体的主体部分对原因进行描述，未获得文件系统的访问授权，访问权限出现某些问题都可能是403原因</p><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>服务器无法找到请求的资源。</p><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>服务器端在执行请求时发生了错误，也有可能时Web应用存在的bug或临时的故障</p><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><p>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求.</p><p><strong>不少返回的状态码的响应都是错误的,但是用户可能察觉不到这点</strong></p><h2 id="5、与HTTP协作Web服务器"><a href="#5、与HTTP协作Web服务器" class="headerlink" title="5、与HTTP协作Web服务器"></a>5、与HTTP协作Web服务器</h2><p>相同的IP地址下,由于虚拟主机可以寄存多个不同主机名和域名的Web网站,因此在发送HTTP请求时,必须在Host首部内完整指定主机名或域名URI</p><h3 id="通信数据转发程序：代理网关隧道"><a href="#通信数据转发程序：代理网关隧道" class="headerlink" title="通信数据转发程序：代理网关隧道"></a>通信数据转发程序：代理网关隧道</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理：是一种有转发功能的应用程序，扮演了位于服务端和客户端中间人的角色，接受由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p><strong>使用代理服务器的原因时利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问是指为主要目的</strong></p><p>代理按两种基准分类，一种是是否使用缓存，另一种是是否会修改报文</p><p>缓存代理：代理转发响应会预先将资源的副本保存在代理服务器上</p><p>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关：转发其他服务器通信数据的服务器，接受从客户端发送的请求时，就像自己拥有资源的源服务器一样对请求进行处理。</p><p><strong>网关能使通信线路上的服务器提供非HTTP协议服务也能提供通信安全性</strong></p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道：相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接应用程序。</p><p>隧道不会解析HTTP请求</p><h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h3><p>利用缓存可以减少对源服务器的访问，因此也节省了通信流量和通信时间。但是即使缓存服务器内有缓存也不能每次返回对同资源的请求，因为换缓存资源存在有效性。</p><p>缓存也可以在客户端浏览器中，一般称为临时网络文件，浏览器缓存如果 有效则可以直接从本地磁盘内读取。</p><h2 id="6、HTTP首部"><a href="#6、HTTP首部" class="headerlink" title="6、HTTP首部"></a>6、HTTP首部</h2><p>HTTP首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。报文首部由几个字段构成</p><p>在请求中HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成</p><p>在响应中HTTP报文由HTTP版本、状态码、HTTP首部字段3部分构成</p><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为给浏览器和服务器提供报文主体大小，所使用的语言、认证信息等内容</p><h4 id="4种HTTP首部字段类型"><a href="#4种HTTP首部字段类型" class="headerlink" title="4种HTTP首部字段类型"></a>4种HTTP首部字段类型</h4><p>1、通用首部字段请求报文和响应报文两方都会使用的首部</p><p>2、请求首部字段</p><p>3、响应首部字段</p><p>4、实体首部字段：针对请求报文和响应报文的实体部分使用的首部。</p><h4 id="End-to-end首部和Hop-by-hop首部"><a href="#End-to-end首部和Hop-by-hop首部" class="headerlink" title="End to end首部和Hop by hop首部"></a>End to end首部和Hop by hop首部</h4><p>首部字段将定义成缓存处理和非缓存处理代理的行为</p><p>端到端首部：首部会转发请求和响应对应的最终接受目标，且必须保存由缓存生成的响应中，另外规定它必须被转发。</p><p>逐条首部：只对单次转发有效，会因通过缓存或代理而不在转发，<strong>如果HTTP1.1后使用，需要提供Connection首部字段</strong></p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制</p><p>public指令：明确表明其他用户也可利用缓存</p><p>private指令：相应只以特定的用户作为对象，这与public相反</p><p>no-cache指令：防止从缓存中返回过期的资源，客户端请求如果包含该指令，表示客户端将不会接受缓存过的响应，于是，“中间”的缓存服务器必须客户端请求转发给源服务器。如果服务器返回响应包含该指令，缓存服务器不能缓存，源服务器也将不再对缓存服务器请求中提出的资源有效性确认，禁止其对响应资源进行缓存操作。</p><p>no-store指令:规定缓存不能在本地存储请求或响应任一部分。</p><p>s-maxage指令：只适用于供多为用户使用公共缓存服务器。对同一用户重复返回响应服务器来说，指令没有任何作用。</p><p>max-age指令：判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源，若为0，需要将请求转发给源服务器。<strong>且缓存服务器不对资源有效性再作确认，1.1版本会优先处理max-age忽略，1.0则相反</strong></p><p>min-fresh指令：要求缓存服务器返回至少还未过指定时间的缓存资源。</p><p>max-stale指令：可知识缓存资源过期也照样接收。如果为指定参数值则无论过多久客户端都会接收响应。</p><p>only-if-cached指令：表示客户端仅在缓存服务器本地缓存目标资源的情况下才回要求其返回。</p><p>must-revalidate指令：代理会向源服务器再次验证即将返回的响应缓存目前是否依然有效。若无法连通，则缓存必须给客户一条504状态码，<strong>且该指令会忽略max-stale</strong></p><p>proxy-revalidate指令:要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p><p>no-transform指令：无论在请求或响应中，缓存都不能改变实体主体的媒体类型，可防止压缩图片等类似操作。</p><p>cache-extension标记：可以扩展Cache-Control首部字段内的指令</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>控制不再转发给代理的首部字段</p><p>管理持久连接（想明确断开连接时，则指定Connection首部字段的值为Close）</p><h4 id="Date；"><a href="#Date；" class="headerlink" title="Date；"></a>Date；</h4><p>首部字段Date表明HTTP报文的日期和时间</p><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>是HTTP1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。</p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>会先说明报文主体后记录了哪些首部字段。</p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>传输报文主体采用编码方式，1.1的传输编码仅对分块传输编码有效。</p><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>用于检测HTTP协议及其他协议时候可使用更高的版本进行通信，参数值可以用来指定一个完全不同的通信协议。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>为了追踪客户端与服务器之间的请求和响应报文的传输路径，还可避免请求回环的发生。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>告知用户一些与缓存相关的问题的警告。</p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>客户端往服务器发送请求报文中所使用的字段用于补充请求的附加信息，客户端信息，对响应内容相关的优先级等内容。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。</p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>告知用户服务器，用户代理的认证信息。，通常在401状态码响应后，把首部字段Authorization加入请求中，共用缓存在接收到含有该首部字段的请求时的操作处理会略有差异。</p><h4 id="Except"><a href="#Except" class="headerlink" title="Except"></a>Except</h4><p>告知服务器，期望出现某中特定的行为，因服务器无法理解客户端的期望做出回应而发生错误时，会返回417，客户端可以利用该首部字段写明所期望的扩展</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>首部字段Host会告知服务器,请求的资源所处的互联网主机名和端口号,Host首部字段是1.1规范内唯一一个必须包含在请求内的首部字段.</p><h4 id="If-xxx"><a href="#If-xxx" class="headerlink" title="If-xxx"></a>If-xxx</h4><p>这种样式的请求首部字段,都可称为条件请求</p><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><p>接收到从代理服务器发来的认证质询时,客户端会发送包含首部字段该请求,以告知服务器认证所需要的信息</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>对于只需获取部分资源的范围请求，包含首部字段即可告知服务器资源的指定范围，如请求从多少字节到多少字节。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>会告知服务器请求的原始资源的URI。但当直接在浏览器的地址栏输入URI，或出于安全性的考虑时，也可以不发送该首部字段。</p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>源服务器在多久前创建了响应</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>能告知客户端实体表示，是一种可将资源以字符串形式做唯一性标识的方式。当资源更新，ETag值也需要更新，生成该值并没有算法规则，由服务器分配。<strong>强ETag无论实体发生多么细微的变化都会改变其值，弱ETag只用于提示资源是否相同，只有发生根本性变化才会改变</strong></p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>使用该首部字段可以将响应接收方引导至某个与请求URI位置不同的资源。</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><p>告知客户端应该在多久之后再次发送请求，主要配合状态码503响应。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息，不单单会标出服务器上软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p>可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>用于通知客户端能够支持Request-URI指定资源的所有格HTTP方法。当收不到支持的HTTP方法时，会以405返回，同时能支持的方法写入Allow后返回</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>会将资源失效的日期告知客户端，缓存服务器在接收到含有该字段的响应后会以缓存来应答请求，在该字段指定的时间之前，响应的副本会一直被保存，当超过指定的时间后，缓存服务器在请求发送过来时，会向源服务器请求资源。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从武器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。</p><h3 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h3><h4 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h4><p>意为拒绝个人信息被采集，是表示拒绝被精准广告追踪的一种方法。0为同意追踪，1为不同意<strong>且DNT具有有效性，所以需要对DNT做对应的支持</strong></p><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>可以将web网站上的个人隐私变成一种仅供程序课理解的形式，以达到保护用户隐私的目的。</p><h2 id="7、确保web安全的HTTPS"><a href="#7、确保web安全的HTTPS" class="headerlink" title="7、确保web安全的HTTPS"></a>7、确保web安全的HTTPS</h2><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><p>1、通信使用明文，内容可能会被窃听（利用抓包工具获取HTTP协议的请求或响应并解析，因此可以对通信加密如SLL加密、内容加密如对报文加密）</p><p>2、不验证通信方的身份，因此有可能遭遇伪装（可以查明对手证书验证身份）</p><p>3、无法证明报文的完整性，可能已经被篡改（由于会中间人攻击，因此可以利用散列值校验）</p><h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h3><p>HTTPS就是身披SSL外壳的HTTP，SSL可以说是当今世界应用最为广泛的网络安全技术</p><p>HTTP采用共享密钥加密和公开密钥加密两者并用的混合加密机制，公开密钥相比共享密钥处理速度慢但更安全。</p><p><strong>HTTP通信步骤</strong></p><p><img src="C:\Users\10379\AppData\Roaming\Typora\typora-user-images\image-20211003212536596.png" alt="image-20211003212536596"></p><p>HTTPS与单纯文本通信会消耗更多的CPU及内存资源只有敏感信息才这样加密</p><h2 id="8、确认访问用户身份的认证"><a href="#8、确认访问用户身份的认证" class="headerlink" title="8、确认访问用户身份的认证"></a>8、确认访问用户身份的认证</h2><p>为了确认网络那头究竟有谁，是谁在访问服务器，因此要认证。</p><p>HTTP常用的认证方式</p><p>1、BASIC认证（基本认证）</p><p>2、DIGEST认证（摘要认证）</p><p>3、SSL客户端认证</p><p>4、FormBase认证（基于表单认证）</p><h2 id="9、基于HTTP的功能追加协议"><a href="#9、基于HTTP的功能追加协议" class="headerlink" title="9、基于HTTP的功能追加协议"></a>9、基于HTTP的功能追加协议</h2><h3 id="消除HTTP瓶颈的SPDY"><a href="#消除HTTP瓶颈的SPDY" class="headerlink" title="消除HTTP瓶颈的SPDY"></a>消除HTTP瓶颈的SPDY</h3><p>比如实时显示更新的内容HTTP无法妥善的处理好这项任务。</p><p>以下HTTP标准会成为瓶颈</p><p>1、一条连接上只发送一个请求</p><p>2、请求只能从客户端开始。客户端不可以接收除响应以外的指令。</p><p>3、请求、响应首部未经压缩就发送。首部信息月多延迟越大。</p><p>4、发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</p><p>5、可任意选择数据压缩 格式。非强制压缩发送。</p><p>Ajax和Comet等技术，一定程度上使HTTP得到了改善，但HTTP协议本身的限制仍然很大，因此需要协议层面上的改动。</p><p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接，同时通信中使用SSL</p><p>使用SPDY，HTTP协议获得以下功能</p><p>1、多路复用流</p><p>2、赋予请求优先级。</p><p>3、压缩HTTP首部</p><p>4、推送功能</p><p>5、服务器提示功能</p><p>SPDY是一种可有效消除HTTP瓶颈的技术，但很多WEB网站存在并非仅仅是由HTTP瓶颈所导致，还可以改善WEB内容编写。</p><h3 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h3><p>主要是为了解决Ajax和Comet里XMLHttpRequest附带缺陷所引起的问题。</p><p>一旦服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送XML、HTML或图片等任意格式数据。且无论是服务器还是客户端任意一方都可直接向对方发送报文。</p><p>主要特点</p><p>1、推送功能</p><p>2、减少通信量</p><p><strong>为了实现该该通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手目的。</strong></p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><h4 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h4><p>是一个可对web服务器上的内容直接进行文件复制、编辑等操作的分布式系统。</p><h2 id="10、构建web内容的技术"><a href="#10、构建web内容的技术" class="headerlink" title="10、构建web内容的技术"></a>10、构建web内容的技术</h2><h4 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h4><p>指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在CGI作用下，程序会对请求内容做出相应的动作如创建HTML等动态内容</p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>是一种能在服务器上创建动态内容的程序，是用java语言实现的一个接口，运行在Web服务器相同的进程中，因此受到的负载较小，该运行环境叫做Web容器或Servlect容器。</p><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>是一种可按应用目标进行扩展的通用标记语言，旨在通过该使用XML，使数据共享变得更容易。</p><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>是一种JavaScript对对象表示法为基础的轻量级数据标记语言，让数据更轻更纯粹，并且JSON自负床形式可被JavaScript轻易读入。</p><h2 id="11、Web的攻击技术"><a href="#11、Web的攻击技术" class="headerlink" title="11、Web的攻击技术"></a>11、Web的攻击技术</h2><h3 id="针对web攻击技术"><a href="#针对web攻击技术" class="headerlink" title="针对web攻击技术"></a>针对web攻击技术</h3><h4 id="在客户端即可篡改请求"><a href="#在客户端即可篡改请求" class="headerlink" title="在客户端即可篡改请求"></a>在客户端即可篡改请求</h4><p>在HTTP请求的报文内加载攻击代码就能发起对web应用的攻击。</p><h4 id="针对Web应用攻击模式"><a href="#针对Web应用攻击模式" class="headerlink" title="针对Web应用攻击模式"></a>针对Web应用攻击模式</h4><p>1、主动攻击</p><p>以服务器为目标的主动攻击</p><p>2、被动攻击</p><p>以服务器为目标的被动攻击，指利用圈套策略执行攻击代码的攻击模式，攻击者不直接对目标Web应用访问发起攻击。</p><h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><p>1、客户端验证</p><p>2、Web应用端的验证</p><h4 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h4><p>1、利用虚假输入表单骗取用户个人信息</p><p>2、利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</p><p>3、显示伪造的文章或图片</p><h4 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h4><p>web应用都会用到数据库，当需要对数据库表内数据进行操作时，会使用SQL语句连接数据库继续进行特定的操作，如果嗲用SQL语句方式上存在疏漏，就有可能执行恶意注入的非法SQL语句</p><p>1、非法查看或篡改数据库内数据</p><p>2、规避认证</p><p>3、执行和数据库服务器业务关联的程序等</p><h4 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h4><p>执行非法操作系统命令达到攻击的目的</p><h4 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h4><p>属于被动攻击模式，通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。</p><p>1、设置任何Cookie信息</p><p>2、重定向至任意URL</p><p>3、显示任意的主体</p><h4 id="邮件首部注入攻击"><a href="#邮件首部注入攻击" class="headerlink" title="邮件首部注入攻击"></a>邮件首部注入攻击</h4><p>通过邮件首部内任意添加非法内容引起的攻击</p><h4 id="目录遍历攻击"><a href="#目录遍历攻击" class="headerlink" title="目录遍历攻击"></a>目录遍历攻击</h4><p>对无意公开文件目录通过截断其目录路径后达成访问目的的一种攻击。</p><h4 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h4><p>部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。</p><h3 id="因设置缺陷引发安全漏洞"><a href="#因设置缺陷引发安全漏洞" class="headerlink" title="因设置缺陷引发安全漏洞"></a>因设置缺陷引发安全漏洞</h3><p>1、强制浏览</p><p>2、不正确错误消息处理</p><p>3、开放重定向</p><h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><p>1、会话劫持（拿到用户ID并进行伪装）</p><p>2、会话固定攻击</p><p>3、跨站点请求伪造（CSRF攻击）通过设置好的陷阱强制对已完成的用户进行非预期的个人信息或设定信息等某些状态更新属于被动攻击4</p><h3 id="其他安全漏洞"><a href="#其他安全漏洞" class="headerlink" title="其他安全漏洞"></a>其他安全漏洞</h3><p>1、密码破解</p><p>2、点击劫持</p><p>3、Dos攻击（让运行中的服务呈停止状态的攻击，如集中利用访问请求造成资源过载或者攻击安全漏洞）</p><p>4、后门程序（开发设置的隐藏入口，可不按正常步骤使用受限功能）</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
