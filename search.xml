<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker学习笔记</title>
      <link href="/2021/09/10/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/10/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>centos7安装docker</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh get-docker.sh   </span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version </span><br></pre></td></tr></table></figure><p>检查版本是否安装成功</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker </span><br></pre></td></tr></table></figure><p>开启docker服务端</p><h3 id="创建容器镜像"><a href="#创建容器镜像" class="headerlink" title="创建容器镜像"></a>创建容器镜像</h3><p>容器相当于镜像，镜像是只读的，容器是可读写的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run ubuntu</span><br></pre></td></tr></table></figure><p>拉取一个名为ubuntu的镜像，注意镜像名有有要求，在dockerhub拉取的，所以名字不能乱取</p><h3 id="容器的相关命令"><a href="#容器的相关命令" class="headerlink" title="容器的相关命令"></a>容器的相关命令</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>输入命令后，就会显示出当前已经存在的容器，并且会列出对应的信息。</p><ul><li><p>CONTAINER ID : 容器对应的ID，这个是唯一的</p></li><li><p>IMAGE : 使用的镜像名称，显示不同</p></li><li><p>COMMAND : 执行的相关命令</p></li><li><p>CREATED: 创建的时间</p></li><li><p>STATUS: 目前镜像的状态，一般会有两种状态Up和Exited.</p></li><li><p>PORTS: 协议和端口</p></li><li><p>NAMES: 容器的名称，名字是Docker随机生成的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure></li></ul><p>查看docker所有存在镜像包括停止的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop &lt;name or ID&gt;</span><br></pre></td></tr></table></figure><p>停止容器的相关命令</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm &lt;name or ID&gt;</span><br></pre></td></tr></table></figure><p>删除容器相关的命令</p><h3 id="多容器操作"><a href="#多容器操作" class="headerlink" title="多容器操作"></a>多容器操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ps -aq</span><br></pre></td></tr></table></figure><p>查看所有容器的命令号</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ps -qa)</span><br></pre></td></tr></table></figure><p>得到所有命令号停止</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm $(docker container ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有容器</p><p> 正在运行的容器，是不可以直接删除的，会报错。我们来做个实验。新建一个容器. 要先停止再删除或者强制删除正在运行的容器</p><h3 id="端口映射以及主动模式和被动模式"><a href="#端口映射以及主动模式和被动模式" class="headerlink" title="端口映射以及主动模式和被动模式"></a>端口映射以及主动模式和被动模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 80:80 nginx</span><br></pre></td></tr></table></figure><p> 确定docker对应的容器端口是多少。比如Nginx镜像的端口诗<code>80</code>。知道这个端口后，就可以在启动容器的时候，用<code>-p </code> 的形式，启用映射了。 </p><p> 等待项目启动后，打开浏览器窗口，在地址栏输入<code>127.0.0.1</code>，就可以打开nginx的默认网址 </p><h4 id="主动模式attach模式"><a href="#主动模式attach模式" class="headerlink" title="主动模式attach模式"></a>主动模式attach模式</h4><p> 当打开<code>127.0.0.1</code>网址的时候，终端上打印出了相关的日志（log），平且每访问一次，都会增加一条日志。也就是说Docker容器的日志会实时的展现到窗口并且占用此端口。这种模式叫做attached模式。 </p><h4 id="detach模式"><a href="#detach模式" class="headerlink" title="detach模式"></a>detach模式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">90</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>这次你会看到，和<code>attached</code>模式不同的是，这次输入完命令后，只显示出了容器的编号，并且可以再输入任何命令。就算我们关掉窗口，容器依然运行，也就是他是在系统后台进行运行的。</p><p>这种就比较适合在生产环境中运行，停掉和删除容器都需要使用<code>Shell脚本</code>的形式。减少了很多误操作。</p><p>输入127.0.01:90就可以通过90端口访问</p><h4 id="detach模式转为attach模式"><a href="#detach模式转为attach模式" class="headerlink" title="detach模式转为attach模式"></a>detach模式转为attach模式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  attach &lt;ID or Image Name&gt;</span><br></pre></td></tr></table></figure><h4 id="detach模式查看日志"><a href="#detach模式查看日志" class="headerlink" title="detach模式查看日志"></a>detach模式查看日志</h4><p>先复习一下上节课的内容，用<code>detached</code>模式开启一个<code>nginx</code>服务，并映射服务器的<code>80端口</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>容器被运行起来了，是<code>detached</code>模式，也就是Docker 的后台运行模式。这时候想要查看后台日志，可以使用下面的命令查看。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs &lt;ID or Image name&gt;</span><br></pre></td></tr></table></figure><p>虽然日志在窗口中出现了，但只打印一次<code>logs</code>,如果想动态一直跟踪日志，可以在命令上加入一个<code>-f</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs -f &lt;ID or Image name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker交互模式"><a href="#docker交互模式" class="headerlink" title="docker交互模式"></a>docker交互模式</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu sh</span><br></pre></td></tr></table></figure><p><code>-it</code>代表启用交互模式，<code>sh</code>代表可以使用Shell脚本。当你输入玩这个脚本后，Docker就会进入到交互模式。可以使用<code>ls</code>来得到目录下的文件，也可以使用<code>hostname</code>来查看计算机名称。</p><p> 这时候你想退出容器和交互模式可以输入<code>exit</code>命令。需要重点说明的是，随着命令退出后，容器也会跟着退出，变成<code>Exited</code>模式。 </p><p>如果我们想退出交互，但是并不想停止容器。可以先开启<code>detached模式</code>，然后通过命令进入交互模式。</p><p>再用<code>detached模式</code>创建一个<code>nginx镜像</code>的容器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>直接通过下面的命令就可以进入到交互模式下了。（重要）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;ID or Image name&gt; sh </span><br></pre></td></tr></table></figure><p><code>exec</code>是执行的意思，<code>-it</code>交互模式 ， <code>sh</code>交互的方式，用shell脚本进行交互</p><h3 id="镜像获取拉取删除"><a href="#镜像获取拉取删除" class="headerlink" title="镜像获取拉取删除"></a>镜像获取拉取删除</h3><h4 id="镜像的获取"><a href="#镜像的获取" class="headerlink" title="镜像的获取"></a>镜像的获取</h4><ul><li><p>从网络社区直接拉取，在Docker里这种社区叫做<code>Registry</code>(登记处)（pull from registry）</p></li><li><p>从Dockerfile构建一个镜像，这是DIY一个镜像，同时整个构建过程是需要联网，因为需要西在基础镜像，然后根据基础镜像进行构建（build from Dockerfile）。</p></li><li><p>自有文件的导入，可以从本地导入已经构建好的镜像文件，在没有网络的时候可以用。这个文件是通过已有的镜像导出来的压缩包，然后就可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image</span><br></pre></td></tr></table></figure><p> 对于Image操作的所有命令和提示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull wordpress</span><br></pre></td></tr></table></figure></li></ul><p>拉取wordpress镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>查看镜像列表的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull wordpress:cli-php8.0</span><br></pre></td></tr></table></figure><p>下载对应版本的镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect baf</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm &lt;Image ID&gt;</span><br></pre></td></tr></table></figure><h4 id="镜像导入导出"><a href="#镜像导入导出" class="headerlink" title="镜像导入导出"></a>镜像导入导出</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image save busybox:latest -o mybusybox.image</span><br></pre></td></tr></table></figure><p><code>save</code>是导出/保存的意思，<code>busybox:latest</code>是镜像名称+版本号， <code>-o</code>代表输出，<code>mybusybox.image</code>是导出后镜像的名字。</p><p>导入镜像步骤</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm busybox</span><br></pre></td></tr></table></figure><p>删除后直接导入镜像。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image load -i .\mybusybox.image</span><br></pre></td></tr></table></figure><h3 id="dockfile"><a href="#dockfile" class="headerlink" title="dockfile"></a>dockfile</h3><p> Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。 </p><ul><li><p>Dockerfile是用于构建docker镜像的文件</p></li><li><p>Dockerfile里包含了构建镜像所需的”指令“</p></li><li><p>Dockerfile有其特定的语法规则</p><h4 id="dockerfile-文件编写"><a href="#dockerfile-文件编写" class="headerlink" title="dockerfile 文件编写"></a>dockerfile 文件编写</h4><p>首先装一个Ubuntu系统。</p><p>第二步，下载安装Python环境</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3<span class="number">.9</span> python3-pip python3<span class="number">.9</span>-dev</span><br></pre></td></tr></table></figure><p>第三步，准备<code>jspang.py</code>文件。这个可以在<code>D盘</code>新建一个<code>DockerTest文件夹</code>，然后在文件夹中新建一个<code>jspang.py</code>文件，然后编写下面的文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello JSPang&quot;</span>)</span><br></pre></td></tr></table></figure><p>第四步，运行jspang.py</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 hello.py</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>编写Dockerfile文件（建议把Dockerfile文件和jspang.py文件放在一起个文件夹下）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN  apt-get update &amp;&amp; \</span><br><span class="line">         DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3<span class="number">.9</span> python3-pip python3<span class="number">.9</span>-dev</span><br><span class="line">ADD jspang.py /</span><br><span class="line">CMD [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;jspang.py&quot;</span>]</span><br></pre></td></tr></table></figure></li></ul><p>有了<code>Dockerfile</code>和<code>jspang.py</code>文件以后，通过<code>PowerShell</code>进入到两个文件的文件夹。通过Docker命令就可以完成构建。</p><h4 id="通过dockerfile构建镜像"><a href="#通过dockerfile构建镜像" class="headerlink" title="通过dockerfile构建镜像"></a>通过dockerfile构建镜像</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t &lt;Name:tag&gt; <span class="xml"><span class="tag">&lt;<span class="name">file</span> <span class="attr">path</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过已经写好的Dockerfile，构建一个<code>jspang</code>的镜像，可以使用下面的命令构建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t jspang .</span><br></pre></td></tr></table></figure><p>（注意命令最后是有一个<code>.</code>的），如果是第一次执行打包，这个过程还比较久的，当出现FINISHED后，说明打包完成了。</p><p>打包完成后，可以通过<code>docker image ls</code>命令来查看现在拥有的镜像列表。如果一切正常，可以看到名字为<code>jspang</code>的镜像已经存在了。</p><p>可以执行容器，验证一下自己DIY的镜像是否可用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run jspang</span><br></pre></td></tr></table></figure><p>镜像如果正常，应该正确现实出<code>Hello JSPang</code>字样，然后就直接退出容器了。这是跟我们写的Dockerfile有关的。</p><p>，就是重新<code>build</code>一个镜像，。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t jspangcom/jspang .</span><br></pre></td></tr></table></figure><p>也可以通过<code>docker image tag</code>命令，具体语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag &lt;old image name &gt; <span class="xml"><span class="tag">&lt;<span class="name">new</span> <span class="attr">iamge</span> <span class="attr">name</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>例如把<code>jspang</code>这个镜像，改为<code>jspangcom/jspang</code>镜像,命令可以如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag jspang jspangcom/jspang</span><br></pre></td></tr></table></figure><h4 id="推送到dockerhub"><a href="#推送到dockerhub" class="headerlink" title="推送到dockerhub"></a>推送到dockerhub</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>执行命令好，会要求输入<code>Username</code>，也就你<code>Dockerhub ID</code>，还需要输入密码。如果输入正确，并出现<code>Login Succeeded</code>就证明登录成功了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push Name[:TAG]</span><br></pre></td></tr></table></figure><p>比如就是把刚才的<code>jspangcom/jspang</code>镜像push到社区，就可以使用下面的命令。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push jspangcom/jspang</span><br></pre></td></tr></table></figure><h3 id="dockerfile编写指南"><a href="#dockerfile编写指南" class="headerlink" title="dockerfile编写指南"></a>dockerfile编写指南</h3><h4 id="from语法"><a href="#from语法" class="headerlink" title="from语法"></a>from语法</h4><p>第一句就是<code>FROM ubuntu:latest</code> , 它的意思是选择一个基础镜</p><p>几乎所有的Dockerfile文件，要做的第一件事就是要选择一个基础镜像。<code>FROM ubuntu:latest</code>并不是一个最优写法。</p><p>选择镜像3个原则</p><ol><li><p>官方镜像优于非官方的镜像；</p></li><li><p>固定版本的版本（tag），而不是每次都使用latest;</p></li><li><p>功能满足，选择体积小的镜像；镜像体积大则他人越不会使用</p><h4 id="run语法正确形式"><a href="#run语法正确形式" class="headerlink" title="run语法正确形式"></a>run语法正确形式</h4><p>分层越多维护越难</p><p>把所有执行命令放到一个RUN里，并用<code>&amp;&amp; \</code>进行连接。就可以把很多命令写到一个RUN里边了。</p><p>以下是安装ipinfo的linux操作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y wget &amp;&amp; \</span><br><span class="line">    wget https:<span class="comment">//github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \</span></span><br><span class="line">    tar zxf ipinfo_2<span class="number">.0</span>.1_linux_amd64.tar.gz &amp;&amp; \</span><br><span class="line">    mv ipinfo_2<span class="number">.0</span>.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; \</span><br><span class="line">    rm -rf ipinfo_2<span class="number">.0</span>.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure></li></ol><p>这样所有的RUN命令只生成一层<code>image layer</code>。打包出来的镜像也没有那么大了。这个文件写到<code>Dockerfile.good</code>文件里，然后用命令进行打包。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -f dockerfile.good -t ipinfo-good .</span><br></pre></td></tr></table></figure><p> 这时候再用<code>docker image histroy </code> 查看分层，就会看到分层少了很多。 不要每一行都写一个run命令</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell学习笔记</title>
      <link href="/2021/09/10/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/10/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><p>shell是一个命令 解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动挂起甚至编写一些程序</p><h4 id="脚本格式要求"><a href="#脚本格式要求" class="headerlink" title="脚本格式要求"></a>脚本格式要求</h4><p>#！/bin/bash开头，脚本需要有可执行权限</p><p>shell脚本后缀以sh结尾</p><p>如#！/bin/bash echo”hello world”</p><p>然后加入执行权限chmod u+x   hello.sh</p><p>脚本常用的执行权限</p><h4 id="脚本的执行方式"><a href="#脚本的执行方式" class="headerlink" title="脚本的执行方式"></a>脚本的执行方式</h4><p>1、sh+脚本（有无执行权限都可以） sh hello.sh(亦可以使用绝对路径)</p><p>2、绝对路径或者相对路径（有执行权限）</p><h3 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h3><p>系统变量  如$home、$PWD、$SHELL</p><p>显示当前shell所有变量 set</p><p>shell变量的定义</p><p>定义变量 变量名=值    </p><p>撤销变量  unset 变量</p><p>设置静态变量 readonly 变量 ,如果声明了静态变量则不可以unset</p><p>输出变量需要&amp;  echo &amp;A</p><p>变量等号两侧不可以有空格，变量名称一般习惯为大写</p><p>A=‘date’   运行里面的命令并将结果返回A，如果不加反引号则代表把date这个字符串赋值给A</p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>export 变量名=变量值 （将shell变量输出为环境变量/全局变量）</p><p>source  配置文件（将修改后的配置信息立即生效）</p><p>echo $变量名 查询环境变量的值，再输出环境变量是要source让配置文件生效</p><p>多行注释   开头!&lt;&lt;!   结尾！</p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用位置参数变量</p><p>$n  n为数字 10以上的参数需要大括号包含如 ${10}</p><p>$*把所有参数看成一个整体</p><p>$@代表命令行的所有参数，不过$@把每个参数区分对待</p><p>$#这个变量代表命令行中所有参数的个数</p><p>echo “0=$0 1=$1”</p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>$$当前进程进程号</p><p>$！后台运行最后一个进程进程号</p><p>$？最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，反之相反</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>$((运算式))或者$[运算式] 或者expr m+n，如果用expr要 *</p><p>注意exxpr运算符要有空格</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>[condition],注意condition前后要有空格,即使为空也要空格  0为true ,&gt;1为false</p><p>两个整数比较 -lt,-le,-eq,-gt,-ge  字符串比较=</p><p>文件类型判断 -f,-e</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;ok&quot;</span> = <span class="string">&quot;ok&quot;</span> ] </span><br><span class="line"></span><br><span class="line">then </span><br><span class="line"></span><br><span class="line">​echo <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">fi（代表语句结束）</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f  /root/shode/aaa.txt ]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​echo <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">fi（代表语句结束)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [条件判断式]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​代码</span><br><span class="line"></span><br><span class="line">elif(条件判断式)</span><br><span class="line"></span><br><span class="line">​代码</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case 语句  $变量名 in</span><br><span class="line"></span><br><span class="line">“值1”）</span><br><span class="line"></span><br><span class="line">如果变量等于1，则执行</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">&quot;值2&quot;)</span><br><span class="line"></span><br><span class="line">如果变量等于2，则执行</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot;  $*被当作一个整体只会输出一句话</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in &quot;$@&quot;  $@被当分别对待有几个参数则输出几句</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for ((初始值;循环控制条件;变量变化))</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [条件判断式]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="read读取控制"><a href="#read读取控制" class="headerlink" title="read读取控制"></a>read读取控制</h3><p>read(选项)(参数)</p><p>选项-p 指定读取值时的提示符,-t指定读取值时的等待时间，如果没有在指定时间内输入则不再等待</p><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p>basename 返回完整路径 /的部分，常用于获取文件名</p><p>basename [pathname] [suffix]</p><p>如 basename home/bin/aa.txt,返回aaa.txt</p><p>basename home/bin/aa.txt.txt 返回aaa</p><p>dirname  返回完整路径/前面的部分，常用于获取路径名</p><p>dirname /home/aaa/bbb/aa.txt  返回/home/aaa/bbb</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>[ function ] funname [()]</p><p>{</p><p>​    Action</p><p>​    [return int;]</p><p>}</p><p>调用直接写函数名  funname [值]</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getsum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum=$[$n1+$n2]</span><br><span class="line">echo <span class="string">&quot;$sum&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">调用自定义函数</span><br><span class="line">getsum $n1 $n2</span><br><span class="line">输入两个值</span><br><span class="line">read -p <span class="string">&quot;输入n1=&quot;</span> n1</span><br><span class="line">read -p <span class="string">&quot;输入n2=&quot;</span> n2</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>日志文件是重要系统信息文件，记录许多重要的系统事件，同时日志对于安全来说可以通过日志来检查错误发生的原因或者收到攻击时攻击者留下的痕迹，是一种用来记录重大事件的工具</p><p>绝大部分的日志文件所在目录：/var/log</p><p>系统启动日志/var/log/boot.log</p><p>/var/log/cron，系统定时任务的相关日志</p><p>/var/log/lastlog 直接用指令lastlog查看，记录用户最后一次登录时间的日志，这个文件也是二进制文件</p><p>/var/log/maillog 记录邮件信息的日志</p><p>/var/log/message 记录重要信息的日志</p><p>/var/log/secure 记录验证和授权方面的信息，只要涉及账户密码都会记录</p><p>/var/tun/lump记录当前登录用户的信息，这个文件会随着用户的登录和注销而不断发生变化  要用who 、users等命令查看</p><h4 id="日志服务管理"><a href="#日志服务管理" class="headerlink" title="日志服务管理"></a>日志服务管理</h4><p>centos7.6日志服务是：rsylogd（后台程序服务管理日志）/etc/rsyslog.conf配置文件控制该服务</p><p> 查询linux中的rsyslogd服务是否启动：ps aux| grep “rsylogd” |grep -v “grep”</p><p>日志文件包含以下四种内容</p><p>1、事件产生的事件 2 、产生事件的服务器的主机名 3、产生事件的服务名或程序名  4、事件的具体信息</p><p>也可以增加自己的日志文件</p><h4 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h4><p>把旧的日志文件移动并改名，同时建立新的空的日志文件，当旧日志文件超出保存范围之后就会进行删除</p><p>/etc/logrotate/conf全局日志论题规则，可以单独给某个日志文件指定策略</p><p>如果没有dateext参数（用日期作为文件后缀）当进行一次日志论题，当前的日志会自动改名，然后新建日志用来保存新的日志</p><p>![日志轮替](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1629524576241.png)</p><p>把自己日志加入日志轮替</p><p>第一种是直接再logrotate.conf配置文件写入该日志的轮替策略</p><p>第二种是在/var/logrotate.d/目录种建立该日志的轮替文件，再该轮替文件中写入正确的轮替策略，因为该目录的文件都会被 “include”到主配置文件中，所以也可以把日志加u轮替（同时可读性和管理也比较好）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">添加自定义轮替规则</span><br><span class="line">/var/log/hsp.log</span><br><span class="line">&#123;</span><br><span class="line">missingok</span><br><span class="line">daily</span><br><span class="line">copytruncate</span><br><span class="line">rotate 7</span><br><span class="line">notifempty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志轮替机制"><a href="#日志轮替机制" class="headerlink" title="日志轮替机制"></a>日志轮替机制</h4><p>依赖系统的定时任务在/etc/cron.daily/目录，就会发现这个目录使用logrotate文件（可执行），logrotate通过这个文件依赖定时任务执行</p><h4 id="内存日志"><a href="#内存日志" class="headerlink" title="内存日志"></a>内存日志</h4><p>内存日志一旦重启就会清空</p><p>journalctl  可以查看内存日志   </p><p>journalctl -n 3 查看最新3条  journalctl -p err 报错日志</p><p>journalctl -since 19:00  –until 19:10:10 查看起始时间到结束时间</p><p>journalctl -o verbose日志详细内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2021/09/10/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/10/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1、了解sql"><a href="#1、了解sql" class="headerlink" title="1、了解sql"></a>1、了解sql</h2><h3 id="1、什么数据库"><a href="#1、什么数据库" class="headerlink" title="1、什么数据库"></a>1、什么数据库</h3><p>数据库应称为数据库管理系统DBMS，数据库是通过DBMS创建和操纵的，访问的是DBMS，保存数据的容器</p><p>表：某种特定类型的结构化清单</p><p>模式：关于数据库和表的布局以及特性的信息</p><p>列：表由列组成，存储表中某部分的信息</p><p>数据类型：所容许的数据类型</p><p>行：表中的数据是按行存储的，所保存的每个记录存储在自己的行内</p><p>主键，一行或一组列，能够唯一标识表中的每个行，主键不是必须的的，可以一起使用多个列作为主键</p><p>只要以下条件：</p><p>1、任意两行都不具有相同的逐渐值</p><p>2、每个行都必须有一个主键值，不允许为NULL值</p><p>3、主键列中的值不允许修改或更新</p><p>4、主键值不能重用，如果某行从表中删除，它的主键不能赋给以后的新行</p><h3 id="2、什么是SQL"><a href="#2、什么是SQL" class="headerlink" title="2、什么是SQL"></a>2、什么是SQL</h3><p>SQL-结构化查询语言</p><p>优点：1、几乎所有DBMS都支持SQL</p><p>2、简单易学</p><p>3、灵活使用能进行复杂和高级数据库操作</p><h3 id="3、什么是MYSQL"><a href="#3、什么是MYSQL" class="headerlink" title="3、什么是MYSQL"></a>3、什么是MYSQL</h3><h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><p>1、成本</p><p>2、性能</p><p>3、可信赖</p><p>4、简单</p><h4 id="2、MySQL版本"><a href="#2、MySQL版本" class="headerlink" title="2、MySQL版本"></a>2、MySQL版本</h4><p>4-InnoDB引擎，增加事务处理，改进全文文本搜索</p><p>4.1-对函数库、子查询、集成帮助重要增加</p><p>5-存储过程、触发器、游标、视图</p><h2 id="2、检索数据"><a href="#2、检索数据" class="headerlink" title="2、检索数据"></a>2、检索数据</h2><h3 id="1、SELECT语句"><a href="#1、SELECT语句" class="headerlink" title="1、SELECT语句"></a>1、SELECT语句</h3><h4 id="1、检索单个列："><a href="#1、检索单个列：" class="headerlink" title="1、检索单个列："></a>1、检索单个列：</h4><p>SELECT prod_name</p><p>FROM Products；</p><p>从product表中检索一个prod_name的列</p><p>注意事项：1、处理SQL语句时，所有空格都被忽略</p><p>2、结束SQL语句，其中多条SQL语句必须以分号，多数DBMS不需要再单条SQL语句后加上分号，但是加上分号肯定没有坏处</p><h4 id="2、检索多个列"><a href="#2、检索多个列" class="headerlink" title="2、检索多个列"></a>2、检索多个列</h4><p>SELECT prod_name，prod_price</p><p>FROM Products；</p><h4 id="3、检索所有列"><a href="#3、检索所有列" class="headerlink" title="3、检索所有列"></a>3、检索所有列</h4><p>SELECT *</p><p>FROM Products；</p><h4 id="4、检索不同行"><a href="#4、检索不同行" class="headerlink" title="4、检索不同行"></a>4、检索不同行</h4><p>SELECT DISTINCTT prod_id</p><p>FROM Products</p><h4 id="5、限制结果"><a href="#5、限制结果" class="headerlink" title="5、限制结果"></a>5、限制结果</h4><p>SELECT prod_id</p><p>FROM Products</p><p>LIMIT 5；</p><p>返回不多于5行</p><p>（LIMIT 4  OFFSET 3）从行3开始取4行</p><h4 id="6、使用完全限定的表名"><a href="#6、使用完全限定的表名" class="headerlink" title="6、使用完全限定的表名"></a>6、使用完全限定的表名</h4><p>SELECT products.prod_id</p><p>FROM crashcourse.products</p><p>假定products表确实位于crashcourse数据库中</p><h2 id="3、排序检索数据"><a href="#3、排序检索数据" class="headerlink" title="3、排序检索数据"></a>3、排序检索数据</h2><p>子句：SQL语句由子句构成，有的必须有的可选</p><h3 id="1、order-by子句"><a href="#1、order-by子句" class="headerlink" title="1、order by子句"></a>1、order by子句</h3><h4 id="1、以字母顺序排序"><a href="#1、以字母顺序排序" class="headerlink" title="1、以字母顺序排序"></a>1、以字母顺序排序</h4><p>SELECT prod_name</p><p>FROM Products</p><p>ORDER BY prod_name；</p><h4 id="2、按多个列排序"><a href="#2、按多个列排序" class="headerlink" title="2、按多个列排序"></a>2、按多个列排序</h4><p>SELECT prod_name，prod_price</p><p>FROM Products</p><p>ORDER BY prod_name， prod_price；</p><h4 id="3、按列位置排序"><a href="#3、按列位置排序" class="headerlink" title="3、按列位置排序"></a>3、按列位置排序</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>ORDER BY 2，3；</p><p>先按SELECT清单中的第二个列，再按第三列排序，也就是先prod_name,再按prod_price排序，如果不在清单则不能使用这种排序</p><h4 id="4、指定排序方向"><a href="#4、指定排序方向" class="headerlink" title="4、指定排序方向"></a>4、指定排序方向</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>ORDER BY  prod_price DESC，prod_name；</p><p>以降序排列产品价格,如果是升序为ASC，但是升序是默认的</p><p>注意区分大小写用order by子句做不到</p><h2 id="4、过滤数据"><a href="#4、过滤数据" class="headerlink" title="4、过滤数据"></a>4、过滤数据</h2><h3 id="1、使用where子句"><a href="#1、使用where子句" class="headerlink" title="1、使用where子句"></a>1、使用where子句</h3><h4 id="1、使用where子句过滤"><a href="#1、使用where子句过滤" class="headerlink" title="1、使用where子句过滤"></a>1、使用where子句过滤</h4><p>如果只需要特定数据需要指定搜索条件，搜索条件也成为过滤条件</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price  = 3.49；</p><p>在同时使用ORDER BY 和 WHERE子句是，应该让 order by 位于 where  之后否则会产生错误</p><h3 id="2、where子句操作符"><a href="#2、where子句操作符" class="headerlink" title="2、where子句操作符"></a>2、where子句操作符</h3><h4 id="1、检查单个值"><a href="#1、检查单个值" class="headerlink" title="1、检查单个值"></a>1、检查单个值</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt; 10；</p><h4 id="2、不匹配检查"><a href="#2、不匹配检查" class="headerlink" title="2、不匹配检查"></a>2、不匹配检查</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt; &gt; 10；</p><p>过略下列价格不是10的</p><p><strong>！= 和&lt;&gt;通常可以互换使用，但并不是所有DBMS都支持这两种不等于操作符，如Microsoft Access</strong></p><h4 id="3、范围值检查"><a href="#3、范围值检查" class="headerlink" title="3、范围值检查"></a>3、范围值检查</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_price  BETWEEM 5 AND 10；</p><p>使用between时必须指定两个值，所需范围的低端和高端值</p><h4 id="4、空值检查"><a href="#4、空值检查" class="headerlink" title="4、空值检查"></a>4、空值检查</h4><p>SELECT prod_name</p><p>FROM Products</p><p>WHERE prod_price  IS NULL；</p><p>返回没有价格的所有产品</p><h2 id="5、组合使用where子句"><a href="#5、组合使用where子句" class="headerlink" title="5、组合使用where子句"></a>5、组合使用where子句</h2><p>操作符：用来连结或改变where子句中的关键字也成为逻辑操作符</p><h3 id="1、操作符"><a href="#1、操作符" class="headerlink" title="1、操作符"></a>1、操作符</h3><h4 id="1、AND操作符"><a href="#1、AND操作符" class="headerlink" title="1、AND操作符"></a>1、AND操作符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE vend_id = ‘DLL01’ AND prod_price &lt;=4；</p><h4 id="2、OR操作符"><a href="#2、OR操作符" class="headerlink" title="2、OR操作符"></a>2、OR操作符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE vend_id = ‘DLL01’ OR vend_id = ‘BRS01’；</p><h4 id="3、计算次序"><a href="#3、计算次序" class="headerlink" title="3、计算次序"></a>3、计算次序</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE (vend_id = ‘DLL01’ OR vend_id = ‘BRS01’)</p><p>AND prod_price &gt;=10；</p><p><strong>and在计算次序中优先级更高，操作符容易被错误使用，因此可以用圆括号组合</strong></p><h3 id="2、IN操作符"><a href="#2、IN操作符" class="headerlink" title="2、IN操作符"></a>2、IN操作符</h3><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE vend_id IN  (‘DLL01’ ,’BRS01’)；</p><p>IN用来指定范围条件，范围中的每个条件都可以匹配，IN操作符完成与OR相同的功能，</p><p>但是使用In操作符优点</p><p>1、长的合法选项清单，IN操作符的语法更加清楚且更直观</p><p>2、使用IN，计算的次序更加容易管理</p><p>3、In操作符一般比OR执行更快</p><p>4、IN可以包含其他SELECT语句</p><h3 id="3、NOT操作符"><a href="#3、NOT操作符" class="headerlink" title="3、NOT操作符"></a>3、NOT操作符</h3><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE NOT vend_id = ‘DLL01’ ；</p><p>匹配DLL01之外其他所有东西，该例子也可以使用&lt;&gt;操作符完成</p><p>NOT的好处与IN联合使用时，找出与条件列表不匹配的行非常简单</p><h2 id="6、用通配符进行过滤"><a href="#6、用通配符进行过滤" class="headerlink" title="6、用通配符进行过滤"></a>6、用通配符进行过滤</h2><h3 id="1、LIKE操作符"><a href="#1、LIKE操作符" class="headerlink" title="1、LIKE操作符"></a>1、LIKE操作符</h3><p>通配符：用来匹配值的一部分的特殊字符</p><p>搜索模式：由字面值、通配符或两者组合构成的搜索条件</p><p><strong>通配符只能用于文本字段，非文本数据类型字段不能使用通配符</strong></p><h4 id="1、百分号-通配符"><a href="#1、百分号-通配符" class="headerlink" title="1、百分号%通配符"></a>1、百分号%通配符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘Fish%’；</p><p>将搜索任意以Fish起头的词，告诉DBMS接受Fish之后任意字符</p><p>如果使用Microsoft Access,则需要*而不是%</p><p><strong>这是区分大小写</strong></p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘%bean bag%’；</p><p>匹配任何位置包含文本 bean bag的值，无论在它之前或之后出现什么字符</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘F%y%’；</p><p>找到F起头以y结尾的所有产品，但是如果产品名称最后为空格则无法识别</p><h4 id="2、下划线（-）通配符"><a href="#2、下划线（-）通配符" class="headerlink" title="2、下划线（_）通配符"></a>2、下划线（_）通配符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name LIKE ‘_ inch teddy bear’；</p><p>（_）总是匹配一个字符，不能多也不能少</p><h4 id="3、方括号-通配符"><a href="#3、方括号-通配符" class="headerlink" title="3、方括号([]) 通配符"></a>3、方括号([]) 通配符</h4><p>方括号通配符用来指定一个字符集，必须匹配指定位置</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name  LIKE ‘[JM]%’</p><p>ORDER BY prod_name;</p><p>找出名字以J或M开头产品</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name  LIKE ‘[ ^JM ]%’</p><p>ORDER BY prod_name;</p><p>不以JM开头的的产品</p><p>并不是所有DBMS支持[] 通配符</p><h3 id="2、使用通配符的技巧"><a href="#2、使用通配符的技巧" class="headerlink" title="2、使用通配符的技巧"></a>2、使用通配符的技巧</h3><p>1、注意通配符位置</p><p>2、不要过分使用</p><p>3、除非绝对必要不要它们用在搜索模式开始出，否则搜索起来最慢</p><h2 id="7、使用MySQL正则表达式"><a href="#7、使用MySQL正则表达式" class="headerlink" title="7、使用MySQL正则表达式"></a>7、使用MySQL正则表达式</h2><h4 id="1、基本字符匹配"><a href="#1、基本字符匹配" class="headerlink" title="1、基本字符匹配"></a>1、基本字符匹配</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘1000’</p><p>ORDER BY prod_name</p><p>REGEXP后所跟为正则表达式</p><p><strong>LIKE匹配整个列，如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回，除非使用通配符，而REGEXP在列值内进行匹配，如果在列值中出现，相应的行会被返回，正则表达式匹配不区分大小写</strong></p><h4 id="2、进行OR匹配"><a href="#2、进行OR匹配" class="headerlink" title="2、进行OR匹配"></a>2、进行OR匹配</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘1000|2000’</p><p>ORDER BY prod_name</p><h4 id="3、匹配几个字符之一"><a href="#3、匹配几个字符之一" class="headerlink" title="3、匹配几个字符之一"></a>3、匹配几个字符之一</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘[123] Ton’</p><p>ORDER BY prod_name</p><p>这个与下面不同</p><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘1|2|3 Ton’</p><p>ORDER BY prod_name</p><p>1，2，3如果不在集合中将会应用于整个串</p><h4 id="4、匹配范围"><a href="#4、匹配范围" class="headerlink" title="4、匹配范围"></a>4、匹配范围</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘[1-5] Ton’</p><p>ORDER BY prod_name</p><p><strong>[a-z]匹配任意字母字符</strong></p><h4 id="5、匹配特殊字符"><a href="#5、匹配特殊字符" class="headerlink" title="5、匹配特殊字符"></a>5、匹配特殊字符</h4><p>SELECT prod_id，prod_name，prod_price</p><p>FROM Products</p><p>WHERE prod_name REGEXP ‘\\ .’</p><p>ORDER BY prod_name</p><p>匹配特殊字符必须\ \为前导，上面就是查找.</p><h4 id="6、匹配字符类"><a href="#6、匹配字符类" class="headerlink" title="6、匹配字符类"></a>6、匹配字符类</h4><p>![1630982988666](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1630982988666.png)</p><h4 id="7、匹配多个实例"><a href="#7、匹配多个实例" class="headerlink" title="7、匹配多个实例"></a>7、匹配多个实例</h4><h4 id="8、匹配定位"><a href="#8、匹配定位" class="headerlink" title="8、匹配定位"></a>8、匹配定位</h4><h2 id="8、创建计算字段"><a href="#8、创建计算字段" class="headerlink" title="8、创建计算字段"></a>8、创建计算字段</h2><p>字段：与列的意思相同</p><h3 id="1、拼接字段"><a href="#1、拼接字段" class="headerlink" title="1、拼接字段"></a>1、拼接字段</h3><p>拼接字段：将值联结到一起构成单个值</p><p>SELECT vend_name + ‘ (‘ + vend_country +’)’</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>也可以将+ 换成||连接元素 （sql的拼接）</p><p>SELECT Concar(vend_name + ‘ (‘ + vend_country +’)’)</p><p>FROM Vendors</p><p>ORDER BY vend_name;(mysql的拼接)</p><p>四个元素</p><p>1、vend_name</p><p>2、包含一个空格和一个左圆括号</p><p>3、存储在vend_country的国家</p><p>4、包含一个右圆括号</p><p>RTrim删除右边多余的空格 Trim去掉左右两边的空格,LTrim去掉左边空格</p><h3 id="2、使用别名"><a href="#2、使用别名" class="headerlink" title="2、使用别名"></a>2、使用别名</h3><p>SELECT RTRIM（vend_name） + ‘ (‘ + RTRIM(vend_country) +’)’ AS vend_title</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>显示的名为vend_title的两者拼接字符串</p><h3 id="3、执行算数计算"><a href="#3、执行算数计算" class="headerlink" title="3、执行算数计算"></a>3、执行算数计算</h3><p>SELECT prod_id,quantity,item_price</p><p>quantity*item_price AS expanded_price</p><p>FROM OrderItems</p><p>WHERE order_num =20008;</p><h2 id="9、使用数据处理函数"><a href="#9、使用数据处理函数" class="headerlink" title="9、使用数据处理函数"></a>9、使用数据处理函数</h2><h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h3><p>只有少数几个函数被所有DBMS支持</p><h3 id="2、使用函数"><a href="#2、使用函数" class="headerlink" title="2、使用函数"></a>2、使用函数</h3><h4 id="1、文本处理函数"><a href="#1、文本处理函数" class="headerlink" title="1、文本处理函数"></a>1、文本处理函数</h4><p>SELECT vend_name， UPPER(vend_name) AS vend_name_upcase</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>UPPER函数将文本转换为大写</p><p> SELECT vend_name， UPPER(vend_name) AS vend_name_upcase</p><p>FROM Vendors</p><p>ORDER BY vend_name;</p><p>SELECT cust_name, cust_contact</p><p>FROM customers</p><p>WHERE Soundex(cust_contact) = Soundex(‘Y.Lie’);</p><p> SOUNDEX 会根据字符串的英文发音，将字母数字字符串转换成一个由四个字符组成的代码。  </p><h4 id="2、日期和时间处理函数"><a href="#2、日期和时间处理函数" class="headerlink" title="2、日期和时间处理函数"></a>2、日期和时间处理函数</h4><p>![1631079154634](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1631079154634.png)</p><p>SELECT cust_id, order_num</p><p>FROM orders</p><p>WHERE Date(order_date) = ‘2005-09-01’;</p><p>检索2005-9-1所用订单</p><p>SELECT cust_id, order_num</p><p>FROM orders</p><p>WHERE Date(order_date) Between ‘2005-09-01’ AND ‘2005-09-30’;</p><p>检索年份</p><p>SELECT cust_id, order_num</p><p>FROM orders</p><p>WHERE YEAR(order_date) =2005 AND Month(order_date) = 9;</p><p>检索年、月</p><h4 id="3、数值处理函数"><a href="#3、数值处理函数" class="headerlink" title="3、数值处理函数"></a>3、数值处理函数</h4><p>Abs,Cos,Exp,Mod,Pi,Rand,Sin,Sqrt,Tan</p><h2 id="10、汇总数据"><a href="#10、汇总数据" class="headerlink" title="10、汇总数据"></a>10、汇总数据</h2><p>聚集函数：运行在行组上，计算和返回单个值的函数</p><h3 id="1、聚集函数"><a href="#1、聚集函数" class="headerlink" title="1、聚集函数"></a>1、聚集函数</h3><h4 id="1、AVG函数"><a href="#1、AVG函数" class="headerlink" title="1、AVG函数"></a>1、AVG函数</h4><p>通过对表中函数计算并计算特定列值的和，求得该列的平均值</p><p>SELECT AVG(prod_price) AS avg_price</p><p>FROM products</p><p>计算特定行的值</p><p>SELECT AVG(prod_price) AS avg_price</p><p>FROM products</p><p>WHERE vend_id = 1003</p><p><strong>AVG函数忽略列值为NULL的行</strong></p><h4 id="2、COUNT函数"><a href="#2、COUNT函数" class="headerlink" title="2、COUNT函数"></a>2、COUNT函数</h4><p>COUNT函数进行计数，可利用COUNT确定表中行的数目或符合特定条件的行的数目</p><p>SELECT AVG(prod_price) AS avg_price</p><p>FROM products</p><p>WHERE vend_id = 1003</p><h4 id="3、MAX函数"><a href="#3、MAX函数" class="headerlink" title="3、MAX函数"></a>3、MAX函数</h4><p>SELECT MAX(prod_price) AS max_price</p><p>FROM products</p><p><strong>MAX函数忽略列值为NULL的行</strong></p><h4 id="4、MIN函数"><a href="#4、MIN函数" class="headerlink" title="4、MIN函数"></a>4、MIN函数</h4><p>SELECT MIN(prod_price) AS max_price</p><p>FROM products</p><h4 id="5、SUM函数"><a href="#5、SUM函数" class="headerlink" title="5、SUM函数"></a>5、SUM函数</h4><p>SUM返回指定列值的总和</p><p>SELECT SUM(prod_price) AS item_ordered</p><p>FROM products;</p><p>SUM也可以合计计算值</p><p>SELECT SUM(prod_price*quantity) AS item_ordered</p><p>FROM products;</p><h3 id="2、聚集不同值"><a href="#2、聚集不同值" class="headerlink" title="2、聚集不同值"></a>2、聚集不同值</h3><p>SELECT AVG(DISTINCT prod_price) AS avg_price</p><p>FROM products</p><p>WHERE vend_id = 1003;</p><p>使用DISTINCT后，平均值只考虑各个不同的价格</p><h3 id="3、组合聚集函数"><a href="#3、组合聚集函数" class="headerlink" title="3、组合聚集函数"></a>3、组合聚集函数</h3><p>SELECT COUNT(*) AS num_items</p><p>MIN(prod_price) AS price_min</p><p>MAX(prod_price) AS price_max</p><p>AVG(prod_price) AS price_avg</p><p>FROM products；</p><h2 id="11、分组数据"><a href="#11、分组数据" class="headerlink" title="11、分组数据"></a>11、分组数据</h2><h3 id="1、数据分组"><a href="#1、数据分组" class="headerlink" title="1、数据分组"></a>1、数据分组</h3><p>SELECT COUNT(*) AS num_prods</p><p>FROM products</p><p>WHERE vend_id = 1003;</p><h3 id="2、创建分组"><a href="#2、创建分组" class="headerlink" title="2、创建分组"></a>2、创建分组</h3><p>SELECT vend_id,COUNT(*) AS num_prods</p><p>FROM products</p><p>GROUP By vend_id;</p><p>指示MYSQL会分组数据</p><h3 id="3、过滤分组"><a href="#3、过滤分组" class="headerlink" title="3、过滤分组"></a>3、过滤分组</h3><p>SELECT vend_id,COUNT(*) AS num_prods</p><p>FROM products</p><p>WHERE prod_price &gt;=10</p><p>GROUP By vend_id</p><p>HAVING COUNT(*) &gt;=2;</p><p>HAVING过滤2或2以上的分组</p><h3 id="4、分组和排序"><a href="#4、分组和排序" class="headerlink" title="4、分组和排序"></a>4、分组和排序</h3><p>SELECT order_num, SUM(quantity*item_price) AS ordertotal</p><p>FROM orderitems</p><p>GROUP By order_num</p><p>HAVING SUM(quantity*item_price) &gt;=50</p><p>ORDER BY ordertotal;</p><p>group by子句用来按订单号分组 HAVING过略数据ORDER BY排序输出</p><h4 id="5、SELECT的子句顺序"><a href="#5、SELECT的子句顺序" class="headerlink" title="5、SELECT的子句顺序"></a>5、SELECT的子句顺序</h4><p>SELECT-FROM-WHERE-GROUP BY -HAVING -ORDER BY -LIMIT</p><h2 id="12、子查询"><a href="#12、子查询" class="headerlink" title="12、子查询"></a>12、子查询</h2><h3 id="1、子查询"><a href="#1、子查询" class="headerlink" title="1、子查询"></a>1、子查询</h3><p>子查询就是查询中嵌套查询</p><h3 id="2、利用子查询进行过略"><a href="#2、利用子查询进行过略" class="headerlink" title="2、利用子查询进行过略"></a>2、利用子查询进行过略</h3><p>SELECT cust_id</p><p>FROM orders </p><p>WHERE  order_num IN (SELECT order_num</p><p>FORM orderitems</p><p>WHERE prod_id = ‘TNT2’);</p><h3 id="3、作为计算字段使用子查询"><a href="#3、作为计算字段使用子查询" class="headerlink" title="3、作为计算字段使用子查询"></a>3、作为计算字段使用子查询</h3><p>SELECT cust_name,cust_state,</p><p> (SELECT COUNT(*)</p><p>FORM orders</p><p>WHERE orders,cust_id = customers.cust_id ) AS orders</p><p>FROM customers</p><p>ORDER BY cust_name;</p><p>相关子查询：设计外部查询的子查询</p><p><strong>注意这里的cust_id是要不同的表</strong></p><h2 id="13、联结表"><a href="#13、联结表" class="headerlink" title="13、联结表"></a>13、联结表</h2><h3 id="1、联结"><a href="#1、联结" class="headerlink" title="1、联结"></a>1、联结</h3><p>利用SQL的SELECT能执行的最重要的操作</p><h4 id="1、关系表"><a href="#1、关系表" class="headerlink" title="1、关系表"></a>1、关系表</h4><p>外键：外键为某个表中的一列，它包含另外一个表的主键值</p><p>关系数据可以有效的存储和方便的处理，因此，关系数据库的可伸缩性远比非关系数据库要好</p><p>可伸缩性：能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好</p><h4 id="2、为什么要使用联结"><a href="#2、为什么要使用联结" class="headerlink" title="2、为什么要使用联结"></a>2、为什么要使用联结</h4><p>分解数据能为多个表更加有效的存储，更方便的处理，并且具有更大的可伸缩性，但是为了SELECT语句检索数据，因此使用联结，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h3 id="2、创建联结"><a href="#2、创建联结" class="headerlink" title="2、创建联结"></a>2、创建联结</h3><h4 id="1、创建联结"><a href="#1、创建联结" class="headerlink" title="1、创建联结"></a>1、创建联结</h4><p>SELECT vend_name，prod_name, prod_price</p><p>FROM products, vendors</p><p>WHERE vendors.vend_id = products.vend_id</p><p>ORDER BY prod_name；</p><p><strong>引用的列可能出现二义性时，必须使用完全限定列名，否则MYSQL返回错误</strong></p><h4 id="2、WHERE子句的重要性"><a href="#2、WHERE子句的重要性" class="headerlink" title="2、WHERE子句的重要性"></a>2、WHERE子句的重要性</h4><p>如果在联结两个表时，没有WHERE子句，第一个表中的每个行将与第二个表中的每个行没对，而不管逻辑是否可以配在一起</p><p><strong>应该保证所有联结都有WHERE子句，否则MySQL将返回比想要数据多得多数据</strong></p><h4 id="3、内部联结"><a href="#3、内部联结" class="headerlink" title="3、内部联结"></a>3、内部联结</h4><p>SELECT vend_name，prod_name, prod_price</p><p>FROM vendors INNER JOIN products </p><p>ON vendors.vend_id = products.vend_id;</p><p>两个表之间的关系时FROM子句的组成部分，以INNER JOIN 指定，在使用这种语法时，联结条件用特定ON子句而不是WHERE子句给出，传递给ON的实际条件与传递给WHERE的相同</p><h4 id="4、联结多个表"><a href="#4、联结多个表" class="headerlink" title="4、联结多个表"></a>4、联结多个表</h4><p>SELECT vend_name，prod_name, prod_price， quantity</p><p>FROM products, vendors， orderitems</p><p>WHERE vendors.vend_id = products.vend_id</p><p>AND orderitems.prod_id =products.prod_id</p><p>AND order_num = 20005;</p><p><strong>MYSQL运行时关联指定的每个表以处理联结，这种处理非常耗费资源，因此不要联结不必要的表</strong></p><h2 id="14、创建高级联结"><a href="#14、创建高级联结" class="headerlink" title="14、创建高级联结"></a>14、创建高级联结</h2><h3 id="1、使用表别名"><a href="#1、使用表别名" class="headerlink" title="1、使用表别名"></a>1、使用表别名</h3><p>SELECT cust_name，cust_contact</p><p>FROM customers AS c, orders AS o , orderitem AS oi</p><p>WHERE c.cust_id = o. cust_id</p><p>AND oi .order_num = o.order_num</p><p>AND prod_id = ‘TNT2’;</p><h3 id="2、使用不同类型的联结"><a href="#2、使用不同类型的联结" class="headerlink" title="2、使用不同类型的联结"></a>2、使用不同类型的联结</h3><h4 id="1、自联结"><a href="#1、自联结" class="headerlink" title="1、自联结"></a>1、自联结</h4><p>利用子查询查找</p><p>SELECT prod_id,prod_name</p><p>FROM products</p><p>WHERE  vend_id = ( SELECT vend_id</p><p>FROM products </p><p>WHERE prod_id = ‘DTNTR’) ;</p><p>利用联结的相同查询</p><p>SELECT p1.prod_id .p1.prod_name</p><p>FROM products AS p1, products AS p2</p><p>WHERE p1.vend_id = p2. vend_id</p><p>AND p2.prod_id = ‘DTNTR’;</p><p><strong>用自联结通常作为外部语句用来代替从相同表中检索数据时使用的子查询语句，有时候处理联结远比处理子查询快的多</strong></p><h4 id="2、自然联结"><a href="#2、自然联结" class="headerlink" title="2、自然联结"></a>2、自然联结</h4><p>自然连接排除多次出现，使每个列只返回一次</p><p>几乎所有的内部联结都是自然联结</p><h4 id="3、外部联结"><a href="#3、外部联结" class="headerlink" title="3、外部联结"></a>3、外部联结</h4><p>SELECT customers.cust_id, order.order_num</p><p>FROM customers LEFT OUTER JOIN orders</p><p>ON customers.cust_id =order.cust_idl;</p><p>使用外部联结时，必须使用RIGHT或LEFT关键字指定包括其所有行的表， RIGHT指出的时OUTER JOIN 右边的表</p><p>*<em>MySQL不支持简化字符  * =和= <em>的使用，这两种在其他DBMS中是很流行的</em></em></p><h3 id="3、使用带聚集函数的联结"><a href="#3、使用带聚集函数的联结" class="headerlink" title="3、使用带聚集函数的联结"></a>3、使用带聚集函数的联结</h3><p>SELECT customers.cust_id, customers.cust_id</p><p>COUNT(orders.order_num) AS num_ord</p><p>FROM customers INNER JOIN orders</p><p>ON customers.cust_id =order.cust_i</p><p>GROUP BY customers.cust_id;</p><p>聚集函数用来汇总数据，如下面COUNT</p><h3 id="4、使用联结和联结条件"><a href="#4、使用联结和联结条件" class="headerlink" title="4、使用联结和联结条件"></a>4、使用联结和联结条件</h3><p>1、一般我们使用内部联结，但使用外部联结也是有效的</p><p>2、保持使用正确的联结条件，否则将返l回不正确的数据</p><p>3、应该总是提供联结条件，否则会得出笛卡尔积</p><p>4、一个联结可以包含多个表，甚至对于每个联结可以采用不同的联结类型</p><h2 id="15、组合查询"><a href="#15、组合查询" class="headerlink" title="15、组合查询"></a>15、组合查询</h2><h3 id="1、组合查询"><a href="#1、组合查询" class="headerlink" title="1、组合查询"></a>1、组合查询</h3><p>MySQL也允许执行多个查询，并将结果作为单个查询结果集返回，这些组合查询通常成为并或复合查询</p><p>使用组合查询的基本情况</p><p>1、在单个查询中从不同的表返回类似结果的数据</p><p>2、对单个表执行多个查询，按单个返回数据</p><h3 id="2、创建组合查询"><a href="#2、创建组合查询" class="headerlink" title="2、创建组合查询"></a>2、创建组合查询</h3><p>可用UNION操作符来组合数条SQL查询，利用UNION，可以给出多条SELECT语句，将它们结果组成单个结果集</p><h4 id="1、使用UNION"><a href="#1、使用UNION" class="headerlink" title="1、使用UNION"></a>1、使用UNION</h4><p>SELECT vend_id，prod_id，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt;= 5</p><p>UNION</p><p>SELECT vend_id, prod_id, prod_price</p><p>FROM products</p><p>WHERE vend_Id IN (1001,1002)</p><p>这条语句由前面两条SELECT 语句组成，语句用UNION关键字分割</p><p>（在某个条件也可以用多条WHERE子句代替UNION查询）</p><h4 id="2、UNION规则"><a href="#2、UNION规则" class="headerlink" title="2、UNION规则"></a>2、UNION规则</h4><p>1、必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）</p><p>2、每个查询必须包含相同的列、表达式或聚集函数</p><p>3、列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含的转换的类型</p><h4 id="3、包含或取消重复的行"><a href="#3、包含或取消重复的行" class="headerlink" title="3、包含或取消重复的行"></a>3、包含或取消重复的行</h4><p>SELECT vend_id，prod_id，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt;= 5</p><p>UNION  ALL</p><p>SELECT vend_id, prod_id, prod_price</p><p>FROM products</p><p>WHERE vend_Id IN (1001,1002)</p><p>ORDER BY vend_id,prod_price</p><p>使用UNION ALL则不取消重复的行</p><h4 id="4、对组合查询结果排序"><a href="#4、对组合查询结果排序" class="headerlink" title="4、对组合查询结果排序"></a>4、对组合查询结果排序</h4><p>SELECT vend_id，prod_id，prod_price</p><p>FROM Products</p><p>WHERE prod_price &lt;= 5</p><p>UNION</p><p>SELECT vend_id, prod_id, prod_price</p><p>FROM products</p><p>WHERE vend_Id IN (1001,1002)</p><p>ORDER BY vend_id,prod_price</p><p>SELECT语句的输出用ORDER BY子句排序，在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后</p><h2 id="16、使用文本搜索"><a href="#16、使用文本搜索" class="headerlink" title="16、使用文本搜索"></a>16、使用文本搜索</h2><h3 id="1、理解全文本搜索"><a href="#1、理解全文本搜索" class="headerlink" title="1、理解全文本搜索"></a>1、理解全文本搜索</h3><p>MySQL支持几种基本的数据库引擎。两个最常用的引擎为MyISAM和InnoDB,前者支持全文本搜索，而后者不吃</p><p>全文本搜索可以解决通配符和正则表达式带来的几种限制</p><p>1、性能</p><p>2、明确控制</p><p>3、智能化的结果</p><h3 id="2、使用全文本搜索"><a href="#2、使用全文本搜索" class="headerlink" title="2、使用全文本搜索"></a>2、使用全文本搜索</h3><p>为了全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断的重新索引</p><p>在索引之后SELECT 可与Match()和Against()一起使用以实际执行搜索</p><h4 id="1、启用全文本搜索"><a href="#1、启用全文本搜索" class="headerlink" title="1、启用全文本搜索"></a>1、启用全文本搜索</h4><p>一般在创建表的时候启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，他给出被索引列的一个逗号分隔的列表</p><p>CREATE TABLE productnotes</p><p>{</p><p>note_id  int</p><p>prod_id char(10)</p><p>note_date datetime</p><p>note_text text</p><p>PRIMARY  KEY(note_id)</p><p>FULLTEXT(note_text )</p><p>} ENGINE=MyISAM;</p><p>为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引</p><p>这里的FULLTEXT索引单个列</p><p><strong>不要再导入数据时使用FULLTEXT，更新索引要化时间，，应该首先导入所有数据，然后再修改表，定义FULLTEXT</strong></p><h4 id="2、进行全文本搜索"><a href="#2、进行全文本搜索" class="headerlink" title="2、进行全文本搜索"></a>2、进行全文本搜索</h4><p>在索引之后，使用MATCH指定被搜索的列，Against指定要使用的搜索的表达式</p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE Match(note_text) Against(‘rabbit’);</p><p>指定词rabbit作为搜索文本，Match指示MySQL针对指定的列进行搜索</p><p><strong>传递给Match()的值必须与FULLTEXT()定义中的相同。除非使用BINARY方式，否则全文本搜索不区分大小写</strong></p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE note_text LIKE ‘%rabbite%’;</p><p>用正则表达式实现同样的结果</p><p>SELECT note_text，Match(note_text) Against(‘rabbit’) AS rank</p><p>FROM productnotes;</p><h4 id="3、使用查询扩展"><a href="#3、使用查询扩展" class="headerlink" title="3、使用查询扩展"></a>3、使用查询扩展</h4><p>查询扩展用来设法放宽所返回全文本搜索的结果范围，找出相关行的其他行</p><p>在使用查询扩展时,MySQL对数据和索引进行两边扫描来完成搜索，</p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE Match(note_text)  Against(‘avails’ WITH QUERY EXPANSION);</p><p>查询扩展功能用于4.4.1或更高级的版本</p><h4 id="4、布尔文本搜索"><a href="#4、布尔文本搜索" class="headerlink" title="4、布尔文本搜索"></a>4、布尔文本搜索</h4><p>以布尔方式可以提供关于如下内容的细节</p><p>1、要匹配的词</p><p>2、要排斥的的词</p><p>3、排列提示</p><p>4、表达式分组</p><p>5、另外一些内容</p><p>SELECT note_text</p><p>FROM productnotes</p><p>WHERE Match(note_text)  Against(‘heavy’ IN BOOLEAN MODE);</p><h4 id="5、全文本搜索的使用说明"><a href="#5、全文本搜索的使用说明" class="headerlink" title="5、全文本搜索的使用说明"></a>5、全文本搜索的使用说明</h4><p>1、在索引全文本数据时，短词被忽略且从中排除</p><p>2、MySQL带有一个内建的非用词列表，这些词在索引全文本数据时总是被忽略</p><p>3、许多词出现频率很高，搜索它们没有用</p><p>4、如果表中的行数少于3行，则全文搜所不返回结果</p><p>5、忽略词中的单引号</p><h2 id="17、插入数据"><a href="#17、插入数据" class="headerlink" title="17、插入数据"></a>17、插入数据</h2><h3 id="1、数据插入"><a href="#1、数据插入" class="headerlink" title="1、数据插入"></a>1、数据插入</h3><p>INSERT用来插入或添加行到数据库表的</p><p>可以插入完整的行，插入行的一部分，插入多行，插入某些查询的结果</p><h3 id="2、插入完整的行"><a href="#2、插入完整的行" class="headerlink" title="2、插入完整的行"></a>2、插入完整的行</h3><p>INSERT INTO Customers</p><p>VALUES(NULL,</p><p>‘PEP . LAPEW’</p><p>‘100 Main Street’,</p><p>‘Los Angles’,</p><p>‘CA’,</p><p>‘90046’,</p><p>‘USA’,</p><p>NULL,</p><p>NULL);’</p><p><strong>INSERT语句一般不会产生输出，这种语法简单但并不安全</strong></p><p>以下方式更安全</p><p>INSERT INTO Customers（cust_name,</p><p>cust_address,</p><p>cust_city,</p><p>cust_state,</p><p>cust_zip,</p><p>cust_country,</p><p>cust_contact,</p><p>cust_email)</p><p>VALUES(NULL,</p><p>‘PEP . LAPEW’</p><p>‘100 Main Street’,</p><p>‘Los Angles’,</p><p>‘CA’,</p><p>‘90046’,</p><p>‘USA’,</p><p>NULL,</p><p>NULL);’</p><p><strong>一般不要使用没有明确给出列的列表的INSERT语句，而且INSERT语句是耗时，而且它可能降低等待处理的SELECT语句的性能，如果数据检索是最重要的，则你可以通过在INSERT和INFO之间添加关键字LOW_PROIORITY</strong></p><h3 id="3、插入多个行"><a href="#3、插入多个行" class="headerlink" title="3、插入多个行"></a>3、插入多个行</h3><p>可以使用多条INSERT语句，设置一次提交，每条语句用一个分号结束</p><p>或者只要每条INSERT语句中的列名相同，而已如下组合各语句</p><h4 id="4、插入检索出的数据"><a href="#4、插入检索出的数据" class="headerlink" title="4、插入检索出的数据"></a>4、插入检索出的数据</h4><p>将SELECT语句结果插入多个表中。这就是所谓的INSERT SELECT</p><p>INSERT INTO Customers（cust_name,</p><p>cust_address,</p><p>cust_city,</p><p>cust_state,</p><p>cust_zip,</p><p>cust_country,</p><p>cust_contact,</p><p>cust_email)</p><p>SELECT cust_name,</p><p>cust_address,</p><p>cust_city,</p><p>cust_state,</p><p>cust_zip,</p><p>cust_country,</p><p>cust_contact,</p><p>cust_email</p><p>FROM custnew;</p><p><strong>SELECT语句可以包含WHERE子句以过滤插入的数据</strong></p><h2 id="18、更新和删除数据"><a href="#18、更新和删除数据" class="headerlink" title="18、更新和删除数据"></a>18、更新和删除数据</h2><h3 id="1、更新数据"><a href="#1、更新数据" class="headerlink" title="1、更新数据"></a>1、更新数据</h3><p>可使用UPDATE</p><p>更新表中特定行</p><p>更新表中所有行</p><p><strong>不要省略WHERE子句，在使用UPDATE时一定要注意细心</strong></p><p>UPDATE语句非常容易使用，由三部分组成</p><p>要更新的表</p><p>列名和它们的新值</p><p>确定要更新行的过滤条件</p><p>UPDATE customers</p><p>SET cust_email = ‘<a href="mailto:&#101;&#x6c;&#109;&#x65;&#114;&#64;&#102;&#x75;&#x64;&#100;&#x2e;&#x63;&#111;&#x6d;">&#101;&#x6c;&#109;&#x65;&#114;&#64;&#102;&#x75;&#x64;&#100;&#x2e;&#x63;&#111;&#x6d;</a>‘</p><p>WHERE cust_id = 1005;</p><p>SET子句设置cust_email列为指定的值</p><p>UPDATE语句以WHERE子句结束</p><p>UPDATE customers</p><p>SET cust_email = ‘<a href="mailto:&#101;&#108;&#109;&#x65;&#114;&#64;&#x66;&#x75;&#x64;&#100;&#46;&#x63;&#x6f;&#x6d;">&#101;&#108;&#109;&#x65;&#114;&#64;&#x66;&#x75;&#x64;&#100;&#46;&#x63;&#x6f;&#x6d;</a>‘</p><p>cust_name = ‘The Fudds’</p><p>WHERE cust_id = 1005;</p><p><strong>如果UPDATE语句更新多行，并且在更新这些行中的一行或多行时出现一个错误，则整个操作被取消，因此可使用IGNORE关键字</strong></p><p>如果要删除某个列的值，可设置为NULL</p><p>UPDATE customers</p><p>SET cust_email = NULL</p><p>WHERE cust_id = 1005</p><h3 id="2、删除数据"><a href="#2、删除数据" class="headerlink" title="2、删除数据"></a>2、删除数据</h3><p>使用DELETE语句，可以两种方式使用DELETE</p><p>1、从表中删除特定的行</p><p>2、从表中删除所有的行</p><p>DELETE FROM customers</p><p>WHERE cust_id = 10006;</p><p><strong>DELETE删除整行而不是删除列，为了删除指定的列，请使用UPDATE语句，而且DELETE不删除表本身，如果想从表中删除所有行，不要使用DELETE，可以使用TRUNCATE TABLE，完成相同的工作，但速度更快</strong></p><h3 id="3、更新和删除的指导原则"><a href="#3、更新和删除的指导原则" class="headerlink" title="3、更新和删除的指导原则"></a>3、更新和删除的指导原则</h3><p>1、除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句</p><p>2、保证每个表都有主键</p><p>3、在对使用更新和删除语句使用WHERE子句前，应该先用SELECT测试</p><p>4、使用强制实施以用完整性的数据库</p><h2 id="19、创建和操作表"><a href="#19、创建和操作表" class="headerlink" title="19、创建和操作表"></a>19、创建和操作表</h2><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>两种创建表的方法</p><p>1、使用具有交互式创建和管理表的工具</p><p>2、表也可以直接用MySQL语句操纵</p><h4 id="1、表创建基础"><a href="#1、表创建基础" class="headerlink" title="1、表创建基础"></a>1、表创建基础</h4><p>要利用CREATE TABLE创建表必须要下列信息</p><p>1、新表的名字，在关键字CREATE TABLE之后给出</p><p>2、表列的名字和定义，用逗号分隔</p><p>CREATE TBALE customers</p><p>(</p><p>cust_id int NOT NULL AUTO_INCREMENT,</p><p>cust_name char(50) NOT NULL,</p><p>cust_address char(50) NULL,</p><p>cust_email char(255) NULL,</p><p>PRIMARY EKY （cust_id)</p><p>)ENGINE=InnoDB;</p><p>表的主键可以在创建表时用PRIMARY KEY关键字指定</p><p><strong>强烈推荐采用某种缩进格式，同时在创建新表时指定的表明必须不存在没否则将出错，如果 要防止意外覆盖已有的表，SQL要求首先手工删除该表，然后再重建它，而不是简单用创建语句覆盖它</strong></p><h4 id="2、使用NULL值"><a href="#2、使用NULL值" class="headerlink" title="2、使用NULL值"></a>2、使用NULL值</h4><p>CREATE TBALE customers</p><p>(</p><p>cust_id int NOT NULL AUTO_INCREMENT,</p><p>cust_name char(50) NOT NULL,</p><p>cust_address char(50) NULL,</p><p>cust_email char(255) NULL,</p><p>cust_date datetime NOT NULL,</p><p>PRIMARY EKY （cust_id)</p><p>)ENGINE=InnoDB;</p><p>如果每个列的定义含有关键字NOT NULL，这将会住址插入没有值的列，如果试图插入将返回错误且插入失败</p><h4 id="3、主键再介绍"><a href="#3、主键再介绍" class="headerlink" title="3、主键再介绍"></a>3、主键再介绍</h4><p>主键值必须唯一</p><p>如果主键使用单个列，则它的值必须唯一</p><p>CREATE TABLE orderitems</p><p>{</p><p>order_num int NOT NULL,</p><p>item_price decimal(8,2) NOT NULL,</p><p>PRIMARY KEY (order_num, order_item)</p><p>}ENGINE=InnoDB;</p><p><strong>主键只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识</strong></p><h4 id="4、使用AUTO-INCREMENT"><a href="#4、使用AUTO-INCREMENT" class="headerlink" title="4、使用AUTO_INCREMENT"></a>4、使用AUTO_INCREMENT</h4><p>AUTO_INCREMENT告诉MySQL本例增加一行时自动增量。每执行一个INSERT操作，将自动对该列增量</p><h4 id="5、指定默认值"><a href="#5、指定默认值" class="headerlink" title="5、指定默认值"></a>5、指定默认值</h4><p>CREATE TABLE orderitems</p><p>{</p><p>order_num int NOT NULL,</p><p>item_price decimal(8,2) NOT NULL,</p><p>quantity int NOT NULL DEFAULT 1,</p><p>PRIMARY KEY (order_num, order_item)</p><p>}ENGINE=InnoDB;</p><p>DEFAULT 1指示MySQL,在未给出数量的情况使用数量1</p><p><strong>与大多数DBMS不一样，MySQL不允许使用函数作为默认值，只支持常量</strong></p><h4 id="6、引擎类型"><a href="#6、引擎类型" class="headerlink" title="6、引擎类型"></a>6、引擎类型</h4><p> 与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。 </p><p>引擎类型</p><p>1、 InnoDB是一个可靠的事务处理引擎（，它不支持全文本搜索 </p><p>2、 MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表）</p><p>3、 MyISAM是一个性能极高的引擎，它支持全文本搜索， 但不支持事务处理 </p><p><strong>外键不能跨引擎，使用一个引擎的表不能引用具有使用不同隐情表的外键</strong></p><h3 id="2、更新表"><a href="#2、更新表" class="headerlink" title="2、更新表"></a>2、更新表</h3><p>使用ALTER TABLE更改表结构必须如下信息</p><p>1、ALTER TABLE之后根除要更改表明（该表必须存在）</p><p>2、所做更改列表</p><p>ALTER TABLE vendors</p><p>ADD vend_phone char(20)</p><p>这条语句给vendors增加一个名为vend_phone的列，必须表明其数据类型</p><p>ALTER TABLE  vendors</p><p>DROP COLUMN vend_phone删除刚刚添加的列‘</p><p>ALTER TABLE的一种常见用途是定义外键</p><p>ALTER TBALE oderitems</p><p>ADD CONSTRAINT fk_orderitems_orders</p><p>FOREIGN KEY (order_num) REFERENCES orders (order_num)</p><h3 id="3、删除表"><a href="#3、删除表" class="headerlink" title="3、删除表"></a>3、删除表</h3><p>DROP TABLE customers</p><h3 id="4、重命名表"><a href="#4、重命名表" class="headerlink" title="4、重命名表"></a>4、重命名表</h3><p>RENAME TBALE customers2 TO customers</p><h2 id="20、使用视图"><a href="#20、使用视图" class="headerlink" title="20、使用视图"></a>20、使用视图</h2><h3 id="1、视图"><a href="#1、视图" class="headerlink" title="1、视图"></a>1、视图</h3><p>Mysql5添加了对视图的支持</p><h4 id="1、为什么使用视图"><a href="#1、为什么使用视图" class="headerlink" title="1、为什么使用视图"></a>1、为什么使用视图</h4><p>1、重用SQL语句</p><p>2、简化复杂的SQL操作</p><p>3、使用表的我组成部分而不是整个表</p><p>4、保护数据</p><p>5、更改数据格式和表示</p><p><strong>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索，如果使用多个联结，和过滤创建了复杂的视图或者嵌套了视图，会发现性能下降的厉害</strong></p><h4 id="2、视图规则和限制"><a href="#2、视图规则和限制" class="headerlink" title="2、视图规则和限制"></a>2、视图规则和限制</h4><p> 1、 与表一样，视图必须唯一命名。 </p><p>2、对于可以创建的视图数目没有限制。 </p><p>3、为了创建视图，必须具有足够的访问权限。这些限制通常由数据 库管理人员授予。 </p><p>4、 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造 一个视图。 </p><p>5、 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也 含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</p><p> 6、 视图不能索引，也不能有关联的触发器或默认值。 </p><p>7、 视图可以和表一起使用。</p><h3 id="2、使用视图"><a href="#2、使用视图" class="headerlink" title="2、使用视图"></a>2、使用视图</h3><p> 1、视图用CREATE VIEW语句来创建。</p><p> 2、使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 </p><p>3、 用DROP删除视图，其语法为DROP VIEW viewname;。</p><p> 4、更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR  REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创 建一个视图；如果要更新的视图存在，则第2条更新语句会替换原 有视图。 </p><h4 id="1、利用视图简化复杂的联结"><a href="#1、利用视图简化复杂的联结" class="headerlink" title="1、利用视图简化复杂的联结"></a>1、利用视图简化复杂的联结</h4><p>CREATE VIEW productcustomers AS</p><p>SELECT cust_name,cust_contact,prod_id</p><p>FROM customers,orders,orderitems</p><p>WHERE customer.cust_id =orders.cust_id</p><p>AND orderitems,order_num=order.order_num;</p><p>这里联结三个表，返回已订购任意产品所有客户的列表</p><h4 id="2、用视图重新格式化检索出的数据"><a href="#2、用视图重新格式化检索出的数据" class="headerlink" title="2、用视图重新格式化检索出的数据"></a>2、用视图重新格式化检索出的数据</h4><p>CREATE VIEW vendorlocation AS </p><p>SELECT Concat(RTrim(vend_name)),’(‘,RTrim(vend_country)’)’</p><p>AS vend_title</p><p>FROM vendors</p><p>ORDER BY vend_name;</p><p>这条语句使用以前的select语句相同的查询创建视图，这时可以使用视图</p><p>SELECT *</p><p>FROM vendorlocations;</p><h4 id="3、用视图过滤不想要的数据"><a href="#3、用视图过滤不想要的数据" class="headerlink" title="3、用视图过滤不想要的数据"></a>3、用视图过滤不想要的数据</h4><p>视图对于应用普通的WHERE子句也很有用</p><p>CREATE VIEW customeremaillist AS</p><p>SELECT cust_name,cust_id,cust_email</p><p>FROM customers,</p><p>WHERE cust_email IS NOT NULL;</p><h4 id="4、使用视图与计算字段"><a href="#4、使用视图与计算字段" class="headerlink" title="4、使用视图与计算字段"></a>4、使用视图与计算字段</h4><p>SELECT prod_id,quantity,item_price,quantity*item_price</p><p>AS expanded_price </p><p>FROM orderitems</p><p>WHERE order_num=20005;</p><p>将其转换为一个视图</p><p>CREATE VIEM orderitemsexpanded AS</p><p>SELECT prod_id,quantity,item_price,quantity*item_price</p><p>AS expanded_price </p><p>FROM orderitems;l</p><p>如果要检索20005详细内容，如下进行</p><p>SELECT * </p><p>FROM orderitemexpander</p><p>WEHER order_num = 20005;</p><h4 id="5、更新视图"><a href="#5、更新视图" class="headerlink" title="5、更新视图"></a>5、更新视图</h4><p>视图是可以更新的，但是并非所有视图都是可更新的，如果Mysql不能正确确定被更新的基数据，则不允许更新</p><p>也就是如果有一下操作则不能更新</p><p>1、分组</p><p>2、联结</p><p>3、子查询</p><p>4、并</p><p>5、聚集函数（Min()、Count()、Sum())</p><p>6、DISTINCT</p><p>7、导出（计算）列</p><h2 id="21、使用存储过程"><a href="#21、使用存储过程" class="headerlink" title="21、使用存储过程"></a>21、使用存储过程</h2><h3 id="1、存储过程"><a href="#1、存储过程" class="headerlink" title="1、存储过程"></a>1、存储过程</h3><p>MySQL添加了对存储过程的支持</p><p>存储过程就是为以后的使用而保存的一条或多条MySQL语句的集合，可以将其视为批文件，虽然作用不仅限于批处理</p><h3 id="2、为什么要使用存储过程"><a href="#2、为什么要使用存储过程" class="headerlink" title="2、为什么要使用存储过程"></a>2、为什么要使用存储过程</h3><p>1、把处理封装在容易使用的单元中，简化复杂的操作</p><p>2、由于不要求反复建立一系列处理步骤，保存了数据的完整性</p><p>3、简化对变动的管理</p><h3 id="3、使用存储过程"><a href="#3、使用存储过程" class="headerlink" title="3、使用存储过程"></a>3、使用存储过程</h3><h4 id="1、执行存储过程"><a href="#1、执行存储过程" class="headerlink" title="1、执行存储过程"></a>1、执行存储过程</h4><p>CALL接受存储过程的名字以及需要传递给他的任意参数</p><p>CALL productpricing(@pricelow,@pricehigh,@priceaverage);</p><p>可以显示结果也可以不显示</p><h4 id="2、创建存储过程"><a href="#2、创建存储过程" class="headerlink" title="2、创建存储过程"></a>2、创建存储过程</h4><p>CREATE PROCEDURE productpricing()</p><p>BEGIN</p><p>​    SELECT Avg(prod_price) AS priceaverage</p><p>​    FROM products</p><p>END;</p><p>这里存储过程名为productpring，它们将在()列举出来，此存储过程没有参数，但后跟的()仍然徐娅，BEIGIN和END语句用来限定存储过程体，过程体本身只是一个SELECT语句</p><p>如果使用这个存储过程</p><p>CALL productpricing();</p><h4 id="3、删除存储过程"><a href="#3、删除存储过程" class="headerlink" title="3、删除存储过程"></a>3、删除存储过程</h4><p>DROP PROCEDURE productpricing;</p><p><strong>这里不用（）,只需要给出存储过程名</strong></p><h4 id="4、使用参数"><a href="#4、使用参数" class="headerlink" title="4、使用参数"></a>4、使用参数</h4><p>CREATE PROCEDURE productpricing(</p><p>OUT p1 DECIMAL(8,2),</p><p>OUT ph DECIMAL(8,2),</p><p>OUT pa DECIAML(8,2))</p><p>BEGIN</p><p>​    SELECT Min(prod_price) </p><p>​    INTO p1</p><p>​    FROM products;</p><p>​    SELECT Max(prod_price) </p><p>​    INTO pj</p><p>​    FROM products;</p><p>​    SELECT Avg(prod_price) </p><p>​    INTO pa</p><p>​    FROM products;</p><p>END;</p><p> 此存储过程接受3个参数：pl存储产品最低价格，ph存储产品 最高价格，pa存储产品平均价格。每个参数必须具有指定的类 型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出 一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存 储过程传出）和INOUT（对存储过程传入和传出）类型的参数。 </p><p>调用此存储过程必须指定3个变量名</p><p>CALL productpricing(@pricelow,@pricehigh,@priceaverage);</p><p><strong>所有MySQL变量都必须以@开始</strong></p><p>获得三个值，可使用以下语句</p><p>SELECT @pricehigh,@pricelow,@priceaverage;</p><p>下面使用IN 和OUT参数</p><p>CREATE PROCEDURE ordertotal(</p><p>​    IN onumber TNT,</p><p>​    OUT ototal DECIMAL(8,2)</p><p>)</p><p>BEGIN</p><p>​    SELECT Sum(item_price*quantity)</p><p>​    FROM orderitems</p><p>​    WHERE order_num = onumber</p><p>​    INTO ototal;</p><p>END;</p><p> onumber定义为IN，因为订单号被传入存储过程。ototal定义 为OUT，因为要从存储过程返回合计。SELECT语句使用这两个 参数，WHERE子句使用onumber选择正确的行，INTO使用ototal存储计算 出来的合计。 </p><p>CALL ordertotal(20005,@total);</p><p>必须给ordertotal传递两个函数，第一个参数为订单号，第二个参数为包含计算出来的合计变量名</p><p>为了显示合计</p><p>SELECT @total；</p><h4 id="5、建立智能存储过程"><a href="#5、建立智能存储过程" class="headerlink" title="5、建立智能存储过程"></a>5、建立智能存储过程</h4><p>增加注释–，添加另外一个参数taxable，它是一个布尔值，在DECLARE语句定义了两个局部变量</p><h4 id="6、检查存储过程"><a href="#6、检查存储过程" class="headerlink" title="6、检查存储过程"></a>6、检查存储过程</h4><p>要显示一个用来创建一个存储过程的CRETE语句，使用SHOW CREATE PROCEDURE语句</p><p>SHOW CREATE PROCEDURE ordertotal;</p><p>为了包括何时，由谁创建等详细存储过程列表使用SHOW PROCEDURE STATUS</p><p><strong>如果要限制SHOW PROCEDURE STATUS的输出，可以使用LIKE指定一个过滤模式</strong></p><h2 id="22、使用游标"><a href="#22、使用游标" class="headerlink" title="22、使用游标"></a>22、使用游标</h2><h3 id="1、游标"><a href="#1、游标" class="headerlink" title="1、游标"></a>1、游标</h3><p>游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据</p><h3 id="2、使用游标"><a href="#2、使用游标" class="headerlink" title="2、使用游标"></a>2、使用游标</h3><p>1、在使用游标前，必须声明它，这个过程实际上没有检索数据，他只是定义要使用的SELECT语句</p><p>2、一旦声明后，必须打开游标以供使用</p><p>3、对于填有数据的游标，根据需要取出各行</p><p>4、结束使用游标后，必须关闭游标</p><h4 id="1、创建游标"><a href="#1、创建游标" class="headerlink" title="1、创建游标"></a>1、创建游标</h4><p>游标用DECLARE创建，DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句</p><p>CREATE PROCEDURE processorders()</p><p>BEGIN</p><p>​    DECLARE ordernumbers CURSOR</p><p>​    FOR</p><p>​    SELECT order_num FROM orders;</p><p>END;</p><p>这里定义命名游标，存储过程处理完成后，游标就消失</p><p>定义游标之后可以重新打开它</p><h4 id="2、打开和关闭游标"><a href="#2、打开和关闭游标" class="headerlink" title="2、打开和关闭游标"></a>2、打开和关闭游标</h4><p>游标用OPEN CURSOR语句打开</p><p>OPEN odernumbers;</p><p>游标用CLOSE语句关闭，CLOSE释放游标使用的内部内存和资源，因此每个游标不在需要时都应该关闭</p><h4 id="3、使用游标数据"><a href="#3、使用游标数据" class="headerlink" title="3、使用游标数据"></a>3、使用游标数据</h4><p>在一个游标被打开之后，可以使用FETCH语句分别访问他的每一行，指定检索什么数据,检索出来的数据存储在什么地方</p><p>CREATE PROCEDURE processorders()</p><p>BEGIN</p><p>//声明名为o的变量名</p><p>​    DECLARE o INT;</p><p>​    DECLARE ordernumbers CURSOR</p><p>​    FOR</p><p>​    SELECT order_num FROM orders;</p><p>​    OPEN ordernumbers;</p><p>​    FETCH ordernumbers INTO o;</p><p>​    CLOSE ordernumbers;</p><p>END;</p><h2 id="23、使用触发器"><a href="#23、使用触发器" class="headerlink" title="23、使用触发器"></a>23、使用触发器</h2><h3 id="1、触发器"><a href="#1、触发器" class="headerlink" title="1、触发器"></a>1、触发器</h3><p>触发器是MySQL相应以下任意语句而自动执行的一条MySQL语句</p><p>1、DELETE</p><p>2、INSERT</p><p>3、UPDATE</p><p>其他语句不支持触发器</p><h3 id="2、创建触发器"><a href="#2、创建触发器" class="headerlink" title="2、创建触发器"></a>2、创建触发器</h3><p> 1、唯一的触发器名； </p><p>2、触发器关联的表；</p><p> 3、触发器应该响应的活动（DELETE、INSERT或UPDATE）； </p><p>4、触发器何时执行（处理之前或之后） </p><p><strong>保持每个数据库的触发器名唯一</strong></p><p>CREATE TRIGGER newproduct AFTER INSERT ON products</p><p>FOR EACH ROW SELECT ‘Product added’;</p><p>create trigger用来创建名为newproduct的新触发器，触发器可以在一个操作之前或之后执行，这里的AFTER INSERT， 所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次 </p><p><strong>只有表支持触发器，视图不支持</strong></p><p>触发器每个表每个事件每次定义，每个表每个事件每次只允许一个触发器。<strong>因此每个表最多支持6个触发器，如果BEFORE触发器失败或语句本身，则MySQL将不执行AFTER触发器</strong></p><h3 id="3、删除触发器"><a href="#3、删除触发器" class="headerlink" title="3、删除触发器"></a>3、删除触发器</h3><p>DROP TRIGGER newproduct;</p><p>为了修改一个触发器，必须先删除它，然后再重新创建</p><h3 id="4、使用触发器"><a href="#4、使用触发器" class="headerlink" title="4、使用触发器"></a>4、使用触发器</h3><h4 id="1、INSERT触发器"><a href="#1、INSERT触发器" class="headerlink" title="1、INSERT触发器"></a>1、INSERT触发器</h4><p> 1、在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行； </p><p>2、在BEFORE INSERT触发器中，NEW中的值也可以被更新）；</p><p> 3、对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值 </p><p>CREATE TRIGGER neworder AFTER INSERT ON orders</p><p>FOR EACH ROW SELECT NEW.order_num;</p><p> 在插入一个新订单到orders表时，MySQL生 成一个新订单号并保存到order_num中。触发器从NEW.order_num取得 这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。 </p><h4 id="2、DELETE触发器"><a href="#2、DELETE触发器" class="headerlink" title="2、DELETE触发器"></a>2、DELETE触发器</h4><p> 1、 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访 问被删除的行；  </p><p> 2、OLD中的值全都是只读的，不能更新。 </p><p>使用OLD保存将要被删除的行到一个存档表中：<br>CREATE TRIGGER deleteorder BEFORE DELETE ON orders</p><p>FOR EACH ROW</p><p>BEGIN</p><p>​    INSERT INTO arichive_orders(order_num,order_date,cust_id)</p><p>VALUES(OLD.order_num,OLD.order_date,OLD.cust_id);</p><p>END;</p><p> 在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_  orders的存档表中 </p><p><strong>使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器 来说），如果由于某种原因，订单不能存档，DELETE本身将被放弃</strong></p><h4 id="3、UPDATE触发器"><a href="#3、UPDATE触发器" class="headerlink" title="3、UPDATE触发器"></a>3、UPDATE触发器</h4><p> 1、在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新 更新的值；</p><p>2、在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）；</p><p> 3、OLD中的值全都是只读的，不能更新。 </p><p>CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors </p><p>FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state)</p><p> 每次更新一个行时，NEW.vend_state中的 值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。 </p><h4 id="4、触发器进一步介绍"><a href="#4、触发器进一步介绍" class="headerlink" title="4、触发器进一步介绍"></a>4、触发器进一步介绍</h4><p>1、与其他DBMS相比，MySQL 5中支持的触发器相当初级。 </p><p>2创建触发器可能需要特殊的安全访问权限，但是，触发器的执行 是自动的。 </p><p>3、应该用触发器来保证数据的一致性（大小写、格式等）。 </p><p>4、 触发器的一种非常有意义的使用是创建审计跟踪。 </p><p>5、 MySQL触发器中不支持CALL语句。 </p><h2 id="24、管理事务处理"><a href="#24、管理事务处理" class="headerlink" title="24、管理事务处理"></a>24、管理事务处理</h2><h3 id="1、事务处理"><a href="#1、事务处理" class="headerlink" title="1、事务处理"></a>1、事务处理</h3><p> MyISAM和InnoDB是两种最常使用 的引擎。前者不支持明确的事务处理管理，而后者支持 </p><p>1、 事务（transaction）指一组SQL语句； </p><p>2、回退（rollback）指撤销指定SQL语句的过程；</p><p>3、提交（commit）指将未存储的SQL语句结果写入数据库表； </p><p>4、保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 </p><h3 id="2、控制事务处理"><a href="#2、控制事务处理" class="headerlink" title="2、控制事务处理"></a>2、控制事务处理</h3><p> MySQL使用下面的语句来标识事务的开始： </p><p>START TRANSACTION</p><h4 id="1、使用ROLLBACK"><a href="#1、使用ROLLBACK" class="headerlink" title="1、使用ROLLBACK"></a>1、使用ROLLBACK</h4><p> MySQL的ROLLBACK命令用来回退（撤销）MySQL语句.</p><p>SELECT * FROM ordertotals;</p><p>START TRANSACTION;</p><p>DELETE FROM ordertotals;</p><p>SELECT * FROM ordertotals;</p><p>ROLLBACK;</p><p>SELECT *FROM ordertotals;</p><p>从显示ordertotals表的内容开始。首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退 START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为 空。 显然，ROLLBACK只能在一个事务处理内使用</p><p>**事务处理用来管理INSERT UPDATE 和DELETE语句不能回退SELECT语句以及回退CREATE或DROP操作 **</p><h4 id="2、使用COMMIT"><a href="#2、使用COMMIT" class="headerlink" title="2、使用COMMIT"></a>2、使用COMMIT</h4><p> 一般的MySQL语句都是直接针对数据库表执行和编写的。这就是 所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 </p><p>为明确的提交，使用COMMIT语句</p><p>START TRANSACTION</p><p>DELETE FROM orderitems WHERE order_num = 20010;</p><p>DELETE FROM orders WHERE order_num = 20010;</p><p>COMMIT;</p><p> 因为涉及更新 两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETKE不会提交</p><h4 id="3、使用保留点"><a href="#3、使用保留点" class="headerlink" title="3、使用保留点"></a>3、使用保留点</h4><p> 简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部 分提交或回退 </p><p>为了创建占位符</p><p>SAVEPOINT delete1’</p><p>每个保留点都取表示它的唯一名字</p><p>ROLLBACK TO delete1;</p><p>**保留点越多越好，而且保留点在事务处理完成后自动释放 也可以用RELEASE SAVEPOINT明确地释放保留点 **</p><h4 id="4、更改默认的提交行为"><a href="#4、更改默认的提交行为" class="headerlink" title="4、更改默认的提交行为"></a>4、更改默认的提交行为</h4><p> 默认的MySQL行为是自动提交所有更改 </p><p>SET autocommit = 0;</p><p>autocommit标志决定是否自动提交更改，不管有没有COMMIT语句，设置为0则只是不自动提交更改</p><h2 id="25、安全管理"><a href="#25、安全管理" class="headerlink" title="25、安全管理"></a>25、安全管理</h2><h3 id="1、访问控制"><a href="#1、访问控制" class="headerlink" title="1、访问控制"></a>1、访问控制</h3><p> 访问控制的目的不仅仅是防止用户的恶意企图还有无疑是错误的结果</p><p><strong>在现实世界 的日常工作中，决不能使用root，除非在绝对情况</strong></p><h3 id="2、管理用户"><a href="#2、管理用户" class="headerlink" title="2、管理用户"></a>2、管理用户</h3><p>USE mysql</p><p>SELECT user FROM user;</p><p>获得用户账号列表时</p><h4 id="1、创建用户账号"><a href="#1、创建用户账号" class="headerlink" title="1、创建用户账号"></a>1、创建用户账号</h4><p>CREATE USER ben IDENTIFIED BY ’p@$$w0ord‘;</p><p>创建用户不一定需要口令，CREATE USER创建一个新用户账号</p><p>**令IDENTIFIED BY指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密， GRANT语句也可以创建用 户账号，但一般来说CREATE USER是最清楚和最简单的句子。 **</p><p>重新命名一个用户账号</p><p>RENAME USER ben TO bforta;</p><h4 id="2、删除用户账号"><a href="#2、删除用户账号" class="headerlink" title="2、删除用户账号"></a>2、删除用户账号</h4><p>DROP USER bforta;</p><p><strong>自MySQL 5以来，DROP USER删除用户账号和 所有相关的账号权限。在MySQL 5以前，DROP USER只能用来 删除用户账号，不能删除相关的权限。</strong></p><h4 id="3、设置访问权限"><a href="#3、设置访问权限" class="headerlink" title="3、设置访问权限"></a>3、设置访问权限</h4><p>SHOW GRANTS FOR bforta;</p><p>看到赋予用户账号的权限</p><p> 设置权限，使用GRANT语句。GRANT要求你至少给出以下信息： </p><p>1、要授予的权限； </p><p>2、被授予访问权限的数据库或表；</p><p>3、 用户名。 </p><p>GRANT SELECT ON crashcourse. * TO bforta;</p><p>此GUANT允许用户在crashcourse,*上使用SELECT</p><p>GRANT反操作为REVOKE,用来撤销特定的权限</p><p>REVOKE SELECT ON crashcoure.* FROM bforta;</p><p> GRANT和REVOKE可在几个层次上控制访问权限：</p><p>1、 整个服务器，使用GRANT ALL和REVOKE ALL；</p><p>2、整个数据库，使用ON database.*；</p><p>3、 特定的表，使用ON database.table；</p><p>4、特定的列； </p><p>5、 特定的存储过程。 </p><h4 id="4、更改口令"><a href="#4、更改口令" class="headerlink" title="4、更改口令"></a>4、更改口令</h4><p>SET PASSWORD FOR bforta = Password(‘n3w’)</p><p>SET PASSWORD更新用户口令。新口令必须传递到Password()函数进行加密。 </p><h2 id="26、数据库维护"><a href="#26、数据库维护" class="headerlink" title="26、数据库维护"></a>26、数据库维护</h2><h3 id="1、备份数据"><a href="#1、备份数据" class="headerlink" title="1、备份数据"></a>1、备份数据</h3><p> 由于这些文件总是处于打开和使用状态，普通的文件副本备份不 一定总是有效。 因此以下几种方法备份</p><p>1、 使用命令行实用程序mysqldump转储所有数据库内容到某个外部 文件。在进行常规备份前这个实用程序应该正常运行，以便能正 确地备份转储文件。 </p><p>2、可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据 （但是并非所有数据库引擎都支持这个实用程序）。</p><p>3、可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所 有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，而且此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原 。</p><p><strong>首先刷新未写数据为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。</strong></p><h3 id="2、数据库维护"><a href="#2、数据库维护" class="headerlink" title="2、数据库维护"></a>2、数据库维护</h3><p>ANALYZE TABLE orders;</p><p>用来检查表键是否正确</p><p>CHECK TABLE orders,orderitems;</p><p>用来针对许多问题进行检查</p><p>1、如果MyISAM表访问产生不正确和不一致的结果，可能需要用 REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题</p><p> 2、如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。  </p><h4 id="3、诊断启动问题"><a href="#3、诊断启动问题" class="headerlink" title="3、诊断启动问题"></a>3、诊断启动问题</h4><p> MySQL 服务器自身通过在命令行上执行mysqld启动。 </p><h4 id="4、查看日志文件"><a href="#4、查看日志文件" class="headerlink" title="4、查看日志文件"></a>4、查看日志文件</h4><p> 1、错误日志。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用 –log-error命令行选项更改。 </p><p>2、查询日志。它记录所有MySQL活动，在诊断问题时非常有用。由于日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用 –log命令行选项更改。</p><p>3、二进制日志。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前MySQL版本中使用的是更新日志。 </p><p>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。此日志通常名为 hostname-slow.log ，位于 data 目录中。此名字可以用 –log-slow-queries命令行选项更改 </p><p>**在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 **</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux和虚拟机学习笔记</title>
      <link href="/2021/09/09/linux%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/09/linux%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="网路连接三种模式"><a href="#网路连接三种模式" class="headerlink" title="网路连接三种模式"></a>网路连接三种模式</h3><p>1、桥接模式：虚拟系统和外部系统通讯，但是造成Ip冲突</p><p>2、NAT模式：网络哟地址转换模式，虚拟系统可以和外部系统通讯，不造成Ip冲突（能够代理出来但不能回去）</p><p>3、主机模式：主机系统</p><h3 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h3><p>1、使用vmware的克隆操作，克隆要关闭Linux系统，，直接右键点击虚拟机-管理-克隆-创建完整的克隆-克隆完直接打开-剩下步骤和安装虚拟机相同</p><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>如果在使用虚拟机系统的时候，想回到原先的某一个状态，担心有些操作造成系统异常，需要回到某个正常运行的状态——快照管理</p><p>方法：右键虚拟机-快照-拍摄的快照-利用快照管理器转到该状态即可（在哪拍快照意味这在此开一个分支）当然每次快照都会占用磁盘空间</p><h3 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h3><p>迁移：直接虚拟机文件夹迁移，删除：直接磁盘文件删除（彻底）或者直接虚拟机内部文件夹删除（部分）</p><h3 id="利用vmtool实现文件共享"><a href="#利用vmtool实现文件共享" class="headerlink" title="利用vmtool实现文件共享"></a>利用vmtool实现文件共享</h3><p>安装完vmtool之后（需要gcc），利用设置设置共享文件夹，在linux中mmt文件夹下</p><h3 id="linux的目录结构"><a href="#linux的目录结构" class="headerlink" title="linux的目录结构"></a>linux的目录结构</h3><p>树状结构-把硬件都映射为文件，从根目录</p><p>/bin-是binary的缩写，目录存放最经常使用的指令。/sbin-存放系统管理员使用的系统管理程序</p><p>/root-该目录为系统管理员，也称作超级权限者用户主目录。</p><p>/lost+found-（隐藏，通过终端进入）一般为空，当系统非法关机就存放一些文件。</p><p>/lib-系统开机所需要最基本的动态连接共享库，其作用类似于windows的dll文件，几乎所有程序都需要这种共享库。</p><p>/etc-所有系统管理所需要的配置文件和子目录。</p><p>/user-用户应用程序和文件都放在这个programfile目录中。/user/local另一个注解额外安装软件所存放的目录</p><p>/boot启动Linux使用的一些核心文件。/proc(不能动)虚拟目录是系统内存的映射</p><p>/srv-(不能动)服务启动所需要的临时文件。/sys-(不能动)该目录安装了2.6内核下一个新的文件系统</p><p>/tmp存放临时文件。/dev-把所有硬件用文件存储/media自动识别的文件，/media-linux会把识别的设备挂载到这个目录之中</p><p>/mnt-让用户临时挂载别的文件系统。/opt-主机额外安装软件所存放的目录</p><p>/var这个目录存放不断被扩充东西，一般为各种经常修改的日志文件</p><p>/selinux-是一种安全子系统，他能控制程序访问特定文件</p><h3 id="linux远程登录和linux远程文件传输"><a href="#linux远程登录和linux远程文件传输" class="headerlink" title="linux远程登录和linux远程文件传输"></a>linux远程登录和linux远程文件传输</h3><p>远程登录linux进行项目管理和开发</p><p>远程登录：xshell 文件xftp6</p><p>查询ip地址ifconfig  然后ping +ip地址判断两者之间有无联网</p><p>利用xftp进行文件传输             （乱码则在属性改为utf-8)</p><h3 id="vi和vim的基本使用"><a href="#vi和vim的基本使用" class="headerlink" title="vi和vim的基本使用"></a>vi和vim的基本使用</h3><p>正常模式：vim打开一个档案直接进入一般模式</p><p>插入模式：按下i I,O o,A,a,r，R按任何一个字母会进入编辑模式</p><p>命令行模式：可以提供相关指令，完成读取，存盘，替换等vim操作，输入esc转为正常模式在输入‘：’或者‘ / ’从其他模式进入命令行模式 ，wq保存退出，q!强制退出不保存， q退出不保存</p><p>拷贝当前行（一般模式下）yy 然后p (粘贴) 拷贝多行 4yy（拷贝往上4行）然后输入p</p><p>删除当前行dd同时删除5行5dd，查找某个单词 （命令行模式下）/hello查找单词hello，输入n就是查找下一个</p><p>设置\取消文件的行号（命令行模式） ‘:set nu’\   ‘:set npnu’</p><p>定位文档最末行G最首行gg在(一般模式),撤销这个动作(一般模式) u</p><p>编辑文件定位(一般模式下)‘20gg’或’20G‘(定位到20行)</p><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><p>shutdown -h now 立刻进行关机</p><p>shudown -h 1 1分钟后关机</p><p>shutdown -r now 现在重新启动计算机   halt关机 reboot重启</p><p>sync内存数据同步到磁盘，无论重启还是关闭系统首先要运行sync命令，但目前关机重启指令都在关机前执行sync</p><h3 id="用户登录注销"><a href="#用户登录注销" class="headerlink" title="用户登录注销"></a>用户登录注销</h3><p>su - (用户名)  su - root 切换系统管理员身份（获取最大权限）  logout可以注销用户，root执行logout就会回到登录的身份如jesse,(logout在图形运行级别无效，在运行级别3有效)</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>添加一个用户 useradd 用户名 某人该用户的家目录在 /home/用户名会自动创建和用户名同名的家目录 useradd -d /home/test king 在test下创建一个用户king的家目录</p><p>passwd 用户名  指定密码否则如果不写用户名就是当前用户的密码</p><p>pwd显示当前用户在哪一个目录下</p><p>删除用户 userdel  用户名（要切成root删除用户）这是保留家目录的</p><p>userdel  -r 用户名 这是删除家目录的 （注意会把tom全部删除）</p><p>一般情况下建议保留家目录</p><p>查询用户信息 id 用户名，  who am i 查询当前用户信息</p><p>高权限用户到低权限用户不用输密码</p><p>用户组：系统对用共性的多个用户进行统一的股那里</p><p>groupadd 组名 （添加组）groupdel  组名（删除组）</p><p>useradd -g 用户组 用户名 增加用户名的同时增加组</p><p>usermod -g 用户组 用户名 修改用户的组</p><p>/etc/passwd 文件 用户的配置文件，记录用户各种信息</p><p>/etc /shadow 文件 口令配置文件 /etc/group 组的配置文件</p><p>/etc/group文件组的配置文件</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><p>运行级别：0关机1单用户 2多用户无网络 3多用户有玩咯4 系统未使用保留给用户 </p><p>5图形界面6系统重启 </p><p>init 切换不同的运行级别</p><p>systemctl get-default查看当前默认级别 </p><p><a href="https://zhuanlan.zhihu.com/p/102802164">找回root密码</a>或者passwd root在图形界面</p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p>man 获得帮助信息  man ls查看ls指令,ls .al /root 指定目录下所用的内容</p><p>help获得shell内置命令的帮助信息 ，也可百度</p><h3 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h3><p>ls -a显示所有文件，ls -l以列表形式显示当目录</p><p>cd ~回到自己的家目录 cd ..回到上一级目录</p><p>cd /root绝对路径到root cd ../../root相对路径到root目录</p><p>mkdir 要创建一级目录 mkdir /home /dog -p创建多级目录 mkdir /home/animal /dog</p><p>rmdir 删除非空目录 rm -rf  /home /animal强制删除目录</p><p>touch创建空文件 touch  hello.txt</p><p>cp 拷贝文件到指定目录 cp [选项] source dest    -r递归复制整个文件夹  cp hello.txt /bbb</p><p>cp -r /home/bbb /opt/把bbb文件和下面文件拷贝到opt目录</p><p>rm -f(-f是指是否有提示)/home/hello.txt，rm -r /home/bbb强制删除整个文件夹</p><p>mv 移动文件到目录或重命名  mv old.txt new.txt重命名,mv pig.txt /root移动文件到root目录（也可移动并且重命名）mv /opt/bbb  /home/移动到home目录下</p><p>cat指令查看文件内容  cat -n 显示行号（这个命令只能浏览文件而不能修改文件） </p><p>cat -n /etc/profile|more</p><p>more一般用来交互，查看文件是一个基于vi的编辑器可以与cat一起使用也可以 more 目录</p><p>使用:f可以查看你当前行号， 交互：可以 空格键向下翻</p><p>less 根据显示的需要加载内容对于显示大型文件有较高效率，用来查看文件内容  less /opt/杂文.txt</p><p>输入pagedown是下一页 输入pageup是上一页 /字串向下搜寻字串功能 n向下查找N向上查找</p><p>echo 输出环境变量 echo $HOSTNAME ,echo “hello” 输出hello</p><p>head 文件查看头文件10行内容 head -n 5 文件(比如etc/profile)查看文件头5行内容</p><p>tail 输出文件中尾部内容 与head同理 tail -f实时追踪该文档的更新，退出ctrl+c</p><p>输出重定向&gt;和&gt;&gt;追加，如： ls -l &gt; 文件 列表的内容覆盖写入文件中 ls -l &gt;&gt;文件 文件追加内容 </p><p>cat 文件1 &gt;  文件2 将文件1的内容覆盖到文件2（类似拷贝） ,echo “ok” &gt; 文件，将文件内容覆盖为“ok”</p><p>In 软连接 （相当于快捷方式） In -s 文件或目录 软连接名（如果cd 软连接名相当于进入该目录）</p><p>如果删除就是用 rm （注意最后不要带上斜杠否则代表这是一个目录）</p><p>history查看执行过的历史命令 history 10显示最近10条指令</p><h3 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h3><p>date 显示当前时间 date + %Y像是年份  date “+%Y-%m%d“显示年月日 H M S时分秒</p><p>date -s 字符串时间，设置日期   </p><p>cal查看日历指令   cal 2020显示2020年所有日历</p><h3 id="搜索查找指令"><a href="#搜索查找指令" class="headerlink" title="搜索查找指令"></a>搜索查找指令</h3><p>find 指令  -name指定文件名 -user指定用户 -size 指定文件大小</p><p>如 find /home -name hello.txt ,find / -szie  +(-) 200M(k，G)</p><p>ls -lh更加人性化查看方式</p><p>locate指令，快出定位文件路径，无需遍历整个文件，查找速度快，该指令执行之前必须下必须先执行updatedb命令</p><p>which 查看指令在哪个目录下 如which ls</p><p>grep指令(过滤指令，查找内容)和管道符号|表示将前一个命令处理结果输出传给后面一个指令处理</p><p>cat /home/hello.txt :|grep -n “yes”,或者grop -n “yes” /home/hello.txt  -i忽略大小写</p><h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><p>gzip 用于压缩文件， gunzip用于解压的</p><p>zip用于压缩文件和文件夹 unzip用于解压的文件夹的</p><p>zip -r myhome.zip /home/将home目录以及其包含文件和子文件都压缩</p><p>unzio -d  /opt/temp myhome.zip 将文件解压到对应目录下</p><p>tar指令是打包指令 打包后文件是 .tar.gz文件  -c产生打包文件 -v显示像是信息 -z打包同时压缩  -x解包</p><p>tar -zcvf pc.tar.gz /home/pig.txt   tar-zxvf home/pc.tar.gz -C /opt/tmp2  解压到哪个目录 -C</p><h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><p>linux用户必须属于一个组，不能独立于组外</p><p>所有者：文件由谁拥有  所在组：文件拥有者所在的组 其他组：不在文件所在组上</p><p>查看所有者(第三列)  ls -ahl   修改文件所有者 chown 用户名 文件名</p><p>组的创建 groupadd 组名  创建一个用户fox放入组中 useradd -g monster fox</p><p>修改文件所在的组 chgrp 组名 文件名(目录)</p><p>改变用户所在的组：usermod -g 组名 用户名，usermod -d 目录名 用户名 改变用户登录的初始目录</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>第0位确定文件类型 d, -,l,c,b   l:链接 ，d是目录，c是字符设备比如鼠标键盘， b是块设备比如硬盘 ，-代表是普通文件</p><p>第1-3位确定文件所用者拥有该文件的权限  </p><p>第4-6位确定所属组（同用户组的）所拥有文件的权限</p><p>第7-9位确定其他用户拥有该文件的权限</p><p>rwx到文件：r代表可读 w代表可修改但是不代表可以删除一个文件删除一个文件代表对目录有写权限 x代表可执行</p><p>rwx到目录 r代表可以读取，ls查看目录内容，w代表可写：对目录内创建修改删除文件 x可以进入该目录</p><p>r=4,w=2,x=1 rwx=7      1：硬链接树或子目录数</p><p>修改权限chmod  </p><p>第一种方式 + - = 变更权限 ，u：所有者 g:所有者 o:其他人  a:所有人</p><p>chmod u=rwx,g =rx,o=x 文件/目录名,chmod o+w,chmod a-x</p><p>chmod 755 目录=chmod  rwxr-xr-xmu’lu</p><p>修改文件所有者 chown </p><p>chown newowner（tom）  文件/目录改变所有者</p><p>chown newowner:newgroup 文件目录  改变所有者和所在组  -R将目录下所有文件改变所有者</p><p>chgrp 修改文件所在组 chgrp newgroup 文件/目录  -R同理</p><h3 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h3><p>任务调度：系统在某个个时间执行特定的命令或程序</p><p>基本语法 crontab -e  +命令编辑定时任务 -l查询任务 -r删除当前所有的任务</p><p>5个星号分别表示从分 时 天 月 星期几如 <em>/1</em>***  +命令 表示每分钟执行</p><p>，表示不连续的时间 -代表范围 8 */n每个多久执行  0 5 * * 1-6周一到周六5点执行（注意星期几和几号最好不要同时出现否则容易混乱）</p><p>crontab -r终止任务调度 crontab -l列出当前有哪些任务进度 service crond restart重启任务调度</p><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><p>at命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行，使用at命令一定要保证atd进程的启动，默认情况下，atd守护进程每60秒检查作业队列，有作业时会检查作业运行时间，如果时间与当前时间匹配则运行此任务</p><p>ps -ef 当前执行的进程有哪些 | grep atd  过滤atd 检测atd是否运行</p><p>每隔60秒对每个作业(队列)执行一次，任务执行完就出列</p><p>at [选项] [时间] 回车  ctrl+D（两次）结束at命令输入  <a href="https://www.cnblogs.com/mq0036/p/14645726.html">at的选项</a></p><p>at指定时间的方法 <a href="https://idc.wanyunshuju.com/cym/120a.html">at命令在指定的时间执行</a></p><p>删除已经设置的任务 atrm 编号</p><h3 id="磁盘分区机制"><a href="#磁盘分区机制" class="headerlink" title="磁盘分区机制"></a>磁盘分区机制</h3><p>linux分区只有一个根目录，一个独立且唯一的文件结构，每个分区用来组成文件系统的一部分，linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，将一个分区和一个目录联系起来，这是载入的一个分区将使它的存储空间在一个目录下获得。、</p><p>linux硬盘分为IDE (hdx<del>)和 SCSI(sdx</del>)目前基本上是SCSI硬盘</p><h3 id="磁盘的挂载与应用"><a href="#磁盘的挂载与应用" class="headerlink" title="磁盘的挂载与应用"></a>磁盘的挂载与应用</h3><p>分配新的硬盘空间：虚拟机右键设置-硬盘-设置大小（重启后可查看硬盘）</p><p>lsblk (查看硬盘使用情况)</p><p>分区命令 fdisk /dev/sdb  输入m可增加分区，然后输入w确认分区退出（q）</p><p>mkfs -t ext4 /dev/sdb 格式化硬盘</p><p>mount /dev/sdb1  /newdisk挂载到newdisk文件夹下</p><p>卸载: umount /dev/sdb1 或者umount newdisk</p><p>但是用命令行挂载如果重启就会消失  永久挂载通过修改/etc/fstab实现挂载，添加完成后执行 mount -a即可生效![1628254946502](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1628254946502.png)</p><p>注意永久挂载如果错误使用会进入紧急模式而开不了机</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><p>查询整体磁盘使用情况 df -h</p><p>查询指定目录的磁盘占用情况 du -h 目录 否则默认为当前目录  -a含文件 -s大小汇总 -max-depth=1查询深度为1 </p><p>ls- l /opt|grep “^-“ |wc -l；统计opt文件夹下文件个数，ls- l /opt|grep “^d” |wc -l 统计Opt文件夹下 目录的个数</p><p>ls- lR /opt|grep “^d” |wc -l 统计opt文件夹下文件个数包括子文件个数</p><p>树状显示目录结构tree 目录，如果没有tree 则使用 yum install tree  </p><h3 id="NAT网络配置"><a href="#NAT网络配置" class="headerlink" title="NAT网络配置"></a>NAT网络配置</h3><p>查看windows网络配置 ipconfig</p><p>查看Linux网络配置 ifconfig</p><p>ip只要在同一网段就可以互相通信</p><h3 id="linux网络配置"><a href="#linux网络配置" class="headerlink" title="linux网络配置"></a>linux网络配置</h3><p>第一种方法：自动获取 缺点：每次获取的Ip地址可能不一样  在ipv4下查看</p><p>第二种方法：指定ip,直接修改配置文件来指定IP，并可以连接到外网</p><p>编辑 vi/etc/sysconfig/network-srcipts/ifcfg-ens33</p><p>要求：将IP地址配置的静态的，</p><p>service network restart 或者 reboot     </p><h3 id="设置主机名和host"><a href="#设置主机名和host" class="headerlink" title="设置主机名和host"></a>设置主机名和host</h3><p>指令hostname查看主机名</p><p>修改文件在 /etc/hostname 指定修改主机名 修改后重启生效</p><p>设置hosts映射</p><p>host文件记录主机和ip的映射关系</p><p>在linux  通过主机名找到某个linux系统  在/etc/hosts 指定</p><p>如192.168.200.1  think-pad</p><p>DNS 是互联网作为域名和ip地址相互映射的一个分布式系统</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>ps 查看当前系统哪些进程正在执行  ps -a 显示所有进程信息</p><p>ps -u 以用户格式显示进程信息  ps -x显示后台进程运行的参数</p><p>ps显示的信息：ity终端信息 stat -运行状态 start开始时间  time-占用cpu时间</p><p>command 执行该进程的指令，vsz占用虚拟内存情况 rss占用物理内存大小，mem占用物理内存百分比 ppid父进程</p><p>ps -aux |grep sshd 检测有无sshd服务</p><p>ps -ef以全格式显示当前所有的进程 -e是显示所有进程 -f全格式</p><p>终止进程：  kill [选型]  进程号   ，killall 进程名称 杀死所有进程子进程也结束</p><p>-9强迫进程立即停止</p><p>/bin/systemctl start  sshd.service重启sshd</p><p>查看进程数 pstree 选项  -p显示进程Pid   -u树状形式显示进程用户</p><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务本质就是进程但是运行在后台通常会监听某个端口，等待其他程序的请求</p><p>service 服务名 [start|stop|restart|reload|status]   </p><p>service指令主要用在etc/init.d目录下管理</p><p>centos7.0后很多服务不用service指令而用systemctl</p><p>查看服务名setup 就可看到全部服务  如果前面带星号说明linux开机自动启动，如果去掉需要手动启动</p><p>服务的运行级别  0：系统停机状态 1单用户工作状态  2多用户状态  3 完全多用户</p><p>简化的命令更换级别 init 0</p><p>4系统未使用 5 x11控制台  6系统正常关闭并重启</p><p>systemctl -get-default查看当前运行级别，systemstl -set-default multi-user.target运行级别3  graphical.target运行级别5</p><p>chkconfig 可以给服务的各个运行级别设置自启动/关闭,自启动是针对不同级别的</p><p>chkconfig指令管理服务 在etc/init.d查看</p><p>chkconfig  服务名 –list，chkcongfig –level 5 服务名 on/off</p><p>systemctl  [start|stop|restart|status] 服务名   该指令管理的服务在  /user/lib/systemd/system查看</p><p>systemctl list-unit-files  查看服务开机启动状态</p><p>systemctl enable 服务名  设置服务开机启动   systemctl  disable 服务名   关闭服务开机启动 （意思是三个级别都启动）</p><p>systemctl  is-enabled 服务名  查看服务是否已经启动</p><p>关闭启动防火墙服务只是临时生效，最终还是需要systemctl  disabled enable</p><p>打开端口指令 firewall-cmd –permanent –add-port=端口号/协议</p><p>关闭端口指令 firewall-cmd –permanent –remove-port=端口号/协议  111/tcp</p><p>重新载入，才能生效  firewall-cmd –reload</p><p>查询端口时候开放： firewall-cmd –query-port=端口/协议</p><p>netstat  -anp |more 查询端口协议</p><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top显示正在执行进程，在执行一段时间可以更新正在运行的进程</p><p>top [选项]  -d 秒数  每隔几秒刷新 -i不显示任何闲置或将死进程 -p  通过指定监控进程id来仅仅监控某个进程的状态</p><p>top交互操作输入P以cpu使用率排序  M以内存 N以PID排序 q退出top</p><p>监控特定用户  先输入top  输入u  在输入用户名</p><p>终止指令进程 top  然后输入k  然后输入pid </p><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>netstat 查看系统网络状态  -an按一定顺序排列输出 -p显示哪个进程在调用</p><h3 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h3><p>查询以安装的rpm了列表 rpm -qa| grep xx 查看是否安装什么包</p><p>rpm -q 软件包名  查询该软件包是否安装</p><p>rpm -qi 软件包名 查询软件包信息  ，rpm -ql 软件包名 查询软件包中的文件，rpm -qf 文件全路径名 查询文件所属的软件包</p><p>rpm -e 软件包名  卸载rpm包</p><p>rpm -ivh rpm包全路径名称  安装rpm包  i=安装  v=提示 h=进度条</p><p>卸载的时候 -nodeps强制卸载但是有可能导致另外一个包无法使用</p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>shell前端软件包管理器，基于rpm管理能够从指定雾浮起自动下载rpm包并且安装</p><p>yum list | grep xx软件列表 ， yum install xx下载安装</p><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>虚拟机可以快照，但实体机无法做快照，所以要备份和恢复技术</p><p>1、把需要的文件用tar打包就行，下次需要恢复的时候，在解压开覆盖即可</p><p>2、使用dump和restore命令</p><p>#yum -y install dump</p><p>#yum -y install restore</p><p>dump支持分卷和增量备份</p><p>dump [-c]  [目录或文件系统]</p><p>-c创建新的归档文件吗，并将一个或多个文件参数所指定的内容写入归档文件的开头</p><p>-t 指定文件名，若该文件在备份文件中，则列出名</p><p>-u 备份完毕后，在/etc/dumpdares中记录备份的文件系统，层级，日期和时间，只支持分区</p><p>-0123456789 0为最完整的备份，回备份所有文件</p><p>-j 自动调用压缩工具打包文件</p><p>-W 显示需要备份文件及其最后一次备份的层级，时间，日期</p><p>cat /etc/dumpdates查看备份时间文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uj -f /opt/boot.bak0.bz2 /boot  将备份boot分区</span><br></pre></td></tr></table></figure><p>只有分区才支持增量分区，如果是目录或者文件则不支持增量备份</p><p>restore 命令用来恢复已经备份的文件</p><p>restore [模式选项] [选项] </p><p>-C使用对比模式  -i使用交互模式，-r进行还原模式  -t查看模式看备份文件有哪些文件</p><p><strong>增量恢复要依次执行</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
