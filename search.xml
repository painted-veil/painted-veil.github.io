<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell学习笔记</title>
      <link href="/2021/08/16/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/16/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><p>shell是一个命令 解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动挂起甚至编写一些程序</p><h4 id="脚本格式要求"><a href="#脚本格式要求" class="headerlink" title="脚本格式要求"></a>脚本格式要求</h4><p>#！/bin/bash开头，脚本需要有可执行权限</p><p>shell脚本后缀以sh结尾</p><p>如#！/bin/bash echo”hello world”</p><p>然后加入执行权限chmod u+x   hello.sh</p><p>脚本常用的执行权限</p><h4 id="脚本的执行方式"><a href="#脚本的执行方式" class="headerlink" title="脚本的执行方式"></a>脚本的执行方式</h4><p>1、sh+脚本（有无执行权限都可以） sh hello.sh(亦可以使用绝对路径)</p><p>2、绝对路径或者相对路径（有执行权限）</p><h3 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h3><p>系统变量  如$home、$PWD、$SHELL</p><p>显示当前shell所有变量 set</p><p>shell变量的定义</p><p>定义变量 变量名=值    </p><p>撤销变量  unset 变量</p><p>设置静态变量 readonly 变量 ,如果声明了静态变量则不可以unset</p><p>输出变量需要&amp;  echo &amp;A</p><p>变量等号两侧不可以有空格，变量名称一般习惯为大写</p><p>A=‘date’   运行里面的命令并将结果返回A，如果不加反引号则代表把date这个字符串赋值给A</p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>export 变量名=变量值 （将shell变量输出为环境变量/全局变量）</p><p>source  配置文件（将修改后的配置信息立即生效）</p><p>echo $变量名 查询环境变量的值，再输出环境变量是要source让配置文件生效</p><p>多行注释   开头!&lt;&lt;!   结尾！</p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用位置参数变量</p><p>$n  n为数字 10以上的参数需要大括号包含如 ${10}</p><p>$*把所有参数看成一个整体</p><p>$@代表命令行的所有参数，不过$@把每个参数区分对待</p><p>$#这个变量代表命令行中所有参数的个数</p><p>echo “0=$0 1=$1”</p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>$$当前进程进程号</p><p>$！后台运行最后一个进程进程号</p><p>$？最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，反之相反</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>$((运算式))或者$[运算式] 或者expr m+n，如果用expr要 *</p><p>注意exxpr运算符要有空格</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>[condition],注意condition前后要有空格,即使为空也要空格  0为true ,&gt;1为false</p><p>两个整数比较 -lt,-le,-eq,-gt,-ge  字符串比较=</p><p>文件类型判断 -f,-e</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;ok&quot;</span> = <span class="string">&quot;ok&quot;</span> ] </span><br><span class="line"></span><br><span class="line">then </span><br><span class="line"></span><br><span class="line">​echo <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">fi（代表语句结束）</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f  /root/shode/aaa.txt ]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​echo <span class="string">&quot;start&quot;</span></span><br><span class="line"></span><br><span class="line">fi（代表语句结束)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [条件判断式]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​代码</span><br><span class="line"></span><br><span class="line">elif(条件判断式)</span><br><span class="line"></span><br><span class="line">​代码</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case 语句  $变量名 in</span><br><span class="line"></span><br><span class="line">“值1”）</span><br><span class="line"></span><br><span class="line">如果变量等于1，则执行</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">&quot;值2&quot;)</span><br><span class="line"></span><br><span class="line">如果变量等于2，则执行</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot;  $*被当作一个整体只会输出一句话</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in &quot;$@&quot;  $@被当分别对待有几个参数则输出几句</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for ((初始值;循环控制条件;变量变化))</span><br><span class="line">do</span><br><span class="line">echo &quot;null&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [条件判断式]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="read读取控制"><a href="#read读取控制" class="headerlink" title="read读取控制"></a>read读取控制</h3><p>read(选项)(参数)</p><p>选项-p 指定读取值时的提示符,-t指定读取值时的等待时间，如果没有在指定时间内输入则不再等待</p><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p>basename 返回完整路径 /的部分，常用于获取文件名</p><p>basename [pathname] [suffix]</p><p>如 basename home/bin/aa.txt,返回aaa.txt</p><p>basename home/bin/aa.txt.txt 返回aaa</p><p>dirname  返回完整路径/前面的部分，常用于获取路径名</p><p>dirname /home/aaa/bbb/aa.txt  返回/home/aaa/bbb</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>[ function ] funname [()]</p><p>{</p><p>​    Action</p><p>​    [return int;]</p><p>}</p><p>调用直接写函数名  funname [值]</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getsum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum=$[$n1+$n2]</span><br><span class="line">echo <span class="string">&quot;$sum&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">调用自定义函数</span><br><span class="line">getsum $n1 $n2</span><br><span class="line">输入两个值</span><br><span class="line">read -p <span class="string">&quot;输入n1=&quot;</span> n1</span><br><span class="line">read -p <span class="string">&quot;输入n2=&quot;</span> n2</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>日志文件是重要系统信息文件，记录许多重要的系统事件，同时日志对于安全来说可以通过日志来检查错误发生的原因或者收到攻击时攻击者留下的痕迹，是一种用来记录重大事件的工具</p><p>绝大部分的日志文件所在目录：/var/log</p><p>系统启动日志/var/log/boot.log</p><p>/var/log/cron，系统定时任务的相关日志</p><p>/var/log/lastlog 直接用指令lastlog查看，记录用户最后一次登录时间的日志，这个文件也是二进制文件</p><p>/var/log/maillog 记录邮件信息的日志</p><p>/var/log/message 记录重要信息的日志</p><p>/var/log/secure 记录验证和授权方面的信息，只要涉及账户密码都会记录</p><p>/var/tun/lump记录当前登录用户的信息，这个文件会随着用户的登录和注销而不断发生变化  要用who 、users等命令查看</p><h4 id="日志服务管理"><a href="#日志服务管理" class="headerlink" title="日志服务管理"></a>日志服务管理</h4><p>centos7.6日志服务是：rsylogd（后台程序服务管理日志）/etc/rsyslog.conf配置文件控制该服务</p><p> 查询linux中的rsyslogd服务是否启动：ps aux| grep “rsylogd” |grep -v “grep”</p><p>日志文件包含以下四种内容</p><p>1、事件产生的事件 2 、产生事件的服务器的主机名 3、产生事件的服务名或程序名  4、事件的具体信息</p><p>也可以增加自己的日志文件</p><h4 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h4><p>把旧的日志文件移动并改名，同时建立新的空的日志文件，当旧日志文件超出保存范围之后就会进行删除</p><p>/etc/logrotate/conf全局日志论题规则，可以单独给某个日志文件指定策略</p><p>如果没有dateext参数（用日期作为文件后缀）当进行一次日志论题，当前的日志会自动改名，然后新建日志用来保存新的日志</p><p>![日志轮替](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1629524576241.png)</p><p>把自己日志加入日志轮替</p><p>第一种是直接再logrotate.conf配置文件写入该日志的轮替策略</p><p>第二种是在/var/logrotate.d/目录种建立该日志的轮替文件，再该轮替文件中写入正确的轮替策略，因为该目录的文件都会被 “include”到主配置文件中，所以也可以把日志加u轮替（同时可读性和管理也比较好）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">添加自定义轮替规则</span><br><span class="line">/var/log/hsp.log</span><br><span class="line">&#123;</span><br><span class="line">missingok</span><br><span class="line">daily</span><br><span class="line">copytruncate</span><br><span class="line">rotate 7</span><br><span class="line">notifempty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志轮替机制"><a href="#日志轮替机制" class="headerlink" title="日志轮替机制"></a>日志轮替机制</h4><p>依赖系统的定时任务在/etc/cron.daily/目录，就会发现这个目录使用logrotate文件（可执行），logrotate通过这个文件依赖定时任务执行</p><h4 id="内存日志"><a href="#内存日志" class="headerlink" title="内存日志"></a>内存日志</h4><p>内存日志一旦重启就会清空</p><p>journalctl  可以查看内存日志   </p><p>journalctl -n 3 查看最新3条  journalctl -p err 报错日志</p><p>journalctl -since 19:00  –until 19:10:10 查看起始时间到结束时间</p><p>journalctl -o verbose日志详细内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker学习笔记</title>
      <link href="/2021/08/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/13/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>centos7安装docker</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh get-docker.sh   </span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version </span><br></pre></td></tr></table></figure><p>检查版本是否安装成功</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker </span><br></pre></td></tr></table></figure><p>开启docker服务端</p><h3 id="创建容器镜像"><a href="#创建容器镜像" class="headerlink" title="创建容器镜像"></a>创建容器镜像</h3><p>容器相当于镜像，镜像是只读的，容器是可读写的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run ubuntu</span><br></pre></td></tr></table></figure><p>拉取一个名为ubuntu的镜像，注意镜像名有有要求，在dockerhub拉取的，所以名字不能乱取</p><h3 id="容器的相关命令"><a href="#容器的相关命令" class="headerlink" title="容器的相关命令"></a>容器的相关命令</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>输入命令后，就会显示出当前已经存在的容器，并且会列出对应的信息。</p><ul><li><p>CONTAINER ID : 容器对应的ID，这个是唯一的</p></li><li><p>IMAGE : 使用的镜像名称，显示不同</p></li><li><p>COMMAND : 执行的相关命令</p></li><li><p>CREATED: 创建的时间</p></li><li><p>STATUS: 目前镜像的状态，一般会有两种状态Up和Exited.</p></li><li><p>PORTS: 协议和端口</p></li><li><p>NAMES: 容器的名称，名字是Docker随机生成的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure></li></ul><p>查看docker所有存在镜像包括停止的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop &lt;name or ID&gt;</span><br></pre></td></tr></table></figure><p>停止容器的相关命令</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm &lt;name or ID&gt;</span><br></pre></td></tr></table></figure><p>删除容器相关的命令</p><h3 id="多容器操作"><a href="#多容器操作" class="headerlink" title="多容器操作"></a>多容器操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ps -aq</span><br></pre></td></tr></table></figure><p>查看所有容器的命令号</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ps -qa)</span><br></pre></td></tr></table></figure><p>得到所有命令号停止</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm $(docker container ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有容器</p><p> 正在运行的容器，是不可以直接删除的，会报错。我们来做个实验。新建一个容器. 要先停止再删除或者强制删除正在运行的容器</p><h3 id="端口映射以及主动模式和被动模式"><a href="#端口映射以及主动模式和被动模式" class="headerlink" title="端口映射以及主动模式和被动模式"></a>端口映射以及主动模式和被动模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 80:80 nginx</span><br></pre></td></tr></table></figure><p> 确定docker对应的容器端口是多少。比如Nginx镜像的端口诗<code>80</code>。知道这个端口后，就可以在启动容器的时候，用<code>-p </code> 的形式，启用映射了。 </p><p> 等待项目启动后，打开浏览器窗口，在地址栏输入<code>127.0.0.1</code>，就可以打开nginx的默认网址 </p><h4 id="主动模式attach模式"><a href="#主动模式attach模式" class="headerlink" title="主动模式attach模式"></a>主动模式attach模式</h4><p> 当打开<code>127.0.0.1</code>网址的时候，终端上打印出了相关的日志（log），平且每访问一次，都会增加一条日志。也就是说Docker容器的日志会实时的展现到窗口并且占用此端口。这种模式叫做attached模式。 </p><h4 id="detach模式"><a href="#detach模式" class="headerlink" title="detach模式"></a>detach模式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">90</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>这次你会看到，和<code>attached</code>模式不同的是，这次输入完命令后，只显示出了容器的编号，并且可以再输入任何命令。就算我们关掉窗口，容器依然运行，也就是他是在系统后台进行运行的。</p><p>这种就比较适合在生产环境中运行，停掉和删除容器都需要使用<code>Shell脚本</code>的形式。减少了很多误操作。</p><p>输入127.0.01:90就可以通过90端口访问</p><h4 id="detach模式转为attach模式"><a href="#detach模式转为attach模式" class="headerlink" title="detach模式转为attach模式"></a>detach模式转为attach模式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  attach &lt;ID or Image Name&gt;</span><br></pre></td></tr></table></figure><h4 id="detach模式查看日志"><a href="#detach模式查看日志" class="headerlink" title="detach模式查看日志"></a>detach模式查看日志</h4><p>先复习一下上节课的内容，用<code>detached</code>模式开启一个<code>nginx</code>服务，并映射服务器的<code>80端口</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>容器被运行起来了，是<code>detached</code>模式，也就是Docker 的后台运行模式。这时候想要查看后台日志，可以使用下面的命令查看。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs &lt;ID or Image name&gt;</span><br></pre></td></tr></table></figure><p>虽然日志在窗口中出现了，但只打印一次<code>logs</code>,如果想动态一直跟踪日志，可以在命令上加入一个<code>-f</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs -f &lt;ID or Image name&gt;</span><br></pre></td></tr></table></figure><h3 id="docker交互模式"><a href="#docker交互模式" class="headerlink" title="docker交互模式"></a>docker交互模式</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu sh</span><br></pre></td></tr></table></figure><p><code>-it</code>代表启用交互模式，<code>sh</code>代表可以使用Shell脚本。当你输入玩这个脚本后，Docker就会进入到交互模式。可以使用<code>ls</code>来得到目录下的文件，也可以使用<code>hostname</code>来查看计算机名称。</p><p> 这时候你想退出容器和交互模式可以输入<code>exit</code>命令。需要重点说明的是，随着命令退出后，容器也会跟着退出，变成<code>Exited</code>模式。 </p><p>如果我们想退出交互，但是并不想停止容器。可以先开启<code>detached模式</code>，然后通过命令进入交互模式。</p><p>再用<code>detached模式</code>创建一个<code>nginx镜像</code>的容器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>直接通过下面的命令就可以进入到交互模式下了。（重要）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;ID or Image name&gt; sh </span><br></pre></td></tr></table></figure><p><code>exec</code>是执行的意思，<code>-it</code>交互模式 ， <code>sh</code>交互的方式，用shell脚本进行交互</p><h3 id="镜像获取拉取删除"><a href="#镜像获取拉取删除" class="headerlink" title="镜像获取拉取删除"></a>镜像获取拉取删除</h3><h4 id="镜像的获取"><a href="#镜像的获取" class="headerlink" title="镜像的获取"></a>镜像的获取</h4><ul><li><p>从网络社区直接拉取，在Docker里这种社区叫做<code>Registry</code>(登记处)（pull from registry）</p></li><li><p>从Dockerfile构建一个镜像，这是DIY一个镜像，同时整个构建过程是需要联网，因为需要西在基础镜像，然后根据基础镜像进行构建（build from Dockerfile）。</p></li><li><p>自有文件的导入，可以从本地导入已经构建好的镜像文件，在没有网络的时候可以用。这个文件是通过已有的镜像导出来的压缩包，然后就可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image</span><br></pre></td></tr></table></figure><p> 对于Image操作的所有命令和提示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull wordpress</span><br></pre></td></tr></table></figure></li></ul><p>拉取wordpress镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>查看镜像列表的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull wordpress:cli-php8.0</span><br></pre></td></tr></table></figure><p>下载对应版本的镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect baf</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm &lt;Image ID&gt;</span><br></pre></td></tr></table></figure><h4 id="镜像导入导出"><a href="#镜像导入导出" class="headerlink" title="镜像导入导出"></a>镜像导入导出</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image save busybox:latest -o mybusybox.image</span><br></pre></td></tr></table></figure><p><code>save</code>是导出/保存的意思，<code>busybox:latest</code>是镜像名称+版本号， <code>-o</code>代表输出，<code>mybusybox.image</code>是导出后镜像的名字。</p><p>导入镜像步骤</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm busybox</span><br></pre></td></tr></table></figure><p>删除后直接导入镜像。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image load -i .\mybusybox.image</span><br></pre></td></tr></table></figure><h3 id="dockfile"><a href="#dockfile" class="headerlink" title="dockfile"></a>dockfile</h3><p> Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。 </p><ul><li><p>Dockerfile是用于构建docker镜像的文件</p></li><li><p>Dockerfile里包含了构建镜像所需的”指令“</p></li><li><p>Dockerfile有其特定的语法规则</p><h4 id="dockerfile-文件编写"><a href="#dockerfile-文件编写" class="headerlink" title="dockerfile 文件编写"></a>dockerfile 文件编写</h4><p>首先装一个Ubuntu系统。</p><p>第二步，下载安装Python环境</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3<span class="number">.9</span> python3-pip python3<span class="number">.9</span>-dev</span><br></pre></td></tr></table></figure><p>第三步，准备<code>jspang.py</code>文件。这个可以在<code>D盘</code>新建一个<code>DockerTest文件夹</code>，然后在文件夹中新建一个<code>jspang.py</code>文件，然后编写下面的文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello JSPang&quot;</span>)</span><br></pre></td></tr></table></figure><p>第四步，运行jspang.py</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 hello.py</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>编写Dockerfile文件（建议把Dockerfile文件和jspang.py文件放在一起个文件夹下）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN  apt-get update &amp;&amp; \</span><br><span class="line">         DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3<span class="number">.9</span> python3-pip python3<span class="number">.9</span>-dev</span><br><span class="line">ADD jspang.py /</span><br><span class="line">CMD [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;jspang.py&quot;</span>]</span><br></pre></td></tr></table></figure></li></ul><p>有了<code>Dockerfile</code>和<code>jspang.py</code>文件以后，通过<code>PowerShell</code>进入到两个文件的文件夹。通过Docker命令就可以完成构建。</p><h4 id="通过dockerfile构建镜像"><a href="#通过dockerfile构建镜像" class="headerlink" title="通过dockerfile构建镜像"></a>通过dockerfile构建镜像</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t &lt;Name:tag&gt; <span class="xml"><span class="tag">&lt;<span class="name">file</span> <span class="attr">path</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过已经写好的Dockerfile，构建一个<code>jspang</code>的镜像，可以使用下面的命令构建。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t jspang .</span><br></pre></td></tr></table></figure><p>（注意命令最后是有一个<code>.</code>的），如果是第一次执行打包，这个过程还比较久的，当出现FINISHED后，说明打包完成了。</p><p>打包完成后，可以通过<code>docker image ls</code>命令来查看现在拥有的镜像列表。如果一切正常，可以看到名字为<code>jspang</code>的镜像已经存在了。</p><p>可以执行容器，验证一下自己DIY的镜像是否可用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run jspang</span><br></pre></td></tr></table></figure><p>镜像如果正常，应该正确现实出<code>Hello JSPang</code>字样，然后就直接退出容器了。这是跟我们写的Dockerfile有关的。</p><p>，就是重新<code>build</code>一个镜像，。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t jspangcom/jspang .</span><br></pre></td></tr></table></figure><p>也可以通过<code>docker image tag</code>命令，具体语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag &lt;old image name &gt; <span class="xml"><span class="tag">&lt;<span class="name">new</span> <span class="attr">iamge</span> <span class="attr">name</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>例如把<code>jspang</code>这个镜像，改为<code>jspangcom/jspang</code>镜像,命令可以如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag jspang jspangcom/jspang</span><br></pre></td></tr></table></figure><h4 id="dockerfile语法"><a href="#dockerfile语法" class="headerlink" title="dockerfile语法"></a>dockerfile语法</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux和虚拟机学习笔记</title>
      <link href="/2021/07/23/linux%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/23/linux%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="网路连接三种模式"><a href="#网路连接三种模式" class="headerlink" title="网路连接三种模式"></a>网路连接三种模式</h3><p>1、桥接模式：虚拟系统和外部系统通讯，但是造成Ip冲突</p><p>2、NAT模式：网络哟地址转换模式，虚拟系统可以和外部系统通讯，不造成Ip冲突（能够代理出来但不能回去）</p><p>3、主机模式：主机系统</p><h3 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h3><p>1、使用vmware的克隆操作，克隆要关闭Linux系统，，直接右键点击虚拟机-管理-克隆-创建完整的克隆-克隆完直接打开-剩下步骤和安装虚拟机相同</p><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>如果在使用虚拟机系统的时候，想回到原先的某一个状态，担心有些操作造成系统异常，需要回到某个正常运行的状态——快照管理</p><p>方法：右键虚拟机-快照-拍摄的快照-利用快照管理器转到该状态即可（在哪拍快照意味这在此开一个分支）当然每次快照都会占用磁盘空间</p><h3 id="虚拟机的迁移和删除"><a href="#虚拟机的迁移和删除" class="headerlink" title="虚拟机的迁移和删除"></a>虚拟机的迁移和删除</h3><p>迁移：直接虚拟机文件夹迁移，删除：直接磁盘文件删除（彻底）或者直接虚拟机内部文件夹删除（部分）</p><h3 id="利用vmtool实现文件共享"><a href="#利用vmtool实现文件共享" class="headerlink" title="利用vmtool实现文件共享"></a>利用vmtool实现文件共享</h3><p>安装完vmtool之后（需要gcc），利用设置设置共享文件夹，在linux中mmt文件夹下</p><h3 id="linux的目录结构"><a href="#linux的目录结构" class="headerlink" title="linux的目录结构"></a>linux的目录结构</h3><p>树状结构-把硬件都映射为文件，从根目录</p><p>/bin-是binary的缩写，目录存放最经常使用的指令。/sbin-存放系统管理员使用的系统管理程序</p><p>/root-该目录为系统管理员，也称作超级权限者用户主目录。</p><p>/lost+found-（隐藏，通过终端进入）一般为空，当系统非法关机就存放一些文件。</p><p>/lib-系统开机所需要最基本的动态连接共享库，其作用类似于windows的dll文件，几乎所有程序都需要这种共享库。</p><p>/etc-所有系统管理所需要的配置文件和子目录。</p><p>/user-用户应用程序和文件都放在这个programfile目录中。/user/local另一个注解额外安装软件所存放的目录</p><p>/boot启动Linux使用的一些核心文件。/proc(不能动)虚拟目录是系统内存的映射</p><p>/srv-(不能动)服务启动所需要的临时文件。/sys-(不能动)该目录安装了2.6内核下一个新的文件系统</p><p>/tmp存放临时文件。/dev-把所有硬件用文件存储/media自动识别的文件，/media-linux会把识别的设备挂载到这个目录之中</p><p>/mnt-让用户临时挂载别的文件系统。/opt-主机额外安装软件所存放的目录</p><p>/var这个目录存放不断被扩充东西，一般为各种经常修改的日志文件</p><p>/selinux-是一种安全子系统，他能控制程序访问特定文件</p><h3 id="linux远程登录和linux远程文件传输"><a href="#linux远程登录和linux远程文件传输" class="headerlink" title="linux远程登录和linux远程文件传输"></a>linux远程登录和linux远程文件传输</h3><p>远程登录linux进行项目管理和开发</p><p>远程登录：xshell 文件xftp6</p><p>查询ip地址ifconfig  然后ping +ip地址判断两者之间有无联网</p><p>利用xftp进行文件传输             （乱码则在属性改为utf-8)</p><h3 id="vi和vim的基本使用"><a href="#vi和vim的基本使用" class="headerlink" title="vi和vim的基本使用"></a>vi和vim的基本使用</h3><p>正常模式：vim打开一个档案直接进入一般模式</p><p>插入模式：按下i I,O o,A,a,r，R按任何一个字母会进入编辑模式</p><p>命令行模式：可以提供相关指令，完成读取，存盘，替换等vim操作，输入esc转为正常模式在输入‘：’或者‘ / ’从其他模式进入命令行模式 ，wq保存退出，q!强制退出不保存， q退出不保存</p><p>拷贝当前行（一般模式下）yy 然后p (粘贴) 拷贝多行 4yy（拷贝往上4行）然后输入p</p><p>删除当前行dd同时删除5行5dd，查找某个单词 （命令行模式下）/hello查找单词hello，输入n就是查找下一个</p><p>设置\取消文件的行号（命令行模式） ‘:set nu’\   ‘:set npnu’</p><p>定位文档最末行G最首行gg在(一般模式),撤销这个动作(一般模式) u</p><p>编辑文件定位(一般模式下)‘20gg’或’20G‘(定位到20行)</p><h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><p>shutdown -h now 立刻进行关机</p><p>shudown -h 1 1分钟后关机</p><p>shutdown -r now 现在重新启动计算机   halt关机 reboot重启</p><p>sync内存数据同步到磁盘，无论重启还是关闭系统首先要运行sync命令，但目前关机重启指令都在关机前执行sync</p><h3 id="用户登录注销"><a href="#用户登录注销" class="headerlink" title="用户登录注销"></a>用户登录注销</h3><p>su - (用户名)  su - root 切换系统管理员身份（获取最大权限）  logout可以注销用户，root执行logout就会回到登录的身份如jesse,(logout在图形运行级别无效，在运行级别3有效)</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>添加一个用户 useradd 用户名 某人该用户的家目录在 /home/用户名会自动创建和用户名同名的家目录 useradd -d /home/test king 在test下创建一个用户king的家目录</p><p>passwd 用户名  指定密码否则如果不写用户名就是当前用户的密码</p><p>pwd显示当前用户在哪一个目录下</p><p>删除用户 userdel  用户名（要切成root删除用户）这是保留家目录的</p><p>userdel  -r 用户名 这是删除家目录的 （注意会把tom全部删除）</p><p>一般情况下建议保留家目录</p><p>查询用户信息 id 用户名，  who am i 查询当前用户信息</p><p>高权限用户到低权限用户不用输密码</p><p>用户组：系统对用共性的多个用户进行统一的股那里</p><p>groupadd 组名 （添加组）groupdel  组名（删除组）</p><p>useradd -g 用户组 用户名 增加用户名的同时增加组</p><p>usermod -g 用户组 用户名 修改用户的组</p><p>/etc/passwd 文件 用户的配置文件，记录用户各种信息</p><p>/etc /shadow 文件 口令配置文件 /etc/group 组的配置文件</p><p>/etc/group文件组的配置文件</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><p>运行级别：0关机1单用户 2多用户无网络 3多用户有玩咯4 系统未使用保留给用户 </p><p>5图形界面6系统重启 </p><p>init 切换不同的运行级别</p><p>systemctl get-default查看当前默认级别 </p><p><a href="https://zhuanlan.zhihu.com/p/102802164">找回root密码</a>或者passwd root在图形界面</p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p>man 获得帮助信息  man ls查看ls指令,ls .al /root 指定目录下所用的内容</p><p>help获得shell内置命令的帮助信息 ，也可百度</p><h3 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h3><p>ls -a显示所有文件，ls -l以列表形式显示当目录</p><p>cd ~回到自己的家目录 cd ..回到上一级目录</p><p>cd /root绝对路径到root cd ../../root相对路径到root目录</p><p>mkdir 要创建一级目录 mkdir /home /dog -p创建多级目录 mkdir /home/animal /dog</p><p>rmdir 删除非空目录 rm -rf  /home /animal强制删除目录</p><p>touch创建空文件 touch  hello.txt</p><p>cp 拷贝文件到指定目录 cp [选项] source dest    -r递归复制整个文件夹  cp hello.txt /bbb</p><p>cp -r /home/bbb /opt/把bbb文件和下面文件拷贝到opt目录</p><p>rm -f(-f是指是否有提示)/home/hello.txt，rm -r /home/bbb强制删除整个文件夹</p><p>mv 移动文件到目录或重命名  mv old.txt new.txt重命名,mv pig.txt /root移动文件到root目录（也可移动并且重命名）mv /opt/bbb  /home/移动到home目录下</p><p>cat指令查看文件内容  cat -n 显示行号（这个命令只能浏览文件而不能修改文件） </p><p>cat -n /etc/profile|more</p><p>more一般用来交互，查看文件是一个基于vi的编辑器可以与cat一起使用也可以 more 目录</p><p>使用:f可以查看你当前行号， 交互：可以 空格键向下翻</p><p>less 根据显示的需要加载内容对于显示大型文件有较高效率，用来查看文件内容  less /opt/杂文.txt</p><p>输入pagedown是下一页 输入pageup是上一页 /字串向下搜寻字串功能 n向下查找N向上查找</p><p>echo 输出环境变量 echo $HOSTNAME ,echo “hello” 输出hello</p><p>head 文件查看头文件10行内容 head -n 5 文件(比如etc/profile)查看文件头5行内容</p><p>tail 输出文件中尾部内容 与head同理 tail -f实时追踪该文档的更新，退出ctrl+c</p><p>输出重定向&gt;和&gt;&gt;追加，如： ls -l &gt; 文件 列表的内容覆盖写入文件中 ls -l &gt;&gt;文件 文件追加内容 </p><p>cat 文件1 &gt;  文件2 将文件1的内容覆盖到文件2（类似拷贝） ,echo “ok” &gt; 文件，将文件内容覆盖为“ok”</p><p>In 软连接 （相当于快捷方式） In -s 文件或目录 软连接名（如果cd 软连接名相当于进入该目录）</p><p>如果删除就是用 rm （注意最后不要带上斜杠否则代表这是一个目录）</p><p>history查看执行过的历史命令 history 10显示最近10条指令</p><h3 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h3><p>date 显示当前时间 date + %Y像是年份  date “+%Y-%m%d“显示年月日 H M S时分秒</p><p>date -s 字符串时间，设置日期   </p><p>cal查看日历指令   cal 2020显示2020年所有日历</p><h3 id="搜索查找指令"><a href="#搜索查找指令" class="headerlink" title="搜索查找指令"></a>搜索查找指令</h3><p>find 指令  -name指定文件名 -user指定用户 -size 指定文件大小</p><p>如 find /home -name hello.txt ,find / -szie  +(-) 200M(k，G)</p><p>ls -lh更加人性化查看方式</p><p>locate指令，快出定位文件路径，无需遍历整个文件，查找速度快，该指令执行之前必须下必须先执行updatedb命令</p><p>which 查看指令在哪个目录下 如which ls</p><p>grep指令(过滤指令，查找内容)和管道符号|表示将前一个命令处理结果输出传给后面一个指令处理</p><p>cat /home/hello.txt :|grep -n “yes”,或者grop -n “yes” /home/hello.txt  -i忽略大小写</p><h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><p>gzip 用于压缩文件， gunzip用于解压的</p><p>zip用于压缩文件和文件夹 unzip用于解压的文件夹的</p><p>zip -r myhome.zip /home/将home目录以及其包含文件和子文件都压缩</p><p>unzio -d  /opt/temp myhome.zip 将文件解压到对应目录下</p><p>tar指令是打包指令 打包后文件是 .tar.gz文件  -c产生打包文件 -v显示像是信息 -z打包同时压缩  -x解包</p><p>tar -zcvf pc.tar.gz /home/pig.txt   tar-zxvf home/pc.tar.gz -C /opt/tmp2  解压到哪个目录 -C</p><h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><p>linux用户必须属于一个组，不能独立于组外</p><p>所有者：文件由谁拥有  所在组：文件拥有者所在的组 其他组：不在文件所在组上</p><p>查看所有者(第三列)  ls -ahl   修改文件所有者 chown 用户名 文件名</p><p>组的创建 groupadd 组名  创建一个用户fox放入组中 useradd -g monster fox</p><p>修改文件所在的组 chgrp 组名 文件名(目录)</p><p>改变用户所在的组：usermod -g 组名 用户名，usermod -d 目录名 用户名 改变用户登录的初始目录</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>第0位确定文件类型 d, -,l,c,b   l:链接 ，d是目录，c是字符设备比如鼠标键盘， b是块设备比如硬盘 ，-代表是普通文件</p><p>第1-3位确定文件所用者拥有该文件的权限  </p><p>第4-6位确定所属组（同用户组的）所拥有文件的权限</p><p>第7-9位确定其他用户拥有该文件的权限</p><p>rwx到文件：r代表可读 w代表可修改但是不代表可以删除一个文件删除一个文件代表对目录有写权限 x代表可执行</p><p>rwx到目录 r代表可以读取，ls查看目录内容，w代表可写：对目录内创建修改删除文件 x可以进入该目录</p><p>r=4,w=2,x=1 rwx=7      1：硬链接树或子目录数</p><p>修改权限chmod  </p><p>第一种方式 + - = 变更权限 ，u：所有者 g:所有者 o:其他人  a:所有人</p><p>chmod u=rwx,g =rx,o=x 文件/目录名,chmod o+w,chmod a-x</p><p>chmod 755 目录=chmod  rwxr-xr-xmu’lu</p><p>修改文件所有者 chown </p><p>chown newowner（tom）  文件/目录改变所有者</p><p>chown newowner:newgroup 文件目录  改变所有者和所在组  -R将目录下所有文件改变所有者</p><p>chgrp 修改文件所在组 chgrp newgroup 文件/目录  -R同理</p><h3 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h3><p>任务调度：系统在某个个时间执行特定的命令或程序</p><p>基本语法 crontab -e  +命令编辑定时任务 -l查询任务 -r删除当前所有的任务</p><p>5个星号分别表示从分 时 天 月 星期几如 <em>/1</em>***  +命令 表示每分钟执行</p><p>，表示不连续的时间 -代表范围 8 */n每个多久执行  0 5 * * 1-6周一到周六5点执行（注意星期几和几号最好不要同时出现否则容易混乱）</p><p>crontab -r终止任务调度 crontab -l列出当前有哪些任务进度 service crond restart重启任务调度</p><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><p>at命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行，使用at命令一定要保证atd进程的启动，默认情况下，atd守护进程每60秒检查作业队列，有作业时会检查作业运行时间，如果时间与当前时间匹配则运行此任务</p><p>ps -ef 当前执行的进程有哪些 | grep atd  过滤atd 检测atd是否运行</p><p>每隔60秒对每个作业(队列)执行一次，任务执行完就出列</p><p>at [选项] [时间] 回车  ctrl+D（两次）结束at命令输入  <a href="https://www.cnblogs.com/mq0036/p/14645726.html">at的选项</a></p><p>at指定时间的方法 <a href="https://idc.wanyunshuju.com/cym/120a.html">at命令在指定的时间执行</a></p><p>删除已经设置的任务 atrm 编号</p><h3 id="磁盘分区机制"><a href="#磁盘分区机制" class="headerlink" title="磁盘分区机制"></a>磁盘分区机制</h3><p>linux分区只有一个根目录，一个独立且唯一的文件结构，每个分区用来组成文件系统的一部分，linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，将一个分区和一个目录联系起来，这是载入的一个分区将使它的存储空间在一个目录下获得。、</p><p>linux硬盘分为IDE (hdx<del>)和 SCSI(sdx</del>)目前基本上是SCSI硬盘</p><h3 id="磁盘的挂载与应用"><a href="#磁盘的挂载与应用" class="headerlink" title="磁盘的挂载与应用"></a>磁盘的挂载与应用</h3><p>分配新的硬盘空间：虚拟机右键设置-硬盘-设置大小（重启后可查看硬盘）</p><p>lsblk (查看硬盘使用情况)</p><p>分区命令 fdisk /dev/sdb  输入m可增加分区，然后输入w确认分区退出（q）</p><p>mkfs -t ext4 /dev/sdb 格式化硬盘</p><p>mount /dev/sdb1  /newdisk挂载到newdisk文件夹下</p><p>卸载: umount /dev/sdb1 或者umount newdisk</p><p>但是用命令行挂载如果重启就会消失  永久挂载通过修改/etc/fstab实现挂载，添加完成后执行 mount -a即可生效![1628254946502](C:\Users\chen jesse\AppData\Roaming\Typora\typora-user-images\1628254946502.png)</p><p>注意永久挂载如果错误使用会进入紧急模式而开不了机</p><h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><p>查询整体磁盘使用情况 df -h</p><p>查询指定目录的磁盘占用情况 du -h 目录 否则默认为当前目录  -a含文件 -s大小汇总 -max-depth=1查询深度为1 </p><p>ls- l /opt|grep “^-“ |wc -l；统计opt文件夹下文件个数，ls- l /opt|grep “^d” |wc -l 统计Opt文件夹下 目录的个数</p><p>ls- lR /opt|grep “^d” |wc -l 统计opt文件夹下文件个数包括子文件个数</p><p>树状显示目录结构tree 目录，如果没有tree 则使用 yum install tree  </p><h3 id="NAT网络配置"><a href="#NAT网络配置" class="headerlink" title="NAT网络配置"></a>NAT网络配置</h3><p>查看windows网络配置 ipconfig</p><p>查看Linux网络配置 ifconfig</p><p>ip只要在同一网段就可以互相通信</p><h3 id="linux网络配置"><a href="#linux网络配置" class="headerlink" title="linux网络配置"></a>linux网络配置</h3><p>第一种方法：自动获取 缺点：每次获取的Ip地址可能不一样  在ipv4下查看</p><p>第二种方法：指定ip,直接修改配置文件来指定IP，并可以连接到外网</p><p>编辑 vi/etc/sysconfig/network-srcipts/ifcfg-ens33</p><p>要求：将IP地址配置的静态的，</p><p>service network restart 或者 reboot     </p><h3 id="设置主机名和host"><a href="#设置主机名和host" class="headerlink" title="设置主机名和host"></a>设置主机名和host</h3><p>指令hostname查看主机名</p><p>修改文件在 /etc/hostname 指定修改主机名 修改后重启生效</p><p>设置hosts映射</p><p>host文件记录主机和ip的映射关系</p><p>在linux  通过主机名找到某个linux系统  在/etc/hosts 指定</p><p>如192.168.200.1  think-pad</p><p>DNS 是互联网作为域名和ip地址相互映射的一个分布式系统</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>ps 查看当前系统哪些进程正在执行  ps -a 显示所有进程信息</p><p>ps -u 以用户格式显示进程信息  ps -x显示后台进程运行的参数</p><p>ps显示的信息：ity终端信息 stat -运行状态 start开始时间  time-占用cpu时间</p><p>command 执行该进程的指令，vsz占用虚拟内存情况 rss占用物理内存大小，mem占用物理内存百分比 ppid父进程</p><p>ps -aux |grep sshd 检测有无sshd服务</p><p>ps -ef以全格式显示当前所有的进程 -e是显示所有进程 -f全格式</p><p>终止进程：  kill [选型]  进程号   ，killall 进程名称 杀死所有进程子进程也结束</p><p>-9强迫进程立即停止</p><p>/bin/systemctl start  sshd.service重启sshd</p><p>查看进程数 pstree 选项  -p显示进程Pid   -u树状形式显示进程用户</p><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务本质就是进程但是运行在后台通常会监听某个端口，等待其他程序的请求</p><p>service 服务名 [start|stop|restart|reload|status]   </p><p>service指令主要用在etc/init.d目录下管理</p><p>centos7.0后很多服务不用service指令而用systemctl</p><p>查看服务名setup 就可看到全部服务  如果前面带星号说明linux开机自动启动，如果去掉需要手动启动</p><p>服务的运行级别  0：系统停机状态 1单用户工作状态  2多用户状态  3 完全多用户</p><p>简化的命令更换级别 init 0</p><p>4系统未使用 5 x11控制台  6系统正常关闭并重启</p><p>systemctl -get-default查看当前运行级别，systemstl -set-default multi-user.target运行级别3  graphical.target运行级别5</p><p>chkconfig 可以给服务的各个运行级别设置自启动/关闭,自启动是针对不同级别的</p><p>chkconfig指令管理服务 在etc/init.d查看</p><p>chkconfig  服务名 –list，chkcongfig –level 5 服务名 on/off</p><p>systemctl  [start|stop|restart|status] 服务名   该指令管理的服务在  /user/lib/systemd/system查看</p><p>systemctl list-unit-files  查看服务开机启动状态</p><p>systemctl enable 服务名  设置服务开机启动   systemctl  disable 服务名   关闭服务开机启动 （意思是三个级别都启动）</p><p>systemctl  is-enabled 服务名  查看服务是否已经启动</p><p>关闭启动防火墙服务只是临时生效，最终还是需要systemctl  disabled enable</p><p>打开端口指令 firewall-cmd –permanent –add-port=端口号/协议</p><p>关闭端口指令 firewall-cmd –permanent –remove-port=端口号/协议  111/tcp</p><p>重新载入，才能生效  firewall-cmd –reload</p><p>查询端口时候开放： firewall-cmd –query-port=端口/协议</p><p>netstat  -anp |more 查询端口协议</p><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top显示正在执行进程，在执行一段时间可以更新正在运行的进程</p><p>top [选项]  -d 秒数  每隔几秒刷新 -i不显示任何闲置或将死进程 -p  通过指定监控进程id来仅仅监控某个进程的状态</p><p>top交互操作输入P以cpu使用率排序  M以内存 N以PID排序 q退出top</p><p>监控特定用户  先输入top  输入u  在输入用户名</p><p>终止指令进程 top  然后输入k  然后输入pid </p><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>netstat 查看系统网络状态  -an按一定顺序排列输出 -p显示哪个进程在调用</p><h3 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h3><p>查询以安装的rpm了列表 rpm -qa| grep xx 查看是否安装什么包</p><p>rpm -q 软件包名  查询该软件包是否安装</p><p>rpm -qi 软件包名 查询软件包信息  ，rpm -ql 软件包名 查询软件包中的文件，rpm -qf 文件全路径名 查询文件所属的软件包</p><p>rpm -e 软件包名  卸载rpm包</p><p>rpm -ivh rpm包全路径名称  安装rpm包  i=安装  v=提示 h=进度条</p><p>卸载的时候 -nodeps强制卸载但是有可能导致另外一个包无法使用</p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>shell前端软件包管理器，基于rpm管理能够从指定雾浮起自动下载rpm包并且安装</p><p>yum list | grep xx软件列表 ， yum install xx下载安装</p><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>虚拟机可以快照，但实体机无法做快照，所以要备份和恢复技术</p><p>1、把需要的文件用tar打包就行，下次需要恢复的时候，在解压开覆盖即可</p><p>2、使用dump和restore命令</p><p>#yum -y install dump</p><p>#yum -y install restore</p><p>dump支持分卷和增量备份</p><p>dump [-c]  [目录或文件系统]</p><p>-c创建新的归档文件吗，并将一个或多个文件参数所指定的内容写入归档文件的开头</p><p>-t 指定文件名，若该文件在备份文件中，则列出名</p><p>-u 备份完毕后，在/etc/dumpdares中记录备份的文件系统，层级，日期和时间，只支持分区</p><p>-0123456789 0为最完整的备份，回备份所有文件</p><p>-j 自动调用压缩工具打包文件</p><p>-W 显示需要备份文件及其最后一次备份的层级，时间，日期</p><p>cat /etc/dumpdates查看备份时间文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uj -f /opt/boot.bak0.bz2 /boot  将备份boot分区</span><br></pre></td></tr></table></figure><p>只有分区才支持增量分区，如果是目录或者文件则不支持增量备份</p><p>restore 命令用来恢复已经备份的文件</p><p>restore [模式选项] [选项] </p><p>-C使用对比模式  -i使用交互模式，-r进行还原模式  -t查看模式看备份文件有哪些文件</p><p><strong>增量恢复要依次执行</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-docker"><a href="#title-docker" class="headerlink" title="title:docker"></a>title:docker</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标题测试</title>
      <link href="/2021/07/22/%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/07/22/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>这是我的第一篇博客</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
